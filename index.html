<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Matrix">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Matrix">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Matrix</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Matrix</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">just do it !</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/06/Hadoop-Spark-in-WSL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/06/Hadoop-Spark-in-WSL/" itemprop="url">Hadoop + Spark in WSL</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-06T22:49:08+08:00">
                2019-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hadoop-Spark-环境配置"><a href="#Hadoop-Spark-环境配置" class="headerlink" title="Hadoop + Spark 环境配置"></a>Hadoop + Spark 环境配置</h1><p>北航大数据导论课设需要</p>
<p>笔者是在<code>WSL(Windows Subsystem for Linux)</code> 或者 直接在<code>Ubuntu</code>双系统上</p>
<h2 id="安装SSH"><a href="#安装SSH" class="headerlink" title="安装SSH"></a>安装SSH</h2><p>打开终端</p>
<ol>
<li>安装<code>SSH</code><ol>
<li><code>sudo apt-get update</code></li>
<li><code>sudo apt-get install openssh-server</code></li>
</ol>
</li>
<li>运行<code>SSH</code><ol>
<li>生成密匙 : <ol>
<li><code>ssh-keygen -t rsa -P &#39;&#39; -f ~/.ssh/id_rsa</code></li>
<li><code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></li>
</ol>
</li>
<li>连接本机检查是否安装成功<ol>
<li><code>ssh localhost</code>连接</li>
<li><code>exit</code>退出</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>笔者遇到的问题</strong> : 在运行<code>ssh localhost</code>之后出现以下报错</p>
<ol>
<li><p>报错信息 : <code>connect to host localhost port 22: Connection refused</code> </p>
<p>原因 : <code>ssh</code>服务没有开启</p>
<p>解决 : </p>
<ul>
<li><p>检查<code>ssh</code>服务是否运行 : <code>/etc/init.d/ssh status</code></p>
<p>返回 <code>* sshd is not running</code> 说明没有开启</p>
</li>
<li><p>开启<code>ssh</code>服务 : <code>/etc/init.d/ssh start</code></p>
</li>
</ul>
</li>
<li><p>报错信息 : <code>Permission denied (publickey)</code></p>
<p>原因 : 目录权限设置不对</p>
<p>解决 : 设置权限</p>
<ul>
<li><code>chmod go-w ~/</code></li>
<li><code>chmod 700 ~/.ssh</code></li>
<li><code>chmod 600 ~/.ssh/authorized_keys</code></li>
</ul>
</li>
</ol>
<p>最终成功之后运行<code>ssh location</code>结果为</p>
<p><img src="/2019/09/06/Hadoop-Spark-in-WSL/ssh.png" alt></p>
<h2 id="配置Java环境"><a href="#配置Java环境" class="headerlink" title="配置Java环境"></a>配置Java环境</h2><p>注意 : </p>
<ol>
<li>根据自己下载的<code>JDK</code>的版本要更改配置或者命令行中的文件名</li>
<li>万能大法 : 命令失败时先加<code>sudo</code>试试</li>
</ol>
<p>流程 : </p>
<h3 id="下载安装JDK"><a href="#下载安装JDK" class="headerlink" title="下载安装JDK"></a>下载安装JDK</h3><ol>
<li><p>下载<code>JDK</code>安装包 : <a href="https://www.oracle.com/java/technologies/javase-jsp-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-jsp-downloads.html</a></p>
<p>以笔者下载的<code>jdk-8u221-linux-x64.tar.gz</code>为例</p>
</li>
<li><p>新建<code>/usr/local/java</code>目录, 存放各个版本的<code>JDk</code></p>
</li>
<li><p>解压文件到2中目录下 : <code>tar -zxvf jdk-8u144-linux-x64.tar.gz -C /usr/local/java/</code></p>
</li>
<li><p>为方便起见将其重命名为<code>java1.8</code> : <code>mv jdk1.8.0_221 java1.8</code></p>
</li>
</ol>
<h3 id="设置系统变量"><a href="#设置系统变量" class="headerlink" title="设置系统变量"></a>设置系统变量</h3><ol>
<li><p><code>sudo vim /etc/profile</code>(直接配置全局环境,配置该用户环境修改<code>~/.bashrc</code>)</p>
</li>
<li><p>在最后一行加上<code>java</code>系统变量路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java1.8		//该路径视自己情况定</span><br><span class="line">export JAVA_BIN=$JAVA_HOME/bin</span><br><span class="line">export JAVA_LIB=$JAVA_HOME/lib</span><br><span class="line">export CLASSPATH=.:$JAVA_LIB/tools.jar:$JAVA_LIB/dt.jar </span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>source /etc/profile</code>使配置生效</p>
</li>
</ol>
<h3 id="检查配置是否成功"><a href="#检查配置是否成功" class="headerlink" title="检查配置是否成功"></a>检查配置是否成功</h3><p>运行<code>java -version</code>,应当返回<code>JDK</code>的版本信息 :</p>
<p><img src="/2019/09/06/Hadoop-Spark-in-WSL/java.png" alt></p>
<h2 id="安装Hadoop并配置单机版"><a href="#安装Hadoop并配置单机版" class="headerlink" title="安装Hadoop并配置单机版"></a>安装Hadoop并配置单机版</h2><p>注 : 以下大部分地址时国内镜像,可能不是最新版本,科学上网选手可以去官网下最新版本</p>
<h3 id="安装Hadoop"><a href="#安装Hadoop" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h3><ol>
<li><p>下载 : <a href="https://mirrors.tuna.tsinghua.edu.cn/apache/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/</a> 为<code></code>Apache`的国内镜像</p>
</li>
<li><p>解压下载文件 : <code>sudo tar zxvf hadoop-2.7.4.tar.gz -C /usr/local</code></p>
</li>
<li><p>为方便起见重命名并赋予权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">sudo mv hadoop-2.7.4 hadoop 	//根据具体版本更改</span><br><span class="line">sudo chmod 777 -R /usr/local/Hadoop</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ol>
<li><p>配置系统变量文件</p>
<ol>
<li><p><code>sudo vim ~/.bashrc</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#HADOOP VARIABLES START </span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8</span><br><span class="line">export HADOOP_INSTALL=/usr/local/hadoop</span><br><span class="line">export PATH=$PATH:$HADOOP_INSTALL/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_INSTALL/sbin</span><br><span class="line">export HADOOP_MAPRED_HOME=$HADOOP_INSTALL </span><br><span class="line">export HADOOP_COMMON_HOME=$HADOOP_INSTALL </span><br><span class="line">export HADOOP_HDFS_HOME=$HADOOP_INSTALL </span><br><span class="line">export YARN_HOME=$HADOOP_INSTALL </span><br><span class="line">export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_INSTALL/lib/native</span><br><span class="line">export HADOOP_OPTS=&quot;-Djava.library.path=$HADOOP_INSTALL/lib&quot;</span><br><span class="line">#HADOOP VARIABLES END</span><br></pre></td></tr></table></figure>
<p><code>source ~/.bashrc</code>生效配置</p>
</li>
<li><p><code>sudo vim /usr/local/hadoop/etc/hadoop/hadoop-env.sh</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># The java implementation to use. </span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8</span><br><span class="line">export HADOOP=/usr/local/hadoop</span><br><span class="line">export PATH=$PATH:/usr/local/hadoop/bin</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sudo vim /usr/local/hadoop/etc/hadoop/yarn-env.sh</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/java/jdk1.8</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>修改<code>Hadoop</code>配置文件</p>
<p>注意 : 确保配置文件中只有一对<code>&lt;configuration&gt; &lt; /configuration &gt;</code></p>
<ol>
<li><p><code>core-site.xml</code></p>
<ul>
<li><p><code>sudo vim /usr/local/hadoop/etc/hadoop/core-site.xml</code></p>
</li>
<li><p>添加以下内容</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>hdfs-site.xml</code></p>
<ul>
<li><p><code>sudo vim /usr/local/hadoop/etc/hadoop/hdfs-site.xml</code></p>
</li>
<li><p>添加以下内容</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.http.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost::50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>yarn-site.xml</code></p>
<ul>
<li><p><code>sudo vim /usr/local/hadoop/etc/hadoop/yarn-site.xml</code></p>
</li>
<li><p>添加以下内容</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services.mapreduce.shuffle.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>127.0.0.1:8032<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>127.0.0.1:8030<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>127.0.0.1:8031<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h3><p>注 : 对<code>hadoop</code>的操作都在<code>/usr/local/hadoop/sbin</code>文件夹的<code>.sh</code>脚本中</p>
<ol>
<li><p><code>hadoop version</code> : 查看<code>hadoop</code>版本信息</p>
<p><img src="/2019/09/06/Hadoop-Spark-in-WSL/hadoop-v.png" alt></p>
</li>
<li><p><code>hdfs namenode -format</code> 格式化<code>namenode</code>(<strong>注意只需要格式化一次,之后不用再格式化</strong>)</p>
<p>注 : 多次格式化之后的补救措施:</p>
<ol>
<li>停止运行 : <code>stop-all.sh</code></li>
<li>删除<code>usr/local/hadoop/tmp/dfs/data</code>文件夹</li>
<li>重新运行</li>
</ol>
</li>
<li><p>启动 : <code>start-all.sh</code></p>
</li>
<li><p><code>jps</code></p>
<p><img src="/2019/09/06/Hadoop-Spark-in-WSL/nodes.png" alt></p>
</li>
<li><p>访问 : <a href="http://localhost:50070/" target="_blank" rel="noopener">http://localhost:50070/</a></p>
<p><img src="/2019/09/06/Hadoop-Spark-in-WSL/50070.png" alt></p>
</li>
<li><p>访问 : <a href="http://localhost:8088/" target="_blank" rel="noopener">http://localhost:8088/</a></p>
<p><img src="/2019/09/06/Hadoop-Spark-in-WSL/8088.png" alt></p>
</li>
<li><p>停止 : <code>stop-all.sh</code></p>
</li>
</ol>
<h2 id="安装Spark"><a href="#安装Spark" class="headerlink" title="安装Spark"></a>安装Spark</h2><h3 id="Scala环境配置"><a href="#Scala环境配置" class="headerlink" title="Scala环境配置"></a>Scala环境配置</h3><ol>
<li><p>下载地址 : <a href="http://distfiles.macports.org/scala2.10/" target="_blank" rel="noopener">http://distfiles.macports.org/scala2.10/</a></p>
</li>
<li><p>解压文件 : <code>sudo tar zxvf scala-2.11.8.tgz -C /usr/local/</code></p>
</li>
<li><p>方便起见重命名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">sudo mv scala-2.11.8 scala</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置系统环境变量</p>
<p><code>sudo vim /etc/profile</code>,添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/java/jdk1.8</span><br><span class="line">SCALA_HOME=/usr/local/scala</span><br><span class="line">PATH=$PATH:$HOME/bin:$JAVA_HOME/bin:$SCALA/bin</span><br><span class="line">export SCALA_HOME</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>
<p><code>source /etc/profile</code>激活</p>
</li>
<li><p>测试 : <code>scala -version</code></p>
</li>
</ol>
<h3 id="Spark安装"><a href="#Spark安装" class="headerlink" title="Spark安装"></a>Spark安装</h3><ol>
<li><p>下载地址 : <a href="https://mirrors.tuna.tsinghua.edu.cn/apache" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache</a></p>
</li>
<li><p>解压 : <code>sudo tar zxvf spark-2.3.1-bin-hadoop2.7.tgz  -C /usr/local/</code></p>
</li>
<li><p>为方便重命名 : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">sudo mv spark-2.3.1-bin-hadoop2.7 spark</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置系统环境变量</p>
<p><code>sudo vim /etc/profile</code>,添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/java/jdk1.8</span><br><span class="line">SCALA_HOME=/usr/local/scala</span><br><span class="line">SPARK_HOME=/usr/local/spark</span><br><span class="line">PATH=$PATH:$HOME/bin:$JAVA_HOME/bin:$SCALA/bin:$SPARK/bin</span><br><span class="line">export SCALA_HOME</span><br><span class="line">export SPARK_HOME</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>
<p><code>source /etc/profile</code>激活</p>
</li>
<li><p>配置<code>spark</code>设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp spark-env.sh.template spark-env.sh</span><br><span class="line">vim spark-env.sh</span><br></pre></td></tr></table></figure>
<p>添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8</span><br><span class="line">export HADOOP_HOME=/usr/local/hadoop</span><br><span class="line">export HADOOP_CONF_DIR=/usr/local/hadoop/etc/hadoop</span><br><span class="line">export SCALA_HOME=/usr/local/scala</span><br><span class="line">export SPARK_HOME=/usr/local/spark</span><br><span class="line">export SPARK_MASTER_HOST=127.0.0.1</span><br><span class="line">export SPARK_MASTER_PORT=7077</span><br><span class="line">export SPARK_MASTER_WEBUI_PORT=8099</span><br><span class="line">export SPARK_LOCAL_IP=127.0.0.1</span><br><span class="line">export SPARK_WORKER_CORES=3</span><br><span class="line">export SPARK_WORKER_INSTANCES=1</span><br><span class="line">export SPARK_WORKER_MEMORY=5G</span><br><span class="line">export SPARK_WORKER_WEBUI_PORT=8081</span><br><span class="line">export SPARK_EXECUTOR_CORES=1</span><br><span class="line">export SPARK_EXECUTOR_MEMORY=1G</span><br><span class="line">export LD_LIBRARY_PATH=$&#123;LD_LIBRARY_PATH&#125;:$HADOOP_HOME/lib/native</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<ol>
<li><p>先启动<code>Hadoop</code></p>
</li>
<li><p>启动<code>Spark</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/spark/sbin</span><br><span class="line">./start-master.sh</span><br><span class="line">./start-slaves.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问 : <a href="http://127.0.0.1:8099/" target="_blank" rel="noopener">http://127.0.0.1:8099/</a></p>
<p><img src="/2019/09/06/Hadoop-Spark-in-WSL/spark.png" alt></p>
</li>
</ol>
</li>
</ol>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p><code>Spark</code>是基于<code>Hadoop</code>的 : </p>
<ol>
<li><code>start-all.sh</code>命令启动<code>Hadoop</code>的节点</li>
<li>进入<code>usr/local/spark/sbin</code>中<code>./start-all.sh</code>启动<code>master</code>和<code>worker</code></li>
<li>先在该目录下<code>./stop-all.sh</code>停止<code>spark</code>服务</li>
<li>在<code>stop-all.sh</code>停止<code>Hadoop</code>服务</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/02/mysql安装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/02/mysql安装/" itemprop="url">mysql安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-02T23:15:37+08:00">
                2019-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="mysql8-0在windows下安装流程"><a href="#mysql8-0在windows下安装流程" class="headerlink" title="mysql8.0在windows下安装流程"></a>mysql8.0在windows下安装流程</h1><ol>
<li><p>下载<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a></p>
</li>
<li><p>将压缩包解压到<code>mysql</code>目录(目录名随意,一致即可)</p>
</li>
<li><p>配置系统变量(<code>mysql</code>的<code>bin</code>目录)  [可选]</p>
</li>
<li><p>在<code>mysql</code>下新建<code>my.ini</code>文件,写入以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[mysqld] </span><br><span class="line"># 设置3306端口</span><br><span class="line">port=3306 </span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir =D:\mysql</span><br><span class="line"># 设置mysql数据库的数据的存放目录，不能自己创建，待会的操作会自动生成</span><br><span class="line">datadir =D:\mysql\data</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=200</span><br><span class="line"># 允许连接失败的次数，防止有人从该主机试图攻击数据库系统</span><br><span class="line">max_connect_errors=10</span><br><span class="line"># 服务端使用的字符集默认为UTF8</span><br><span class="line">character-set-server=utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[client]</span><br><span class="line"># 设置mysql客户端连接服务端时默认使用的端口和字符集</span><br><span class="line">port=3306</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>以<strong>管理员身份</strong>打开<code>cmd</code>并进入<code>bin</code>文件夹</p>
</li>
<li><p><strong>运行<code>mysqld --initialize-insecure --user=mysql</code>在<code>mysql</code>下生成<code>data</code>文件夹</strong></p>
<p>注意 : <strong>一定不要自己创建<code>data</code>文件夹</strong></p>
</li>
<li><p>继续在<code>bin</code>文件夹下运行<code>mysqld --install</code></p>
<p>注 : 移除安装是<code>mysqld remove</code></p>
</li>
<li><p>启动服务 : <code>net start mysql</code></p>
</li>
<li><p>登录 : <code>mysql -uroot -p</code>  初始密码为空回车即可</p>
</li>
<li><p>进入<code>mysql</code>服务</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/21/OS-lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/OS-lab5/" itemprop="url">OS-lab5</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-21T23:33:16+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="lab5做了什么"><a href="#lab5做了什么" class="headerlink" title="lab5做了什么"></a>lab5做了什么</h1><ol>
<li>基于磁盘的硬件构成实现通过<code>I/O</code>接口<strong>驱动</strong>来与磁盘外设进行交互(主要是<strong>屏蔽丑陋的硬件,提供统一的读写接口</strong>)</li>
<li>基于<code>I/O</code>交互以及磁盘的空间搭建文件系统结构(本质上就是用<strong>数据结构</strong>管理磁盘的空间)</li>
<li>基于文件系统来向用户提供操作的接口(以<strong>系统调用</strong>的形式)</li>
</ol>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="外部存储设备驱动"><a href="#外部存储设备驱动" class="headerlink" title="外部存储设备驱动"></a>外部存储设备驱动</h2><p>这部分很依赖于底层硬件的构成标准</p>
<h3 id="磁盘寻址的原理"><a href="#磁盘寻址的原理" class="headerlink" title="磁盘寻址的原理"></a>磁盘寻址的原理</h3><p><del>这部分我们OS实现不用考虑权当复习理论课了</del></p>
<h4 id="地址表达"><a href="#地址表达" class="headerlink" title="地址表达"></a>地址表达</h4><p>一个扇区大小(<strong>有效数据大小为一块即512字节</strong>)为最小的数据交换单元</p>
<ul>
<li><p>物理磁盘使用柱面,磁道,扇区构成<strong>物理地址</strong>来定位一个块, 即</p>
<p><strong>某一磁盘寻址依赖于</strong> : (括号中均为常量)</p>
<ol>
<li>柱面号<code>C_index</code>(一共有<code>C_num</code>个柱面)</li>
<li>磁头号<code>H_index</code>(一共有<code>H_num</code>层磁头)</li>
<li>扇区号<code>S_index</code>(一个磁道有<code>S_num</code>个扇区)</li>
</ol>
<p><img src="/2019/05/21/OS-lab5/disk.png" alt></p>
</li>
<li><p>而<strong>逻辑地址</strong>则将所有扇区抽象成连续的块结构<strong>通过偏移获取</strong></p>
<p><strong>抽象规则为 : <code>offset = C_index * H_num + H_index * S_num + S_index</code></strong></p>
</li>
</ul>
<h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><ol>
<li>OS发出的请求 : 盘号<code>diskno</code> + 偏移<code>offset</code></li>
<li>由盘号定位到某一磁盘接受之后寻址 : <ul>
<li><strong>由逻辑地址向物理地址转换 : </strong><ol>
<li><code>C_index = offset / (H_num * S_num)</code></li>
<li><code>H_index = (offset % (H_num * S_num)) / S_num</code></li>
<li><code>S_index = (offset % (H_num * S_num)) % S_num</code></li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="OS与外设交互的机制"><a href="#OS与外设交互的机制" class="headerlink" title="OS与外设交互的机制"></a>OS与外设交互的机制</h3><p><strong>通过读写设备上的寄存器来进行数据通信</strong> :</p>
<ol>
<li>外设寄存器也称为 I/O 端口，我们使用 I/O 端口来访问 I/O 设备</li>
<li>外设寄存器通常包括控制寄存器、状态寄存器和数据寄存器</li>
<li><strong>这些硬件 I/O 寄存器被映射到指定的物理内存空间(理论上你可以选择映射到任何内核虚拟空间,但由于无缓存我们选择映射到<code>kseg1</code>),即当我们访问这段物理地址时,<code>CPU</code>就会知道其对应的实际物理空间对应的不是物理内存,而是外设中的外设寄存器,例如在读数据时外设将数据写入其内部的存储空间,而我们从<code>kseg1</code>中直接按虚拟地址读取就可以了</strong></li>
</ol>
<p><strong>故我们读写某一固定的物理内存(固定值取决于外设种类对应的规定)就相当于读写外设的寄存器这样我们就能控制其行为</strong></p>
<h3 id="IDE磁盘在硬件层次的规定"><a href="#IDE磁盘在硬件层次的规定" class="headerlink" title="IDE磁盘在硬件层次的规定"></a>IDE磁盘在硬件层次的规定</h3><ul>
<li><p>其映射到的物理内存区域是<code>[0x13000000, 0x13004200)</code></p>
</li>
<li><p>在CPU访问时使用的只能是虚拟地址,所以我们要把这块区域<strong>映射到内核空间的<code>kseg1</code>中(因为这片空间是内核中的,映射固定(加偏移即可),并且数据不会被缓存</strong>,<code>kesg</code>的起始地址为<code>0xA0000000</code>,<strong>所以磁盘外设寄存器对应的虚拟地址为<code>[0xB3000000, 0xB3004200)</code></strong></p>
<p>注意这个映射到的虚拟地址是我们选择的,基于<strong>内核空间所有用户进程都可以访问以及这片虚拟内存不存在缓存</strong></p>
<p><strong>注意在此处涉及内核虚拟地址向物理地址的转换(由硬件实现),其规则如下(<del>我猜的</del>) : </strong></p>
<ul>
<li>对<code>kseg0</code>中的内核虚拟地址通过最高位清0 : 所以我们在之前通过加<code>0x8000_0000</code>实现物理地址映射到<code>kseg0</code></li>
<li><strong>对<code>kseg1</code>中的内核虚拟地址通过最高3位清0 : 所以<code>[0xB3000000, 0xB3004200)</code>即对应物理地址<code>[0x13000000, 0x13004200)</code></strong></li>
</ul>
</li>
<li><p>磁盘各个外设寄存器的意义 : </p>
<p><img src="/2019/05/21/OS-lab5/IDE-regs.png" alt></p>
<p>注意实际上我们只有一块磁盘,所以<code>IDE ID</code>恒为0</p>
</li>
<li><p>所以我们的对磁盘的<code>I/O</code>操作就如下图</p>
<p><img src="/2019/05/21/OS-lab5/w-r.png" alt></p>
</li>
</ul>
<p><strong>注意此处有一点我没有想通的机制 : 就是我们认为从磁盘中读取数据和向磁盘写入数据都是瞬间完成的,没有延时,所以没有实现<code>CPU</code>轮询状态位或者磁盘通知<code>CPU</code>中断类似的机制,我猜时因为我们的外设磁盘是仿真模拟的,所以讲问题简化了</strong></p>
<h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><ol>
<li>实现<strong>用户态对外设寄存器(表现为一段物理地址内存)进行读写的系统调用</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/syscall_all.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_write_dev</span><span class="params">(<span class="keyword">int</span> sysno, u_int va, u_int dev, u_int len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((dev &gt;= <span class="number">0x10000000</span> &amp;&amp; (dev + len - <span class="number">1</span>) &lt; <span class="number">0x10000020</span>) ||</span><br><span class="line">        (dev &gt;= <span class="number">0x13000000</span> &amp;&amp; (dev + len - <span class="number">1</span>) &lt; <span class="number">0x13004200</span>) ||</span><br><span class="line">        (dev &gt;= <span class="number">0x15000000</span> &amp;&amp; (dev + len - <span class="number">1</span>) &lt; <span class="number">0x15000200</span>)) &#123;</span><br><span class="line">        u_long dev_va = dev + <span class="number">0xa0000000</span>;<span class="comment">//将设备物理地址映射到内核kseg1空间</span></span><br><span class="line">        bcopy(va, dev_va, len);<span class="comment">//将va对应的虚拟内存地址之后长len字节的数据写入设备物理地址dev</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_write_dev</span><span class="params">(<span class="keyword">int</span> sysno, u_int va, u_int dev, u_int len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((dev &gt;= <span class="number">0x10000000</span> &amp;&amp; (dev + len - <span class="number">1</span>) &lt; <span class="number">0x10000020</span>) ||</span><br><span class="line">        (dev &gt;= <span class="number">0x13000000</span> &amp;&amp; (dev + len - <span class="number">1</span>) &lt; <span class="number">0x13004200</span>) ||</span><br><span class="line">        (dev &gt;= <span class="number">0x15000000</span> &amp;&amp; (dev + len - <span class="number">1</span>) &lt; <span class="number">0x15000200</span>)) &#123;</span><br><span class="line">        u_long dev_va = dev + <span class="number">0xa0000000</span>;<span class="comment">//将设备物理地址映射到内核kseg1空间</span></span><br><span class="line">        bcopy(dev_va, va, len);<span class="comment">//从设备物理地址dev中读出长len字节的数据写入va对应的虚拟地址中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>实现<strong>用户态</strong>下的磁盘驱动,<strong>对磁盘设备的空间的访问要基于之前实现的用户态系统调用</strong>(因为设备映射的是内核虚拟空间,用户态不能直接访问内核虚拟地址,所以要通过系统调用)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/ide.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ide_read</span><span class="params">(u_int diskno, u_int secno, <span class="keyword">void</span> *dst, u_int nsecs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0x200表示512字节,这是一个扇区的大小</span></span><br><span class="line">	<span class="keyword">int</span> offset_begin = secno * <span class="number">0x200</span>;<span class="comment">//初始扇区地址偏移</span></span><br><span class="line">	<span class="keyword">int</span> offset_end = offset_begin + nsecs * <span class="number">0x200</span>;<span class="comment">//最后一个扇区地址偏移</span></span><br><span class="line">	<span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(offset_begin + offset &lt; offset_end)</span><br><span class="line">	&#123;</span><br><span class="line">         syscall_write_dev(&amp;diskno, <span class="number">0x13000010</span>, <span class="number">4</span>);<span class="comment">//写入磁盘号,理论上恒为0(因为只有一个磁盘)</span></span><br><span class="line">         <span class="keyword">int</span> va = offset_begin + offset;</span><br><span class="line">         syscall_write_dev(&amp;va, <span class="number">0x13000000</span>, <span class="number">4</span>);<span class="comment">//写入偏移量决定操作的磁盘空间位置</span></span><br><span class="line">         <span class="keyword">char</span> operate = <span class="number">0</span>;</span><br><span class="line">         syscall_write_dev(&amp;operate, <span class="number">0x13000020</span>, <span class="number">1</span>);<span class="comment">//写入操作数为0表示读</span></span><br><span class="line">         syscall_read_dev(&amp;va, <span class="number">0x13000030</span>, <span class="number">4</span>);<span class="comment">//读取状态值</span></span><br><span class="line">		<span class="keyword">if</span> (va != <span class="number">0</span>)<span class="comment">//读操作成功,此时数据已经存到了磁盘外设寄存器中</span></span><br><span class="line">		&#123;<span class="comment">//对于读操作先启动磁盘将数据从由offset决定的扇区读出写入磁盘buffer再从buffer中读出到目标用户地址dst中</span></span><br><span class="line">			syscall_read_dev(dst + offset, <span class="number">0x13004000</span>, <span class="number">0x200</span>);</span><br><span class="line">			offset += <span class="number">0x200</span>;		</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			user_panic(<span class="string">"disk I/O error"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ide_write</span><span class="params">(u_int diskno, u_int secno, <span class="keyword">void</span> *src, u_int nsecs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i<span class="comment">//0x200表示512字节,这是一个扇区的大小</span></span><br><span class="line">	<span class="keyword">int</span> offset_begin = secno * <span class="number">0x200</span>;<span class="comment">//初始扇区地址偏移</span></span><br><span class="line">	<span class="keyword">int</span> offset_end = offset_begin + nsecs * <span class="number">0x200</span>;<span class="comment">//最后一个扇区地址偏移</span></span><br><span class="line">	<span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(offset_begin + offset &lt; offset_end)</span><br><span class="line">	&#123;</span><br><span class="line">         syscall_write_dev(&amp;diskno, <span class="number">0x13000010</span>, <span class="number">4</span>);<span class="comment">//写入磁盘号,理论上恒为0(因为只有一个磁盘)</span></span><br><span class="line">         <span class="keyword">int</span> va = offset_begin + offset;</span><br><span class="line">         syscall_write_dev(&amp;va, <span class="number">0x13000000</span>, <span class="number">4</span>);<span class="comment">//写入偏移量决定操作的磁盘空间位置</span></span><br><span class="line">         <span class="comment">//对于写操作先将要写入的数据写到磁盘外设寄存器中的buffer中,在向磁盘写入操作位磁盘自身从buffer中读取数据写入由offset决定的扇区中</span></span><br><span class="line">         syscall_write_dev(src + offset, <span class="number">0x13004000</span>, <span class="number">0x200</span>);</span><br><span class="line">         <span class="keyword">char</span> operate = <span class="number">1</span>;</span><br><span class="line">         syscall_write_dev(&amp;operate, <span class="number">0x13000020</span>, <span class="number">1</span>);<span class="comment">//写入操作数为1表示写</span></span><br><span class="line">         syscall_read_dev(&amp;va, <span class="number">0x13000030</span>, <span class="number">4</span>);<span class="comment">//读取状态值</span></span><br><span class="line">		<span class="keyword">if</span> (va != <span class="number">0</span>) &#123;<span class="comment">//写操作成功</span></span><br><span class="line">			offset += <span class="number">0x200</span>;		</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			user_panic(<span class="string">"disk I/O error"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统实现<strong>对磁盘的空间以文件的形式组织管理</strong></p>
<p><img src="/2019/05/21/OS-lab5/dis_mm.png" alt></p>
<h3 id="磁盘在物理和逻辑层次上的表示"><a href="#磁盘在物理和逻辑层次上的表示" class="headerlink" title="磁盘在物理和逻辑层次上的表示"></a>磁盘在物理和逻辑层次上的表示</h3><p>我们将磁盘的空间抽象成了文件的形式,在物理层次和逻辑层次磁盘空间有不同的划分 :</p>
<ul>
<li><p>物理上 : <strong>以扇区划分,大小为<code>512B</code></strong></p>
<ol>
<li><strong>扇区是块设备传输数据的基本单元</strong>,也就是说它是块设备中最小的寻址单位</li>
<li>体现 : 在磁盘驱动实现中每次偏移加<code>0x200</code></li>
</ol>
</li>
<li><p>逻辑上 : <strong>以数据块划分,大小为<code>4KB</code></strong></p>
<ol>
<li><strong>块是内核对文件系统的一种抽象</strong>,也就是说<code>OS</code>执行的所有磁盘操作都是以块为基本单位的.</li>
<li>体现 : 文件控制块中的数据指针每个指向<code>4KB</code>大小的空间</li>
</ol>
</li>
<li><p><strong>关系</strong> :</p>
<p><strong>扇区是硬件设备传输数据的最小单位,而块是操作系统传输数据的最小单位。一个块通常对应一个或多个相邻的扇区</strong></p>
</li>
</ul>
<h3 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h3><ol>
<li><p>超级块结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/fs.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">	u_int s_magic;		<span class="comment">//魔数用来校验是否合法</span></span><br><span class="line">	u_int s_nblocks;	<span class="comment">//保存该磁盘中的数据块个数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span>	<span class="comment">//文件结构的根目录</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="位图结构"><a href="#位图结构" class="headerlink" title="位图结构"></a>位图结构</h3><p>在该实验中我们使用<code>u_int *bitmap</code>(在<code>fs.c</code>中定义)来实现位图结构</p>
<p><strong>位图结构用来标记某一数据块是否被使用过,一位代表一个数据块, 为1表示空闲,为0表示不可被使用</strong></p>
<ol>
<li><p>初始化 : </p>
<p>所有的存在的块对应的标记位为1,<strong>注意最后一个块标记位之后的位标记为0</strong></p>
</li>
<li><p>释放块,即将对应的标记位标记位1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fs.c</span></span><br><span class="line">u_int *bitmap; <span class="comment">//使用一个int型的数组来实现bitmap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_block</span><span class="params">(u_int blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (blockno==<span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">//0号块是启动引导扇区不允许释放</span></span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	 1. bitmap是int型数组,一个元素占据32位,所以(块号/32)得到表示的整数在数组中的下标</span></span><br><span class="line"><span class="comment">    	 2. (blockno % 32)得到对应的在该整数中的偏移</span></span><br><span class="line"><span class="comment">    	 3. 按位或上 1&lt;&lt;(blockno % 32) [100...00] 即可将对应位设置为1</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        bitmap[blockno/<span class="number">32</span>] = bitmap[blockno/<span class="number">32</span>] | (<span class="number">1</span>&lt;&lt;(blockno%<span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h3><ol>
<li><p>结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/fs.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNAMELEN	128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDIRECT		10</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">	u_char f_name[MAXNAMELEN];	<span class="comment">//文件名</span></span><br><span class="line">	u_int f_size;			   <span class="comment">//文件包含的数据块的字节大小</span></span><br><span class="line">	u_int f_type;			   <span class="comment">//文件的类型</span></span><br><span class="line">	u_int f_direct[NDIRECT];    <span class="comment">//10个直接的数据指针,指向磁盘中组成文件的数据块</span></span><br><span class="line">	u_int f_indirect;		   <span class="comment">//当文件内容过大时使用间接数据指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span>		</span><br><span class="line">	u_char f_pad[<span class="number">256</span>-MAXNAMELEN<span class="number">-4</span><span class="number">-4</span>-NDIRECT*<span class="number">4</span><span class="number">-4</span><span class="number">-4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>直接指针 : 一共有10个,每个指向一个<code>4KB</code>的数据块,所以<strong>只通过直接数据指针最大表示<code>40KB</code>大小的文件</strong></p>
</li>
<li><p>间接指针 : 当文件大小超过<code>40KB</code>时使用 : <strong>其为一个指向(存储(指向(存储文件内容的磁盘块)的指针)的数据块)的指针)</strong>,间接指针指向的还是有个块,但是其<strong>特殊之处在于该块中存储的不是文件的数据内容,而是指向存储文件数据内容的块的指针们</strong></p>
<p>为方便起见在该<strong>特殊的数据块中我们前10个指针缺省,这些由直接指针实现功能</strong></p>
</li>
</ul>
<p><img src="/2019/05/21/OS-lab5/data_point.png" alt></p>
</li>
</ol>
<p><strong>注意</strong> :</p>
<ol>
<li>在我们的体系中, <strong>目录也是文件,是一种特殊的文件而已,特殊之处在于 : </strong><ul>
<li><strong>一般文件的控制块指针指向的数据块存储的是文件自身的数据</strong></li>
<li><strong>目录文件的控制块指针指向的数据块存储的是其目录下包含的文件(或者文件目录)的控制块</strong></li>
</ul>
</li>
<li>我们是用<strong>数组的形式将数据块组织起来的</strong>,所以在文件控制块中我们所谓的指向<strong>数据块的指针其实就是保存该数据块的数组下标即可</strong>(之后统一用指针表达比较形象)</li>
</ol>
<h3 id="如何构建一个文件"><a href="#如何构建一个文件" class="headerlink" title="如何构建一个文件"></a>如何构建一个文件</h3><p>该功能的实现是在<code>fsformat.c</code>中实现,其作用是<strong>基于数个已经存在的源文件将其组织成磁盘上的文件的形式,最后生成<code>fs.img</code>磁盘文件</strong></p>
<h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><ol>
<li>初始化磁盘结构 : <ul>
<li>第一个磁盘块为<code>boot</code>启动块</li>
<li>第二个磁盘块为记录数据块使用情况的位图<code>map</code>块</li>
<li>第三个磁盘块为保存<code>super</code>块</li>
</ul>
</li>
<li>对每个源文件 : <ul>
<li>填写文件控制块</li>
<li>拷贝数据块并建立链接指针</li>
</ul>
</li>
<li>初始位图,标记已经使用的数据块</li>
<li>将构造好的磁盘结构生成文件<code>fs.img</code>文件</li>
</ol>
<p><strong>图示</strong> :</p>
<p><img src="/2019/05/21/OS-lab5/gen_file.png" alt></p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fsformat.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Super</span> <span class="title">Super</span>;</span> <span class="comment">//超级块结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">File</span>;</span>   <span class="comment">//文件控制块结构</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BY2BLK		BY2PG<span class="comment">//4096,即一个块的字节(Byte)数,一个块4KB大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT2BLK		(BY2BLK*8)<span class="comment">//一个块中的位数(Bit)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBLOCK 1024 <span class="comment">// 一个磁盘中的数据块的数目</span></span></span><br><span class="line"><span class="keyword">uint32_t</span> nbitblock; <span class="comment">// bitmap位图结构占据的数据块个数</span></span><br><span class="line"><span class="keyword">uint32_t</span> nextbno;   <span class="comment">// 始终指向当前第一个可用的数据块结构</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> <span class="title">super</span>;</span><span class="comment">//超级块结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;<span class="comment">//块存储的都是数据,但是数据的含义不同</span></span><br><span class="line">    BLOCK_FREE  = <span class="number">0</span>,<span class="comment">//空闲块</span></span><br><span class="line">    BLOCK_BOOT  = <span class="number">1</span>,<span class="comment">//根目录块</span></span><br><span class="line">    BLOCK_BMAP  = <span class="number">2</span>,<span class="comment">//位图结构块</span></span><br><span class="line">    BLOCK_SUPER = <span class="number">3</span>,<span class="comment">//超级块</span></span><br><span class="line">    BLOCK_DATA  = <span class="number">4</span>,<span class="comment">//存储文件数据块</span></span><br><span class="line">    BLOCK_FILE  = <span class="number">5</span>,<span class="comment">//存储文件控制块的块</span></span><br><span class="line">    BLOCK_INDEX = <span class="number">6</span>,<span class="comment">//存储文件控制块中的间接数据指针的块</span></span><br><span class="line">&#125;;<span class="comment">//表示数据块的类型</span></span><br><span class="line"><span class="comment">//与所有数据块对应的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> data[BY2BLK];<span class="comment">//字节数组</span></span><br><span class="line">    <span class="keyword">uint32_t</span> type;</span><br><span class="line">&#125; disk[NBLOCK];<span class="comment">//该数组结构代表一个磁盘中所有可用的数据块</span></span><br></pre></td></tr></table></figure>
<p><strong>注意 : 一个<code>block</code>中存储的数据有多种含义</strong></p>
<h4 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h4><p>函数调用图示 :</p>
<h5 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h5><ol>
<li><p><code>next_block(int type)</code> : 获得<strong>当前可用的第一个数据块下标返回,并设定该块的使用类型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next_block</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    disk[nextbno].type = type;</span><br><span class="line">    <span class="keyword">return</span> nextbno++;<span class="comment">//先return再+++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>save_block_link(struct File *f, int nblk, int bno)</code> : <strong>将第<code>bno</code>个数据块链接到<code>f</code>文件的第<code>nblk</code>个指针</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_block_link</span><span class="params">(struct File *f, <span class="keyword">int</span> nblk, <span class="keyword">int</span> bno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(nblk &lt; NINDIRECT);</span><br><span class="line">    <span class="keyword">if</span>(nblk &lt; NDIRECT) &#123;<span class="comment">//当可以用直接指针表示时</span></span><br><span class="line">        f-&gt;f_direct[nblk] = bno;<span class="comment">//建立映射</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(f-&gt;f_indirect == <span class="number">0</span>) &#123;<span class="comment">//当第一次用间接指针表示时</span></span><br><span class="line">            f-&gt;f_indirect = next_block(BLOCK_INDEX);<span class="comment">//为间接指针分配一个数据块用来存储指向数据块的指针,实际上就是给f_indirect赋值一个空闲块的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*通过disk[f-&gt;f_indirect].data获得存储指针的数据块的数据数组</span></span><br><span class="line"><span class="comment">         *注意此处的强制类型转换不可以少,因为data[]自身是字节数组,但是一个bno占一个字大小</span></span><br><span class="line"><span class="comment">         *所以要(uint32_t *)之后再通过[nblk]索引</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ((<span class="keyword">uint32_t</span> *)(disk[f-&gt;f_indirect].data))[nblk] = bno;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明 : </p>
<ul>
<li><code>#define NINDIRECT  (BY2BLK/4)</code> : <code>NINDIRECT</code>值为1024,即一个文件<strong>最多外接1024个数据块</strong>,这是因为一个文件控制块只有一个间接指针,指向一个<code>4KB</code>大小的存储指针的块,而一个指针<code>4B</code>大小,所以最多存储1024个指向数据块的指针</li>
<li><code>#define NDIRECT 10</code> : 表示一个文件控制块有10个直接指针</li>
</ul>
</li>
<li><p><code>make_link_block(struct File *dirf, int nblk)</code> : <strong>该函数是对目录文件的操作(第一个参数)</strong></p>
<p>为该目录文件控制块的<code>nblk</code>指针<strong>分配一块存储目录下属文件的控制块的块</strong>,增加目录文件的大小并返回分配的块的下标</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_link_block</span><span class="params">(struct File *dirf, <span class="keyword">int</span> nblk)</span> </span>&#123;</span><br><span class="line">    save_block_link(dirf, nblk, nextbno);</span><br><span class="line">    dirf-&gt;f_size += BY2BLK;</span><br><span class="line">    <span class="keyword">return</span> next_block(BLOCK_FILE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>create_file(struct File *dirf)</code> : <strong>该函数是对目录文件的操作(第一个参数)</strong></p>
<p><strong>在目录文件<code>dirf</code>中找到一个可以写入(所属文件的控制块)的空闲数据块地址,返回该地址[当不存在空闲数据区域时新分配数据块用来保存文件控制块]</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct File *<span class="title">create_file</span><span class="params">(struct File *dirf)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dirblk</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i, bno, found;</span><br><span class="line">    <span class="keyword">int</span> nblk = dirf-&gt;f_size / BY2BLK;<span class="comment">//获得当前目录文件有效的数据指针个数</span></span><br><span class="line">    <span class="keyword">if</span>(nblk == <span class="number">0</span>) &#123;<span class="comment">//该目录文件没有数据块,使用make_link_block分配,此时nblk = 0</span></span><br><span class="line">        <span class="keyword">return</span> (struct File *)(disk[make_link_block(dirf, <span class="number">0</span>)].data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nblk &lt;= NDIRECT) &#123;<span class="comment">//还在使用直接数据块指针阶段</span></span><br><span class="line">        bno = dirf-&gt;f_direct[nblk<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//使用间接数据块指针</span></span><br><span class="line">        bno = ((<span class="keyword">uint32_t</span> *)(disk[dirf-&gt;f_indirect].data))[nblk<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//至此获得当前文件最后一个数据块的下标,</span></span><br><span class="line">    <span class="comment">/*之后按文件控制块的大小遍历该数据块</span></span><br><span class="line"><span class="comment">     *检查文件名是否为空来确定是否是空闲文件控制块</span></span><br><span class="line"><span class="comment">     *返回找到的第一个空闲文件控制块的指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    dirblk = (struct File *)(disk[bno].data);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; FILE2BLK; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dirblk[i].f_name[<span class="number">0</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">            <span class="comment">// found spare file link.</span></span><br><span class="line">            <span class="keyword">return</span> &amp;dirblk[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*当最后一个数据块没有空闲文件控制块时</span></span><br><span class="line"><span class="comment">     *给目录文件使用make_link_block新分配一个</span></span><br><span class="line"><span class="comment">     *返回新数据块的首地址(以文件控制块指针的形式)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> (struct File *)(disk[make_link_block(dirf, nblk)].data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意 : 有如下的关系</strong> :</p>
<ul>
<li><strong><code>f_size = nblk * BY2BLK</code> : <code>nblk</code>为该(目录)文件有效的数据块指针的个数</strong></li>
</ul>
</li>
</ol>
<h5 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h5><p><img src="/2019/05/21/OS-lab5/main_call.png" alt></p>
<ol>
<li><p><code>main</code>函数 : 运行生成磁盘镜像文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*参数的含义</span></span><br><span class="line"><span class="comment">     *第一个参数为文件名本身argv[0]</span></span><br><span class="line"><span class="comment">     *第二个参数是产生的磁盘镜像的目标文件路径argv[1]</span></span><br><span class="line"><span class="comment">     *之后的参数是基于的源文件argv[2]...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    init_disk();	<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">"-r"</span>) == <span class="number">0</span> &amp;&amp; argc != <span class="number">4</span>) &#123;<span class="comment">//参数错误</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\Usage: fsformat gxemul/fs.img files...\n\fsformat gxemul/fs.img -r DIR\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">"-r"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">            write_directory(&amp;super.s_root, argv[i]);<span class="comment">//不要求实现</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">            write_file(&amp;super.s_root, argv[i]);<span class="comment">//逐个读取源文件以磁盘文件的形式组织起来</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flush_bitmap();<span class="comment">//改变位图控制块</span></span><br><span class="line">    finish_fs(argv[<span class="number">1</span>]);<span class="comment">//生成目标文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>init_disk()</code> : 初始化磁盘结构</p>
<ul>
<li>第一个块初始化为<code>boot</code></li>
<li>第二个块初始化为<code>super</code></li>
<li>之后若干个需要大小的块初始化为<code>bitmap</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_disk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, r, diff;</span><br><span class="line">    <span class="comment">//第一个块为boot结构</span></span><br><span class="line">    disk[<span class="number">0</span>].type = BLOCK_BOOT;</span><br><span class="line">    <span class="comment">//建立bitmap结构</span></span><br><span class="line">    <span class="comment">//NBLOCK为块的数目,所以应该分配NBLOCK个bit大小来存储bitmap结构</span></span><br><span class="line">    <span class="comment">//(+ BIT2BLK - 1)的操作是因为当填不满某一块时也要分配给bitmap(剩余一部分)</span></span><br><span class="line">    nbitblock = (NBLOCK + BIT2BLK - <span class="number">1</span>) / BIT2BLK;</span><br><span class="line">    nextbno = <span class="number">2</span> + nbitblock;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nbitblock; ++i) &#123;</span><br><span class="line">        disk[<span class="number">2</span>+i].type = BLOCK_BMAP;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//标记可用的位(前3个块在最后标记为不可用)</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nbitblock; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(disk[<span class="number">2</span>+i].data, <span class="number">0xff</span>, NBLOCK/<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当多余的无效的位都标记为0表示不可用</span></span><br><span class="line">    <span class="keyword">if</span>(NBLOCK != nbitblock * BY2BLK) &#123;</span><br><span class="line">        diff = NBLOCK % BY2BLK / <span class="number">8</span>;</span><br><span class="line">        <span class="built_in">memset</span>(disk[<span class="number">2</span>+(nbitblock<span class="number">-1</span>)].data+diff, <span class="number">0x00</span>, BY2BLK - diff);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化super块中的数据</span></span><br><span class="line">    disk[<span class="number">1</span>].type = BLOCK_SUPER;</span><br><span class="line">    super.s_magic = FS_MAGIC;</span><br><span class="line">    super.s_nblocks = NBLOCK;</span><br><span class="line">    super.s_root.f_type = FTYPE_DIR;</span><br><span class="line">    <span class="built_in">strcpy</span>(super.s_root.f_name, <span class="string">"/"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>write_file(struct File *dirf, const char *path)</code> : <strong>将<code>path</code>指定的文件写入<code>dirf</code>文件目录之下</strong></p>
<ol>
<li>为文件新建一个控制块并加入到<code>dirf</code>目录文件中(<code>create_file</code>实现)</li>
<li>填写新建的文件控制块的各个数据域</li>
<li>将文件中的内容拷贝到数据块中并<strong>建立到新建文件控制块的链接</strong> (<code>save_block_link</code>实现)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_file</span><span class="params">(struct File *dirf, <span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iblk = <span class="number">0</span>, r = <span class="number">0</span>, n = <span class="keyword">sizeof</span>(disk[<span class="number">0</span>].data);</span><br><span class="line">    <span class="keyword">uint8_t</span> buffer[n+<span class="number">1</span>], *dist;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">target</span> = <span class="title">create_file</span>(<span class="title">dirf</span>);</span><span class="comment">//将target文件控制块加入dirf目录文件中</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(path, O_RDONLY);<span class="comment">//该处的open是在fcntl.h标准头文件中包含的C标准函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fname = <span class="built_in">strrchr</span>(path, <span class="string">'/'</span>);<span class="comment">//获得最后一个/的位置</span></span><br><span class="line">    <span class="keyword">if</span>(fname)</span><br><span class="line">        fname++;<span class="comment">//找到了之后该位置之后的字符串就是文件名</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fname = path;<span class="comment">//没找到则该path就是顶层,本身就是文件名</span></span><br><span class="line">    <span class="built_in">strcpy</span>(target-&gt;f_name, fname);<span class="comment">//向文件控制块写入文件名</span></span><br><span class="line">    target-&gt;f_size = lseek(fd, <span class="number">0</span>, SEEK_END);<span class="comment">//将文件指针移动到文件末尾,获得文件的大小</span></span><br><span class="line">    target-&gt;f_type = FTYPE_REG;<span class="comment">//该文件类型为常规类型</span></span><br><span class="line">    <span class="comment">//开始遍历path得到的文件将其中的内容写入文件控制块指向的数据块中</span></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);<span class="comment">//将参数移动到文件的头部(偏移为0)</span></span><br><span class="line">    <span class="keyword">while</span>((r = read(fd, disk[nextbno].data, n)) &gt; <span class="number">0</span>) &#123;<span class="comment">//将fd文件中读出的数据写入到disk[nextbno].data中,一次写入一个data块大小(n字节)</span></span><br><span class="line">        save_block_link(target, iblk++, next_block(BLOCK_DATA));<span class="comment">//建立数据块到所属文件控制块的映射</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>flush_bitmap</code> : 将使用过的数据块在位图管理结构<code>bitmap</code>中标记为已使用的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_bitmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//nextbo为使用过的数据块个数</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nextbno; ++i) &#123;</span><br><span class="line">        ((<span class="keyword">uint32_t</span> *)disk[<span class="number">2</span>+i/BIT2BLK].data)[(i%BIT2BLK)/<span class="number">32</span>] &amp;= ~(<span class="number">1</span>&lt;&lt;(i%<span class="number">32</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>finish_fs(char *name)</code> : <strong>根据之前组织好的内存中的数据生成磁盘镜像文件</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish_fs</span><span class="params">(<span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, i, k, n, r;</span><br><span class="line">    <span class="keyword">uint32_t</span> *p;</span><br><span class="line">    <span class="built_in">memcpy</span>(disk[<span class="number">1</span>].data, &amp;super, <span class="keyword">sizeof</span>(super));<span class="comment">//将super放入磁盘第一个数据块</span></span><br><span class="line">    fd = open(name, O_RDWR|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i) &#123;</span><br><span class="line">        reverse_block(disk+i);</span><br><span class="line">        write(fd, disk[i].data, BY2BLK);<span class="comment">//将数据块内容写入文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>最后的文件结构为 :</p>
<p><img src="/2019/05/21/OS-lab5/file_struct.png" alt></p>
<h3 id="块缓存机制"><a href="#块缓存机制" class="headerlink" title="块缓存机制"></a>块缓存机制</h3><p><strong>我们使用磁盘中的数据是通过将其加载到内存中的位置实现的,也就是说我们大部分操作还是对内存中数据进行的</strong></p>
<ol>
<li><p>映射机制</p>
<p>将<code>DISKMA1P</code>到<code>DISKMAP+DISKMAX</code>这一段虚存地址空间 <code>(0x10000000-0xcﬀﬀﬀ)</code>作为缓冲区,当磁盘读入内存时,分配相应的物理页来保存数据,映射关系直接是<strong>地址从低到高,数据块索引从小到大的线性映射</strong></p>
<p><strong>注意 : 在我们的体系中磁盘上的一个数据块大小与内存中的一页相同,都是<code>4KB</code></strong></p>
</li>
<li><p>功能函数 : </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fs.c</span></span><br><span class="line"><span class="comment">//根据数据块索引得到在内存中映射的虚拟地址</span></span><br><span class="line"><span class="function">u_int <span class="title">diskaddr</span><span class="params">(u_int blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( super &amp;&amp; blockno &gt; (super-&gt;s_nblocks)) &#123;</span><br><span class="line">                user_panic(<span class="string">"diskaddr failed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DISKMAP+blockno*BY2BLK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*判断该虚拟页是否有物理页与之对应</span></span><br><span class="line"><span class="comment"> *有返回1,没有返回0</span></span><br><span class="line"><span class="comment"> *通过判断页目录与页表的对应项是否有效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">u_int <span class="title">va_is_mapped</span><span class="params">(u_int va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((*vpd)[PDX(va)] &amp; (PTE_V)) &amp;&amp; ((*vpt)[VPN(va)] &amp; (PTE_V)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*判断该索引的数据块是否在内存中有有效的虚拟页对应</span></span><br><span class="line"><span class="comment"> *如果有返回va值,没有返回0</span></span><br><span class="line"><span class="comment"> *通过判断其映射的虚拟地址是否与物理页与之对应</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">u_int <span class="title">block_is_mapped</span><span class="params">(u_int blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u_int va = diskaddr(blockno);</span><br><span class="line">        <span class="keyword">if</span> (va_is_mapped(va)) &#123;</span><br><span class="line">                <span class="keyword">return</span> va;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*检查该虚拟地址对应的数据是否改变过</span></span><br><span class="line"><span class="comment"> *改变过返回1,否则返回0</span></span><br><span class="line"><span class="comment"> *通过检查对应页表项的dirty位来实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">u_int <span class="title">va_is_dirty</span><span class="params">(u_int va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (* vpt)[VPN(va)] &amp; PTE_D;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*判断当前块是否有效</span></span><br><span class="line"><span class="comment"> *有效则返回1,无效则返回0</span></span><br><span class="line"><span class="comment"> *根据位图结构中对应位的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">block_is_free(u_int blockno)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (super == <span class="number">0</span> || blockno &gt;= super-&gt;s_nblocks) &#123;<span class="comment">//块号超过范围</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bitmap[blockno / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">/*检查该块是否修改过</span></span><br><span class="line"><span class="comment"> *修改过返回1,否则返回0</span></span><br><span class="line"><span class="comment"> *通过检查块映射虚拟地址的dirty位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">u_int <span class="title">block_is_dirty</span><span class="params">(u_int blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u_int va = diskaddr(blockno);</span><br><span class="line">        <span class="keyword">return</span> va_is_mapped(va) &amp;&amp; va_is_dirty(va);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从磁盘中读取blockno代表的数据块到其规定的虚拟地址缓存中,并将blk的值设置为该虚拟地址的值,若是第一次加载则设置isnew为1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_block</span><span class="params">(u_int blockno, <span class="keyword">void</span> **blk, u_int *isnew)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u_int va;</span><br><span class="line">        <span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks) &#123;</span><br><span class="line">                user_panic(<span class="string">"reading non-existent block %08x\n"</span>, blockno);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//检查该块是否在位图结构中对应的位有效</span></span><br><span class="line">        <span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno)) &#123;</span><br><span class="line">                user_panic(<span class="string">"reading free block %08x\n"</span>, blockno);</span><br><span class="line">        &#125;</span><br><span class="line">        va = diskaddr(blockno);</span><br><span class="line">		<span class="comment">/*检查该块是否在虚拟内存中有有效的映射缓冲块</span></span><br><span class="line"><span class="comment">		 *如果已有映射说明磁盘中的数据已经读到了缓冲块中,只需设置isnew标记位为0即可</span></span><br><span class="line"><span class="comment">		 *如果没有映射则新分配一个物理页用来作为该块在虚拟内存中的缓冲块,并从磁盘中读取数据填入,并且设置isnew标记位1</span></span><br><span class="line"><span class="comment">		 *设置blk为作为缓存块的虚拟地址</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="keyword">if</span> (block_is_mapped(blockno)) &#123; <span class="comment">//the block is in memory</span></span><br><span class="line">                <span class="keyword">if</span> (isnew) &#123;</span><br><span class="line">                        *isnew = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                        <span class="comment">//the block is not in memory</span></span><br><span class="line">                <span class="keyword">if</span> (isnew) &#123;</span><br><span class="line">                        *isnew = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                syscall_mem_alloc(<span class="number">0</span>, va, PTE_V | PTE_R);</span><br><span class="line">                ide_read(<span class="number">0</span>, blockno * SECT2BLK, (<span class="keyword">void</span> *)va, SECT2BLK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (blk) &#123;</span><br><span class="line">                *blk = (<span class="keyword">void</span> *)va;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将第blockno块在内存中的虚拟缓存中的数据写回磁盘中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_block</span><span class="params">(u_int blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u_int va;</span><br><span class="line">        <span class="comment">//检测当前块是否存储有效的虚拟内存缓存块</span></span><br><span class="line">        <span class="keyword">if</span> (!block_is_mapped(blockno)) &#123;</span><br><span class="line">                user_panic(<span class="string">"write unmapped block %08x"</span>, blockno);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//向磁盘中写入内存中缓存区的信息</span></span><br><span class="line">        va = diskaddr(blockno);</span><br><span class="line">        ide_write(<span class="number">0</span>, blockno * SECT2BLK, (<span class="keyword">void</span> *)va, SECT2BLK);</span><br><span class="line">    	<span class="comment">//为缓存区的映射增加标记位表示修改过</span></span><br><span class="line">        syscall_mem_map(<span class="number">0</span>, va, <span class="number">0</span>, va, (PTE_V | PTE_R | PTE_LIBRARY));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*对第blockno索引的数据块在虚拟内存中建立缓存页</span></span><br><span class="line"><span class="comment"> *如果本来就存在缓存,则返回0,否则新建一页缓存,返回映射的虚拟地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">map_block</span><span class="params">(u_int blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u_int va;</span><br><span class="line">        <span class="keyword">if</span> (va = block_is_mapped(blockno)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	va = disdiskaddr(blockno);</span><br><span class="line">        <span class="keyword">return</span> syscall_mem_alloc(<span class="number">0</span>,va,PTE_V|PTE_R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*解除第blockno索引的数据块与内存中缓存块的映射(起始就是将对应虚拟内存解除与物理页的映射)</span></span><br><span class="line"><span class="comment"> *如果该虚拟内存缓存块是dirty(即被修改过的),则要先写回磁盘中去再解除映射</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unmap_block</span><span class="params">(u_int blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        u_int va;</span><br><span class="line">        <span class="keyword">if</span> (va=block_is_mapped(blockno)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!block_is_free(blockno) &amp;&amp; block_is_dirty(blockno)) &#123;</span><br><span class="line">                        write_block(blockno);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (syscall_mem_unmap(<span class="number">0</span>,va))</span><br><span class="line">                        writef(<span class="string">"unmap_block failed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        user_assert(!block_is_mapped(blockno));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放blockno索引代表的块(实际上只做了将其在位图中对应位置的位置为1表示可用)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_block</span><span class="params">(u_int blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      	<span class="comment">//第一个是boot块不允许释放</span></span><br><span class="line">        <span class="keyword">if</span> (blockno==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将对应标记位置为1</span></span><br><span class="line">        bitmap[blockno/<span class="number">32</span>] |= (<span class="number">1</span>&lt;&lt;(blockno%<span class="number">32</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在位图标记中寻找第一个空闲可用的块返回其索引值(在其使用前要将原数据写回)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_block_num</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> blockno;</span><br><span class="line">        <span class="keyword">for</span> (blockno = <span class="number">3</span>; blockno &lt; super-&gt;s_nblocks; blockno++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bitmap[blockno / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>))) &#123; </span><br><span class="line">                        bitmap[blockno / <span class="number">32</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>));</span><br><span class="line">        <span class="comment">//注意 : 我们在free_block中只是改变了bitmap中的标记位而已,所以真正要使用这个块之前要将其数据写回到磁盘中去(使用write_block来写回)</span></span><br><span class="line">                        write_block(blockno / BIT2BLK);<span class="comment">//我认为这是将要新分配的那一块写回磁盘,即不用除以BIT2BLK但是我不敢改艹</span></span><br><span class="line">                        <span class="keyword">return</span> blockno;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*分配一个可用的数据块返回其索引值,可用的含义如下:</span></span><br><span class="line"><span class="comment"> 1.在位图中标记位为1</span></span><br><span class="line"><span class="comment"> 2.已经将之间的数据写回磁盘中</span></span><br><span class="line"><span class="comment"> 3.在虚拟内存中建立了缓存块映射</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_block</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r, bno;</span><br><span class="line">        <span class="comment">//找到一个空闲的块并将值写回磁盘</span></span><br><span class="line">        <span class="keyword">if</span> ((r = alloc_block_num()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        bno = r;</span><br><span class="line">    	<span class="comment">//建立虚拟内存中的缓存</span></span><br><span class="line">        <span class="keyword">if</span> ((r = map_block(bno)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                free_block(bno);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> :</p>
<ul>
<li><p>有关有效位</p>
<ol>
<li><code>PTE_D</code> : </li>
<li><code>PTE_LIBRARY</code> : </li>
</ol>
</li>
<li><p>有关映射</p>
<ol>
<li><strong>磁盘块的索引与虚拟地址中的缓存块地址</strong>二者的映射关系是<strong>确定</strong>的,即按索引从小到大,地址按页小到大来静态映射的</li>
<li><strong>我们所说的<code>map</code>和<code>unmap</code>实质上是建立索引对应的虚拟页映射到一个有效的物理页</strong>,即保证虚拟缓存块是有效的</li>
</ol>
</li>
<li><p><strong>有关块的释放与获取</strong></p>
<ol>
<li><p>我们在释放块时只是<strong>做了将其在<code>bitmap</code>结构中的对应标记位设置为1</strong>的简单操作</p>
</li>
<li><p>当要获取一块时,我们要:</p>
<ol>
<li>在<code>bitmap</code>中找到一个标记为1(可用)的块</li>
<li><strong>将其对应的缓存内容写回磁盘中</strong></li>
<li>在虚拟内存中建立缓存块</li>
</ol>
<p><strong>至此该数据块才真正可以被分配使用</strong></p>
</li>
</ol>
<p><strong>即我们采用的是写回机制而不是写直达,也就是说当释放的块再次被使用时才将其写会磁盘中保存改动</strong></p>
</li>
</ul>
</li>
</ol>
<h3 id="对文件系统的操作"><a href="#对文件系统的操作" class="headerlink" title="对文件系统的操作"></a>对文件系统的操作</h3><p>注意区分对<strong>一般文件和对目录文件</strong>二者操作的不同</p>
<p>二者的数据结构组织相同,但是<strong>数据的含义</strong>不同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fs.c</span></span><br><span class="line"><span class="comment">//读取超级块内容到缓存区中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_super</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="keyword">void</span> *blk;</span><br><span class="line">        <span class="keyword">if</span> ((r = read_block(<span class="number">1</span>, &amp;blk, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                user_panic(<span class="string">"cannot read superblock: %e"</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        super = blk;</span><br><span class="line">        <span class="keyword">if</span> (super-&gt;s_magic != FS_MAGIC) &#123;</span><br><span class="line">                user_panic(<span class="string">"bad file system magic number %x %x"</span>, super-&gt;s_magic, FS_MAGIC);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (super-&gt;s_nblocks &gt; DISKMAX / BY2BLK) &#123;</span><br><span class="line">                user_panic(<span class="string">"file system is too large"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        writef(<span class="string">"superblock is good\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取位图结构bitmap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_bitmap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u_int i;</span><br><span class="line">        <span class="keyword">void</span> *blk = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//nbitmap代表的是位图结构bitmap占用的数据块的个数(至少为1个)</span></span><br><span class="line">        nbitmap = super-&gt;s_nblocks / BIT2BLK + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//将bitmap读入到虚拟内存缓存中</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitmap; i++) &#123;</span><br><span class="line">                read_block(i + <span class="number">2</span>, blk, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bitmap = (u_int *)diskaddr(<span class="number">2</span>);</span><br><span class="line"> <span class="comment">//检查bitmap中前两个块(boot和super)和bitmap占用的块必定是已被使用的   	</span></span><br><span class="line">        user_assert(!block_is_free(<span class="number">0</span>));</span><br><span class="line">        user_assert(!block_is_free(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitmap; i++) &#123;</span><br><span class="line">                user_assert(!block_is_free(i + <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        writef(<span class="string">"read_bitmap is good\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fs_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        read_super();</span><br><span class="line">        check_write_block();</span><br><span class="line">        read_bitmap();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在文件控制块f中查询第fileno个指针指向的数据块的索引值,ppdiskbno指向保存该索引值的地址</span></span><br><span class="line"><span class="comment">//alloc为1代表在间接指针无效时允许新分配一页</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_block_walk</span><span class="params">(struct File *f, u_int filebno, u_int **ppdiskbno, u_int alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        u_int *ptr;</span><br><span class="line">        <span class="keyword">void</span> *blk;</span><br><span class="line"><span class="comment">//指针值在直接指针范围内直接通过直接指针获得</span></span><br><span class="line">        <span class="keyword">if</span> (filebno &lt; NDIRECT) &#123;</span><br><span class="line">                ptr = &amp;f-&gt;f_direct[filebno];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (filebno &lt; NINDIRECT) &#123;</span><br><span class="line">        <span class="comment">//当指针值需要使用间接指针时</span></span><br><span class="line">                <span class="keyword">if</span> (f-&gt;f_indirect == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;<span class="comment">//不允许alloc</span></span><br><span class="line">                                <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>) &#123;<span class="comment">//允许alloc则分配一块存储间接指针</span></span><br><span class="line">                                <span class="keyword">return</span> r;</span><br><span class="line">                        &#125;</span><br><span class="line">                        f-&gt;f_indirect = r;</span><br><span class="line">                &#125;</span><br><span class="line">			<span class="comment">//blk保存(保存间接指针的虚拟页)的起始地址</span></span><br><span class="line">                <span class="keyword">if</span> ((r = read_block(f-&gt;f_indirect, &amp;blk, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//则ptr指向(保存fileno指针指向的数据块索引)的地址</span></span><br><span class="line">            <span class="comment">//即*ptr即为fileno指向的数据块的索引值</span></span><br><span class="line">                ptr = (u_int *)blk + filebno;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        *ppdiskbno = ptr;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在f文件控制块中查找第fileno个指针指向的数据块对应的索引值赋值给diskbno(即建立文件控制块域与数据块关系)</span></span><br><span class="line"><span class="comment">//当alloc为1时若查找出来的索引无效,允许新分配一块</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_map_block</span><span class="params">(struct File *f, u_int filebno, u_int *diskbno, u_int alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        u_int *ptr;</span><br><span class="line"><span class="comment">//在f文件控制块中找对应的数据索引</span></span><br><span class="line">        <span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ptr, alloc)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//*ptr保存索引值</span></span><br><span class="line"><span class="comment">//如果索引无效</span></span><br><span class="line">        <span class="keyword">if</span> (*ptr == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">                &#125;</span><br><span class="line">			<span class="comment">//如果允许分配则新分配一页,并写入控制块结构对应位置</span></span><br><span class="line">                <span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//填入新分配的块的索引</span></span><br><span class="line">                *ptr = r;</span><br><span class="line">        &#125;</span><br><span class="line">        *diskbno = *ptr;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放文件控制块f的第filebno个指针指向的数据块</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_clear_block</span><span class="params">(struct File *f, u_int filebno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        u_int *ptr;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ptr, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*ptr) &#123;</span><br><span class="line">                free_block(*ptr);</span><br><span class="line">                *ptr = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得文件控制块f中第filebno个指针指向的数据块中的数据加载到虚拟内存中,并令blk指向该虚拟地址</span></span><br><span class="line"><span class="comment">//当filebno超过索引范围之后,则新分配一个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_get_block</span><span class="params">(struct File *f, u_int filebno, <span class="keyword">void</span> **blk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        u_int diskbno;</span><br><span class="line">        u_int isnew;</span><br><span class="line">    <span class="comment">//找到数据块的索引</span></span><br><span class="line">        <span class="keyword">if</span> ((r = file_map_block(f, filebno, &amp;diskbno, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//加载该数据块到虚拟内存blk中</span></span><br><span class="line">        <span class="keyword">if</span> ((r = read_block(diskbno, blk, &amp;isnew)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//???</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_dirty</span><span class="params">(struct File *f, u_int offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="keyword">void</span> *blk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((r = file_get_block(f, offset / BY2BLK, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">volatile</span> <span class="keyword">char</span> *)blk = *(<span class="keyword">volatile</span> <span class="keyword">char</span> *)blk;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得目录文件dir之下名为name的文件,如果有则将该文件的文件控制块赋值给file(注意此时dir问name文件的直接父目录)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir_lookup</span><span class="params">(struct File *dir, <span class="keyword">char</span> *name, struct File **file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        u_int i, j, nblock;</span><br><span class="line">        <span class="keyword">void</span> *blk;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="comment">//nblock为该目录文件之下的数据块个数</span></span><br><span class="line">        nblock = ROUND(dir-&gt;f_size,BY2BLK)/BY2BLK;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line">                <span class="comment">//获得一个保存文件控制块的数据块</span></span><br><span class="line">                <span class="keyword">if</span> (r=file_get_block(dir,i,&amp;blk))</span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                f = (struct File*)blk;</span><br><span class="line">                <span class="comment">//遍历该块中的每一个文件控制块,比较文件名</span></span><br><span class="line">                <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;FILE2BLK;j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(f[j].f_name,name)==<span class="number">0</span>) &#123;</span><br><span class="line">                                f[j].f_dir = dir;</span><br><span class="line">                                *file = &amp;f[j];</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在目录文件dir之下寻找一个空闲的文件控制块,并将其赋值给file</span></span><br><span class="line"><span class="comment">//如果没有空闲的控制块,则新分配一个数据块用来存储文件控制块</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir_alloc_file</span><span class="params">(struct File *dir, struct File **file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        u_int nblock, i , j;</span><br><span class="line">        <span class="keyword">void</span> *blk;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">        nblock = dir-&gt;f_size / BY2BLK;</span><br><span class="line">    <span class="comment">//遍历每一个块</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((r = file_get_block(dir, i, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                &#125;</span><br><span class="line">                f = blk;</span><br><span class="line">            <span class="comment">//遍历块中的每一个文件控制块</span></span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; FILE2BLK; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (f[j].f_name[<span class="number">0</span>] == <span class="string">'\0'</span>) &#123; </span><br><span class="line">                                *file = &amp;f[j];</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//当没找到之后新分配一个数据块</span></span><br><span class="line">        dir-&gt;f_size += BY2BLK;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_get_block(dir, i, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        f = blk;</span><br><span class="line">        *file = &amp;f[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//去除路径中的空格</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">skip_slash</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (*p == <span class="string">'/'</span>) &#123;</span><br><span class="line">                p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//难道我们不支持文件目录的嵌套吗???</span></span><br><span class="line"><span class="comment">//返回0代表找到了给文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">walk_path</span><span class="params">(<span class="keyword">char</span> *path, struct File **pdir, struct File **pfile, <span class="keyword">char</span> *lastelem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> *p;</span><br><span class="line">        <span class="keyword">char</span> name[MAXNAMELEN];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span>, *<span class="title">file</span>;</span></span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// start at the root.</span></span><br><span class="line">        path = skip_slash(path);</span><br><span class="line">        file = &amp;super-&gt;s_root;</span><br><span class="line">        dir = <span class="number">0</span>;</span><br><span class="line">        name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pdir) &#123;</span><br><span class="line">                *pdir = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *pfile = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find the target file by name recursively.</span></span><br><span class="line">        <span class="keyword">while</span> (*path != <span class="string">'\0'</span>) &#123;</span><br><span class="line">                dir = file;</span><br><span class="line">                p = path;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (*path != <span class="string">'/'</span> &amp;&amp; *path != <span class="string">'\0'</span>) &#123;</span><br><span class="line">                        path++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (path - p &gt;= MAXNAMELEN) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                user_bcopy(p, name, path - p);</span><br><span class="line">                name[path - p] = <span class="string">'\0'</span>;</span><br><span class="line">                path = skip_slash(path);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dir-&gt;f_type != FTYPE_DIR) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((r = dir_lookup(dir, name, &amp;file)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (r == -E_NOT_FOUND &amp;&amp; *path == <span class="string">'\0'</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (pdir) &#123;</span><br><span class="line">                                        *pdir = dir;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (lastelem) &#123;</span><br><span class="line">                                        <span class="built_in">strcpy</span>(lastelem, name);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                *pfile = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pdir) &#123;</span><br><span class="line">                *pdir = dir;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *pfile = file;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据path找到其代表的文件控制块并赋值给file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_open</span><span class="params">(<span class="keyword">char</span> *path, struct File **file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> walk_path(path, <span class="number">0</span>, file, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据path在目录下创建文件,并将新建的文件控制块赋值给file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_create</span><span class="params">(<span class="keyword">char</span> *path, struct File **file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> name[MAXNAMELEN];</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span>, *<span class="title">f</span>;</span></span><br><span class="line">        <span class="keyword">if</span> ((r = walk_path(path, &amp;dir, &amp;f, name)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -E_FILE_EXISTS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r != -E_NOT_FOUND || dir == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dir_alloc_file(dir, &amp;f) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)f-&gt;f_name, name);</span><br><span class="line">        *file = f;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将文件控制块f代表的文件的大小截取为newsize(要求newsize &lt; oldsize)(不安全的方法,只能被file_set_size使用)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">file_truncate</span><span class="params">(struct File *f, u_int newsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u_int bno, old_nblocks, new_nblocks;</span><br><span class="line">        old_nblocks = f-&gt;f_size / BY2BLK + <span class="number">1</span>;</span><br><span class="line">        new_nblocks = newsize / BY2BLK + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newsize == <span class="number">0</span>) &#123;</span><br><span class="line">                new_nblocks = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (new_nblocks &lt;= NDIRECT) &#123;<span class="comment">//当只需要直接指针时</span></span><br><span class="line">                f-&gt;f_indirect = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//当新的大小比原大小大时,将多余的块释放</span></span><br><span class="line">                <span class="keyword">for</span> (bno = new_nblocks; bno &lt; old_nblocks; bno++) &#123;</span><br><span class="line">                        file_clear_block(f, bno);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (bno = new_nblocks; bno &lt; old_nblocks; bno++) &#123;</span><br><span class="line">                        file_clear_block(f, bno);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f-&gt;f_size = newsize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将文件的大小改变为newsize</span></span><br><span class="line"><span class="comment"> *如果newsize &lt; oldsize则截断(使用file_truncate),设置f_size为new_size</span></span><br><span class="line"><span class="comment"> *如果newsize &gt; oldsize则直接设置f_size为new_size即可</span></span><br><span class="line"><span class="comment"> *将???</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_set_size</span><span class="params">(struct File *f, u_int newsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f-&gt;f_size &gt; newsize) &#123;</span><br><span class="line">                file_truncate(f, newsize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f-&gt;f_size = newsize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f-&gt;f_dir) &#123;</span><br><span class="line">                file_flush(f-&gt;f_dir);<span class="comment">//??????</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将文件控制块f中所有指针指向的数据块中的dirty的写回磁盘中(即同步磁盘与内存缓存中的数据)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">file_flush</span><span class="params">(struct File *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u_int nblocks;</span><br><span class="line">        u_int bno;</span><br><span class="line">        u_int diskno;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">        nblocks = f-&gt;f_size / BY2BLK + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (bno = <span class="number">0</span>; bno &lt; nblocks; bno++) &#123;</span><br><span class="line">            <span class="comment">//获得当前文件第bno个指针对应的索引,当不存在时不新建映射</span></span><br><span class="line">                <span class="keyword">if</span> ((r = file_map_block(f, bno, &amp;diskno, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//如果由索引获得的数据块是dirty的,则将其刷新回磁盘上</span></span><br><span class="line">                <span class="keyword">if</span> (block_is_dirty(diskno)) &#123;</span><br><span class="line">                        write_block(diskno);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该操作是保证数据同步性,即将内存中dirty的快缓存写回到磁盘中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fs_sync</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; super-&gt;s_nblocks; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (block_is_dirty(i)) &#123;</span><br><span class="line">                        write_block(i);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件的操作其实就是把文件内容从内存缓存写回磁盘中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">file_close</span><span class="params">(struct File *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        file_flush(f);</span><br><span class="line">        <span class="keyword">if</span> (f-&gt;f_dir) &#123;</span><br><span class="line">                file_flush(f-&gt;f_dir);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_remove</span><span class="params">(<span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">        <span class="keyword">if</span> ((r = walk_path(path, <span class="number">0</span>, &amp;f, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        file_truncate(f, <span class="number">0</span>);</span><br><span class="line">        f-&gt;f_name[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        file_flush(f);</span><br><span class="line">        <span class="keyword">if</span> (f-&gt;f_dir) &#123;</span><br><span class="line">                file_flush(f-&gt;f_dir);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>好像 :</p>
<p>我们所谓的对文件或者目录文件的操作都是针对于在内存缓存区的,而磁盘上的文件结构或者内容不会发生改变,所以我们在每一次对映射关系的修改之前都会有个写回磁盘的操作???</p>
<h2 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h2><p>在我们实现文件系统之后,我们需要给用户提供<strong>使用的接口(就是一些标准化的操文件系统的函数)</strong></p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>我们引入一个新的数据结构,即<strong>文件描述符</strong>,该描述符描述<strong>一个打开的文件在操作过程中状态</strong></p>
<ol>
<li><p>定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/fd.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	u_int fd_dev_id;</span><br><span class="line">	u_int fd_offset;</span><br><span class="line">	u_int fd_omode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其在内存中的构成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/fd.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXFD 32 <span class="comment">//最多同时存在32个文件描述符结构</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEBASE 0x60000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FDTABLE (FILEBASE-PDMAP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INDEX2FD(i)	(FDTABLE+(i)*BY2PG)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INDEX2DATA(i)	(FILEBASE+(i)*PDMAP)</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/21/OS-lab5/fd_struct.png" alt></p>
<p><strong>注意 : 我们一个<code>Fd</code>结构体占据一页的大小</strong></p>
</li>
<li><p>操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/fd.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">devtab</span>[] =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	&amp;devfile,</span><br><span class="line">	&amp;devcons,</span><br><span class="line">	&amp;devpipe,</span><br><span class="line">	<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> dev_id;</span><br><span class="line">	<span class="keyword">char</span> *dev_name;</span><br><span class="line">	<span class="keyword">int</span> (*dev_read)(struct Fd*, <span class="keyword">void</span>*, u_int, u_int);</span><br><span class="line">	<span class="keyword">int</span> (*dev_write)(struct Fd*, <span class="keyword">const</span> <span class="keyword">void</span>*, u_int, u_int);</span><br><span class="line">	<span class="keyword">int</span> (*dev_close)(struct Fd*);</span><br><span class="line">	<span class="keyword">int</span> (*dev_stat)(struct Fd*, struct Stat*);</span><br><span class="line">	<span class="keyword">int</span> (*dev_seek)(struct Fd*, u_int);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">.dev_id=	<span class="string">'f'</span>,</span><br><span class="line">.dev_name=	<span class="string">"file"</span>,</span><br><span class="line">.dev_read=	file_read,</span><br><span class="line">.dev_write=	file_write,</span><br><span class="line">.dev_close=	file_close,</span><br><span class="line">.dev_stat=	file_stat,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devcons</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">.dev_id=	<span class="string">'c'</span>,</span><br><span class="line">.dev_name=	<span class="string">"cons"</span>,</span><br><span class="line">.dev_read=	cons_read,</span><br><span class="line">.dev_write=	cons_write,</span><br><span class="line">.dev_close=	cons_close,</span><br><span class="line">.dev_stat=	cons_stat,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devpipe</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">.dev_id=	<span class="string">'p'</span>,</span><br><span class="line">.dev_name=	<span class="string">"pipe"</span>,</span><br><span class="line">.dev_read=	piperead,</span><br><span class="line">.dev_write=	pipewrite,</span><br><span class="line">.dev_close=	pipeclose,</span><br><span class="line">.dev_stat=	pipestat,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//上面的层次结构颇有面向对象的风格</span></span><br><span class="line"><span class="comment">//即使用父类Dev.继承众多子类devfile,devcons,devpipe</span></span><br><span class="line"><span class="comment">//使用函数指针的形式来实现子类同样的功能下根据自身进行各自不同的行为</span></span><br><span class="line"><span class="comment">//-------------------------------------------------//</span></span><br><span class="line"><span class="comment">//在devtab[]中寻找id为dev_id的设备,,并使用dev指向他</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dev_lookup</span><span class="params">(<span class="keyword">int</span> dev_id, struct Dev **dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; devtab[i]; i++)</span><br><span class="line">		<span class="keyword">if</span> (devtab[i]-&gt;dev_id == dev_id) &#123;</span><br><span class="line">			*dev = devtab[i];</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	writef(<span class="string">"[%08x] unknown device type %d\n"</span>, env-&gt;env_id, dev_id);</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按顺序寻找第一个还未被使用的储存Fd的页,使fd指向该页首地址</span></span><br><span class="line"><span class="comment">//依据于该地址对应的页目录或者页表项是否有效来判断该地址是够被使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fd_alloc</span><span class="params">(struct Fd **fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(fdno = <span class="number">0</span>;fdno &lt; MAXFD - <span class="number">1</span>;fdno++)</span><br><span class="line">	&#123;</span><br><span class="line">		va = INDEX2FD(fdno);</span><br><span class="line">		<span class="keyword">if</span>(((* vpd)[va/PDMAP] &amp; PTE_V)==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*fd = va;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(((* vpt)[va/BY2PG] &amp; PTE_V)==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*fd = va;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件描述符fd,实际上就是取消其所在页的映射而已</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fd_close</span><span class="params">(struct Fd *fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	syscall_mem_unmap(<span class="number">0</span>, (u_int)fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找第fdnum个文件描述符,使得fd指向该页起始地址</span></span><br><span class="line"><span class="comment">//寻找成功则返回0,不成功返回错误值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fd_lookup</span><span class="params">(<span class="keyword">int</span> fdnum, struct Fd **fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int va;</span><br><span class="line">	<span class="keyword">if</span>(fdnum &gt;=MAXFD)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	va = INDEX2FD(fdnum);</span><br><span class="line">	<span class="keyword">if</span>(((* vpt)[va/BY2PG] &amp; PTE_V)!=<span class="number">0</span>)	</span><br><span class="line">	&#123;</span><br><span class="line">		*fd = va;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据文件描述符指针获得其对应的数据块</span></span><br><span class="line"><span class="function">u_int <span class="title">fd2data</span><span class="params">(struct Fd *fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> INDEX2DATA(fd2num(fd));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过文件描述符fd获得其在描述符数组结构中的index(利用每个描述符占据一页并且连续存储</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fd2num</span><span class="params">(struct Fd *fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((u_int)fd - FDTABLE)/BY2PG;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过文件描述符在数组中的下标fd获得其在数组结构中的页起始地址</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num2fd</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fd*BY2PG+FDTABLE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*关闭第fdnum个文件描述符以及其对应的文件</span></span><br><span class="line"><span class="comment"> 1. 通过fdnum作为描述符数组下标找到描述符所在页并释放它</span></span><br><span class="line"><span class="comment"> 2. 通过描述符中的dev_id来在devtab[]中寻找对于对应的设备对象并关闭它</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fdnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">	||  (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	r = (*dev-&gt;dev_close)(fd);</span><br><span class="line">	fd_close(fd);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭所有文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_all</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;MAXFD; i++)</span><br><span class="line">		close(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将第oldfdum个文件描述符以及其数据域中的数据对应的物理页向第newfdnum个文件描述符建立映射</span></span><br><span class="line"><span class="comment"> *即oldfd与newfd共享oldfdnum中的数据</span></span><br><span class="line"><span class="comment"> 1. 关闭newfd,使其变为一个还未使用的文件描述符块</span></span><br><span class="line"><span class="comment"> 2. 建立newfd的数据域到oldfd的数据域物理页的映射</span></span><br><span class="line"><span class="comment"> 3. 建立newfd文件描述符页到oldfd文件描述符物理页的映射</span></span><br><span class="line"><span class="comment"> *注意映射要么全部建立成功,要么一个都不建立</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfdnum, <span class="keyword">int</span> newfdnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, r;</span><br><span class="line">	u_int ova, nva, pte;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">oldfd</span>, *<span class="title">newfd</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(oldfdnum, &amp;oldfd)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	close(newfdnum);</span><br><span class="line"></span><br><span class="line">	newfd = (struct Fd*)INDEX2FD(newfdnum);</span><br><span class="line">	ova = fd2data(oldfd);</span><br><span class="line">	nva = fd2data(newfd);</span><br><span class="line">	<span class="comment">//建立数据域的共享</span></span><br><span class="line">	<span class="keyword">if</span> ((* vpd)[PDX(ova)]) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;PDMAP; i+=BY2PG) &#123;</span><br><span class="line">			pte = (* vpt)[VPN(ova+i)];</span><br><span class="line">			<span class="keyword">if</span>(pte&amp;PTE_V) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, ova+i, <span class="number">0</span>, nva+i, pte&amp;(PTE_V|PTE_R|PTE_LIBRARY))) &lt; <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">goto</span> err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//建立文件描述符页的共享</span></span><br><span class="line">	<span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, (u_int)oldfd, <span class="number">0</span>, (u_int)newfd, ((*vpt)[VPN(oldfd)])&amp;(PTE_V|PTE_R|PTE_LIBRARY))) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newfdnum;</span><br><span class="line"><span class="comment">//当在建立映射的任何时候出错时均跳转到err代码处 : 取消之间所有建立的映射</span></span><br><span class="line">err:</span><br><span class="line">	syscall_mem_unmap(<span class="number">0</span>, (u_int)newfd);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;PDMAP; i+=BY2PG)</span><br><span class="line">		syscall_mem_unmap(<span class="number">0</span>, nva+i);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处n的含义好像不是读取的字节数???excuse me &gt;&gt; fuck</span></span><br><span class="line"><span class="comment">/*从第fdnum个文件描述符对应的文件中读出n个字节数据写入buf中,流程如下 :</span></span><br><span class="line"><span class="comment"> 1. 根据fdnum获得文件描述符指针fd</span></span><br><span class="line"><span class="comment"> 2. 根据文件描述符域中的dev_id在devtab[]中获得设备指针dev</span></span><br><span class="line"><span class="comment"> 3. 根据设备指针域中的读函数指针dev_read进行读取</span></span><br><span class="line"><span class="comment"> 4. 在读取完成后设置文件偏移量</span></span><br><span class="line"><span class="comment"> *当返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fdnum, <span class="keyword">void</span> *buf, u_int n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">	||  (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_WRONLY) &#123;</span><br><span class="line">		writef(<span class="string">"[%08x] read %d -- bad mode\n"</span>, env-&gt;env_id, fdnum); </span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	r = (*dev-&gt;dev_read)(fd, buf, n, fd-&gt;fd_offset);</span><br><span class="line">	<span class="keyword">if</span> (r &gt;= <span class="number">0</span>)</span><br><span class="line">		fd-&gt;fd_offset += r;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分多次读入,整体效果与read函数一致</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> fdnum, <span class="keyword">void</span> *buf, u_int n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m, tot;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (tot=<span class="number">0</span>; tot&lt;n; tot+=m) &#123;</span><br><span class="line">		m = read(fdnum, (<span class="keyword">char</span>*)buf+tot, n-tot);</span><br><span class="line">		<span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> m;</span><br><span class="line">		<span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//与read函数基本一致</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fdnum, <span class="keyword">const</span> <span class="keyword">void</span> *buf, u_int n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">	||  (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_RDONLY) &#123;</span><br><span class="line">		writef(<span class="string">"[%08x] write %d -- bad mode\n"</span>, env-&gt;env_id, fdnum);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"write %d %p %d via dev %s\n"</span>,</span><br><span class="line">		fdnum, buf, n, dev-&gt;dev_name);</span><br><span class="line">	r = (*dev-&gt;dev_write)(fd, buf, n, fd-&gt;fd_offset);</span><br><span class="line">	<span class="keyword">if</span> (r &gt; <span class="number">0</span>)</span><br><span class="line">		fd-&gt;fd_offset += r;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置第fdnum个文件描述符中的文件偏移为offset</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> fdnum, u_int offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	fd-&gt;fd_offset = offset;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> st_name[MAXNAMELEN];</span><br><span class="line">	u_int st_size;</span><br><span class="line">	u_int st_isdir;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">st_dev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//初始化第fdnum个文件描述符对应的dev中的dev_stat</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fdnum, struct Stat *stat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">	||  (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	stat-&gt;st_name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	stat-&gt;st_size = <span class="number">0</span>;</span><br><span class="line">	stat-&gt;st_isdir = <span class="number">0</span>;</span><br><span class="line">	stat-&gt;st_dev = dev;</span><br><span class="line">	<span class="keyword">return</span> (*dev-&gt;dev_stat)(fd, stat);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct Stat *stat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd, r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">	r = fstat(fd, stat);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="IPC机制的使用"><a href="#IPC机制的使用" class="headerlink" title="IPC机制的使用"></a>IPC机制的使用</h3><p><strong>我们的操作系统中的文件系统服务通过 <code>IPC</code>的形式供其他进程调用,进行文件读写操作.具体来说,在内核开始运行时,就启动了文件系统服务进程 <code>ENV_CREATE(fs_serv)</code>,用户进程需要进行文件操作时,使用<code>ipc_send/ipc_recv</code> 与 <code>fs_serv</code> 进行互,完成操作</strong></p>
<p>所以基本流程为<code>file.c</code>中的函数准备好<strong>实现功能的数据</strong>,调用<code>fsipc.c</code>中的<strong>通讯函数</strong>传递<strong>包装后的数据</strong>给<code>fs_serv</code>进程,该进程根据<strong>标准形式数据</strong>进行操作,操作完成之后又通过<code>ipc</code>机制通知操作成功或者失败</p>
<p><strong>在文件操作中通信主要靠的是映射到同一地址,即用户进程告诉文件服务进程我的文件描述符等数据结构都应该要在虚拟地址<code>dstva</code>指向的页,然后文件服务进程找到一个物理页把这些都填好,然后在二者之间建立映射关系</strong></p>
<h4 id="传递的指令形式"><a href="#传递的指令形式" class="headerlink" title="传递的指令形式"></a>传递的指令形式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fs.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSREQ_OPEN	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSREQ_MAP	2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSREQ_SET_SIZE	3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSREQ_CLOSE	4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSREQ_DIRTY	5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSREQ_REMOVE	6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSREQ_SYNC	7</span></span><br><span class="line"><span class="comment">//各种文件操作通信的标准请求结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> req_path[MAXPATHLEN];</span><br><span class="line">	u_int req_omode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_map</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> req_fileid;</span><br><span class="line">	u_int req_offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_set_size</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> req_fileid;</span><br><span class="line">	u_int req_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_close</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> req_fileid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_dirty</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> req_fileid;</span><br><span class="line">	u_int req_offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_remove</span> &#123;</span></span><br><span class="line">	u_char req_path[MAXPATHLEN];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h4><p><strong>之后对用户进程的请求只需要包装(根据数据填写对应的域即可)成标准的请求结构然后发送给文件服务进程即可</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/fsipc.c</span></span><br><span class="line"><span class="keyword">extern</span> u_char fsipcbuf[BY2PG];		<span class="comment">//在entry中定义为一页大小</span></span><br><span class="line"><span class="comment">/*最基本的通信函数</span></span><br><span class="line"><span class="comment"> *type为操作的类型</span></span><br><span class="line"><span class="comment"> *fsreq为实现操作需要的相关数据保存的地址位置</span></span><br><span class="line"><span class="comment"> *dstva为该进程接受文件服务进程返回信息的保存位置</span></span><br><span class="line"><span class="comment"> 文件服务进程控制块在第2个</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fsipc</span><span class="params">(u_int type, <span class="keyword">void</span> *fsreq, u_int dstva, u_int *perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int whom;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	ipc_send(envs[<span class="number">1</span>].env_id, type, (u_int)fsreq, PTE_V|PTE_R);</span><br><span class="line">	r =  ipc_recv(&amp;whom, dstva, perm);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将打开文件请求包转成标准请求Fsreq_open发送给文件服务系统</span></span><br><span class="line"><span class="comment">//以omode的权限打开path下的文件并使fd指向打开文件的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsipc_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, u_int omode, struct Fd *fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int perm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> *<span class="title">req</span>;</span></span><br><span class="line">	req = (struct Fsreq_open*)fsipcbuf;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN)</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">	<span class="built_in">strcpy</span>(req-&gt;req_path, path);</span><br><span class="line">	req-&gt;req_omode = omode;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_OPEN, req, (u_int)fd, &amp;perm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将映射地址请求包转成标准请求Fsreq_map发送给文件服务系统</span></span><br><span class="line"><span class="comment">//将fileid代表的文件的offset字节所在的数据块(一页大小)映射到dstva的虚拟地址</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsipc_map</span><span class="params">(u_int fileid, u_int offset, u_int dstva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	u_int perm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_map</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">	req = (struct Fsreq_map*)fsipcbuf;</span><br><span class="line">	req-&gt;req_fileid = fileid;</span><br><span class="line">	req-&gt;req_offset = offset;</span><br><span class="line">	<span class="keyword">if</span> ((r=fsipc(FSREQ_MAP, req, dstva, &amp;perm)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((perm&amp;~(PTE_R|PTE_LIBRARY)) != (PTE_V))</span><br><span class="line">		user_panic(<span class="string">"fsipc_map: unexpected permissions %08x for dstva %08x"</span>, perm, dstva);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将改变文件大小请求包转成标准请求Fsreq_set_size发送给文件服务系统</span></span><br><span class="line"><span class="comment">//将fileid代表的文件的大小设置为size</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsipc_set_size</span><span class="params">(u_int fileid, u_int size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_set_size</span> *<span class="title">req</span>;</span></span><br><span class="line">	req = (struct Fsreq_set_size*)fsipcbuf;</span><br><span class="line">	req-&gt;req_fileid = fileid;</span><br><span class="line">	req-&gt;req_size = size;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_SET_SIZE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将关闭文件请求包转成标准请求Fsreq_close发送给文件服务系统</span></span><br><span class="line"><span class="comment">//将fileid代表的文件关闭</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsipc_close</span><span class="params">(u_int fileid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_close</span> *<span class="title">req</span>;</span></span><br><span class="line">	req = (struct Fsreq_close*)fsipcbuf;</span><br><span class="line">	req-&gt;req_fileid = fileid;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_CLOSE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将设置dirty请求包转成标准请求Fsreq_dirty发送给文件服务系统</span></span><br><span class="line"><span class="comment">//将fileid代表的文件数据offset字节偏移所在的数据块标记为dirty的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsipc_dirty</span><span class="params">(u_int fileid, u_int offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_dirty</span> *<span class="title">req</span>;</span></span><br><span class="line">	req = (struct Fsreq_dirty*)fsipcbuf;</span><br><span class="line">	req-&gt;req_fileid = fileid;</span><br><span class="line">	req-&gt;req_offset = offset;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_DIRTY, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将删除文件请求包转成标准请求Fsreq_remove发送给文件服务系统</span></span><br><span class="line"><span class="comment">//将path找到的文件从其目录中删除掉</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsipc_remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_remove</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">	req = (struct Fsreq_remove*)fsipcbuf;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN)</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">	<span class="built_in">strcpy</span>(req-&gt;req_path, path);</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_REMOVE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将同步文件请求发送给文件服务系统</span></span><br><span class="line"><span class="comment">//将fsipcbuf中代表的文件从内存中的缓存区写会磁盘中(即同步数据)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsipc_sync</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_SYNC, fsipcbuf, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意 : 在上述操作中使用了众多的指针类型的强制转换,我对此的理解是</strong> :</p>
<ol>
<li>任何一个结构体指针都只是指向一片<strong>连续的内存区域</strong>而已</li>
<li><strong>结构体的定义形式决定了使用该指针时会如何划分这一块连续的内存区域,以及划分之后的每一块区域代表的含义</strong></li>
<li>所以我们<strong>可以向一片连续的内存区域按顺序填入我们结构体的数据,就可以使用该类型指针来解读它</strong></li>
</ol>
<h4 id="文件服务进程"><a href="#文件服务进程" class="headerlink" title="文件服务进程"></a>文件服务进程</h4><p>文件服务进程等待其他进程<strong>通过<code>IPC</code>机制发送文件操作请求</strong>然后响应,在文件服务进程中可以<strong>使用<code>fs.c</code>中对文件的各种操作函数</strong>(<del>既然是个假的操作系统,我们为什么不让用户进程直接使用<code>fs.c</code>中函数呢</del>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/serv.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span>	</span><br><span class="line">	u_int o_fileid;		</span><br><span class="line">	<span class="keyword">int</span> o_mode;		</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">o_ff</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时打开的最多文件个数,注意是同时打开,不代表fileid的范围就在这中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXOPEN	1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEVA 0x60000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize to force into data section</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> <span class="title">opentab</span>[<span class="title">MAXOPEN</span>] = &#123;</span> &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Virtual address at which to receive page mappings containing client requests.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REQVA	0x0ffff000</span></span><br><span class="line"><span class="comment">//初始化数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	u_int va;</span><br><span class="line">	va = FILEVA;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;MAXOPEN; i++) &#123;</span><br><span class="line">		opentab[i].o_fileid = i;</span><br><span class="line">		opentab[i].o_ff = (struct Filefd*)va;</span><br><span class="line">		va += BY2PG;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//user/pageref.c</span></span><br><span class="line"><span class="comment">//返回虚拟地址映射到的物理地址的历史上被引用次数</span></span><br><span class="line"><span class="comment">//当没有有效映射时返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pageref</span><span class="params">(<span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int pte;</span><br><span class="line">	<span class="keyword">if</span> (!((* vpd)[PDX(v)]&amp;PTE_V))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	pte = (* vpt)[VPN(v)];</span><br><span class="line">	<span class="keyword">if</span> (!(pte&amp;PTE_V))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> pages[PPN(pte)].pp_ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_alloc</span><span class="params">(struct Open **o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, r;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXOPEN; i++) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (pageref(opentab[i].o_ff)) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">if</span> ((r = syscall_mem_alloc(<span class="number">0</span>, (u_int)opentab[i].o_ff, PTE_V|PTE_R|PTE_LIBRARY)) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> r;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">             <span class="comment">/*这个case1非常骚</span></span><br><span class="line"><span class="comment">              *当ref = 1时说明该文件之前被打开过一次,所以此时是第二次打开</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">			opentab[i].o_fileid += MAXOPEN;<span class="comment">//第二次打开fileid + MAXOPEN,这样既可以保证fileid在每次打开文件的唯一性,又可以通过取模方便的由fileid获得index = fileid % MAXOPEN</span></span><br><span class="line">			*o = &amp;opentab[i];</span><br><span class="line">			user_bzero((<span class="keyword">void</span>*)opentab[i].o_ff, BY2PG);</span><br><span class="line">			<span class="keyword">return</span> (*o)-&gt;o_fileid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据fileid这一唯一标识获得open结构体赋值给po</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_lookup</span><span class="params">(u_int envid, u_int fileid, struct Open **po)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">o</span>;</span></span><br><span class="line">	o = &amp;opentab[fileid%MAXOPEN];</span><br><span class="line">	<span class="keyword">if</span> (pageref(o-&gt;o_ff) == <span class="number">1</span> || o-&gt;o_fileid != fileid)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	*po = o;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">//接下来便是各种文件服务进程的服务函数</span></span><br><span class="line"><span class="comment">//打开文件服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_open</span><span class="params">(u_int envid, struct Fsreq_open *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	writef(<span class="string">"serve_open %08x %x 0x%x\n"</span>, envid, (<span class="keyword">int</span>)rq-&gt;req_path, rq-&gt;req_omode);</span><br><span class="line">	u_char path[MAXPATHLEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ff</span>;</span></span><br><span class="line">	<span class="keyword">int</span> fileid;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">o</span>;</span></span><br><span class="line">	user_bcopy(rq-&gt;req_path, path, MAXPATHLEN);</span><br><span class="line">	path[MAXPATHLEN<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> ((r = open_alloc(&amp;o)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		writef(<span class="string">"open_alloc failed: %d"</span>, r);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	fileid = r;</span><br><span class="line">	<span class="keyword">if</span> ((r = file_open(path, &amp;f)) &lt; <span class="number">0</span>) &#123;<span class="comment">//使用fs.c中的file_open打开path文件并使f指向其文件控制块</span></span><br><span class="line">		writef(<span class="string">"file_open failed: %e"</span>, r);</span><br><span class="line">		<span class="keyword">if</span> (r==-E_NOT_FOUND) writef(<span class="string">"E_NOT_FOUND\n"</span>);</span><br><span class="line">		<span class="keyword">if</span> (r==-E_BAD_PATH) writef(<span class="string">"E_BAD_PATH\n"</span>);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	o-&gt;o_file = f;</span><br><span class="line">	ff = (struct Filefd*)o-&gt;o_ff;</span><br><span class="line">	ff-&gt;f_file = *f;</span><br><span class="line">	ff-&gt;f_fileid = o-&gt;o_fileid;</span><br><span class="line">	o-&gt;o_mode = rq-&gt;req_omode;</span><br><span class="line">	ff-&gt;f_fd.fd_omode = o-&gt;o_mode;</span><br><span class="line">	ff-&gt;f_fd.fd_dev_id = devfile.dev_id;</span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"sending success, page %08x\n"</span>, (u_int)o-&gt;o_ff);</span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, (u_int)o-&gt;o_ff, PTE_V|PTE_R|PTE_LIBRARY);<span class="comment">//o_ff结构体与请求进程传入的fd结构体映射到了同一物理页,ipc_send建立了fd到o_ff的物理页的映射关系</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">out:user_panic(<span class="string">"*********************path:%s"</span>,path);</span><br><span class="line">	ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//映射地址服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_map</span><span class="params">(u_int envid, struct Fsreq_map *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"serve_map %08x %08x %08x\n"</span>, envid, rq-&gt;req_fileid, rq-&gt;req_offset);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">	u_int filebno;</span><br><span class="line">	<span class="keyword">void</span> *blk;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">    <span class="comment">//根据fileid这一唯一标识找到对应的open结构体</span></span><br><span class="line">	<span class="keyword">if</span>((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen))&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ipc_send(envid,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//根据文件内偏移获得所在的数据块下标</span></span><br><span class="line">	filebno = rq-&gt;req_offset/BY2BLK;</span><br><span class="line">    <span class="comment">//根据文件控制块+数据块下标获得该数据块映射到的虚拟页起始地址blk</span></span><br><span class="line">	<span class="keyword">if</span>((r = file_get_block(pOpen-&gt;o_file, filebno, &amp;blk))&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ipc_send(envid,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//使用IPC机制来使得用户进程设定的dstva映射到blk的物理页,即用户指定的虚拟地址与blk共享一个数据块,实现用户进程获得数据块</span></span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, blk, PTE_V|PTE_R|PTE_LIBRARY);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置文件大小服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_set_size</span><span class="params">(u_int envid, struct Fsreq_set_size *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"serve_set_size %08x %08x %08x\n"</span>, envid, rq-&gt;req_fileid, rq-&gt;req_size);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="keyword">if</span>((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen))&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                ipc_send(envid,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>((r = file_set_size(pOpen-&gt;o_file, rq-&gt;req_size))&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ipc_send(envid,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_close</span><span class="params">(u_int envid, struct Fsreq_close *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"serve_close %08x %08x\n"</span>, envid, rq-&gt;req_fileid);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="keyword">if</span>((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen))&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                ipc_send(envid,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//使用fs.c中的底层函数关闭文件控制块</span></span><br><span class="line">	file_close(pOpen-&gt;o_file);</span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span>;		</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除文件服务函数	</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_remove</span><span class="params">(u_int envid, struct Fsreq_remove *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"serve_map %08x %s\n"</span>, envid, rq-&gt;req_path);</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">	u_char path[MAXPATHLEN];</span><br><span class="line">        user_bcopy(rq-&gt;req_path, path, MAXPATHLEN);</span><br><span class="line">        path[MAXPATHLEN<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>((r = file_remove(path))&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                ipc_send(envid,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;	</span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//标记dirty位服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_dirty</span><span class="params">(u_int envid, struct Fsreq_dirty *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"serve_dirty %08x %08x %08x\n"</span>, envid, rq-&gt;req_fileid, rq-&gt;req_offset)</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="keyword">if</span>((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen))&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                ipc_send(envid,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="keyword">if</span>((r = file_dirty(pOpen-&gt;o_file, rq-&gt;req_offset))&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ipc_send(envid,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_sync</span><span class="params">(u_int envid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fs_sync();</span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据操作码选择操作的总的服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int req, whom, perm;</span><br><span class="line">	<span class="keyword">for</span>(;;) &#123;</span><br><span class="line">		perm = <span class="number">0</span>;</span><br><span class="line">		req = ipc_recv(&amp;whom, REQVA, &amp;perm);</span><br><span class="line">		<span class="keyword">if</span> (!(perm &amp; PTE_V)) &#123;</span><br><span class="line">			writef(<span class="string">"Invalid request from %08x: no argument page\n"</span>,</span><br><span class="line">				whom);</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">// just leave it hanging...</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> (req) &#123;</span><br><span class="line">		<span class="keyword">case</span> FSREQ_OPEN:</span><br><span class="line">			serve_open(whom, (struct Fsreq_open*)REQVA);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FSREQ_MAP:</span><br><span class="line">			serve_map(whom, (struct Fsreq_map*)REQVA);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FSREQ_SET_SIZE:</span><br><span class="line">			serve_set_size(whom, (struct Fsreq_set_size*)REQVA);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FSREQ_CLOSE:</span><br><span class="line">			serve_close(whom, (struct Fsreq_close*)REQVA);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FSREQ_DIRTY:</span><br><span class="line">			serve_dirty(whom, (struct Fsreq_dirty*)REQVA);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FSREQ_REMOVE:</span><br><span class="line">			serve_remove(whom, (struct Fsreq_remove*)REQVA);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FSREQ_SYNC:</span><br><span class="line">			serve_sync(whom);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			writef(<span class="string">"Invalid request code %d from %08x\n"</span>, whom, req);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		syscall_mem_unmap(<span class="number">0</span>, REQVA);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进程运行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">umain</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	user_assert(<span class="keyword">sizeof</span>(struct File)==<span class="number">256</span>);</span><br><span class="line">	writef(<span class="string">"FS is running\n"</span>);</span><br><span class="line">	writef(<span class="string">"FS can do I/O\n"</span>);</span><br><span class="line">	serve_init();</span><br><span class="line">	fs_init();</span><br><span class="line">	fs_test();	</span><br><span class="line">	serve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用户态下调用传递函数"><a href="#用户态下调用传递函数" class="headerlink" title="用户态下调用传递函数"></a>用户态下调用传递函数</h4><p>在用户态下<strong>准备传递的数据调用传递函数</strong>即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/fd.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span></span><br><span class="line">	u_int f_fileid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//user/file.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">.dev_id=	<span class="string">'f'</span>,</span><br><span class="line">.dev_name=	<span class="string">"file"</span>,</span><br><span class="line">.dev_read=	file_read,</span><br><span class="line">.dev_write=	file_write,</span><br><span class="line">.dev_close=	file_close,</span><br><span class="line">.dev_stat=	file_stat,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//真正的在用户态下打开文件的操作,基于IPC机制向文件进程发送打开文件请求</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">	u_int size,fileid;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	u_int va;</span><br><span class="line">	u_int i;</span><br><span class="line">	<span class="keyword">if</span>((r = fd_alloc(&amp;fd))&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//突然觉得这个r =  然后return r的写法很像java的异常抛出机制,可以把错误代码一层层向上传递</span></span><br><span class="line">		writef(<span class="string">"Without free fd left\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//向文件进程发送打开文件请求</span></span><br><span class="line">	<span class="keyword">if</span>((r = fsipc_open(path, mode, fd))&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		writef(<span class="string">"cannont open file %s\n"</span>,path);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	va = fd2data(fd);	</span><br><span class="line">	ffd = (struct Filefd*)fd;</span><br><span class="line">	size = ffd-&gt;f_file.f_size;</span><br><span class="line">	fileid = ffd-&gt;f_fileid;</span><br><span class="line">	<span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> fd2num(fd);</span><br><span class="line">	<span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; size; i+=BY2PG)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">/*使用map进程来在用户进程获得文件数据块</span></span><br><span class="line"><span class="comment">         *va为Fd_data的储存起始位置,为每一个文件分配4MB</span></span><br><span class="line"><span class="comment">         *size为文件大小</span></span><br><span class="line"><span class="comment">         *文件数据块所在位置通过fileid唯一确定的Open结构体中的文件控制块中的数据块指针来确定</span></span><br><span class="line"><span class="comment">         *fsipc_map将fileid打开文件偏移为i所在的数据块映射到以va+i为起始地址的虚拟页上</span></span><br><span class="line"><span class="comment">         *所以Fd_data在当文件打开时中存储的就是文件中的数据内容</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		<span class="keyword">if</span>((r = fsipc_map(fileid, i, va+i))&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			writef(<span class="string">"cannot map the file.\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fd2num(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_close</span><span class="params">(struct Fd *fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">	u_int va,size,fileid;</span><br><span class="line">	u_int i;</span><br><span class="line"></span><br><span class="line">	ffd = (struct Filefd*)fd;</span><br><span class="line">	fileid = ffd-&gt;f_fileid;</span><br><span class="line">	size = ffd-&gt;f_file.f_size;</span><br><span class="line">	va = fd2data(fd);      </span><br><span class="line">	<span class="comment">//将文件所有的数据块标记为dirty的,因为在fs中关闭文件控制块会判断数据块是否为dirty的,如果是则写回</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i += BY2PG)</span><br><span class="line">	&#123;</span><br><span class="line">			fsipc_dirty(fileid, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//使用IPC机制关闭文件描述符</span></span><br><span class="line">	<span class="keyword">if</span>((r = fsipc_close(fileid))&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		writef(<span class="string">"cannot close the file\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//去掉映射</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i +=BY2PG)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((r = syscall_mem_unmap(<span class="number">0</span>, va+i))&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			writef(<span class="string">"cannont unmap the file.\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	fd_close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从fd代表的文件中从offset位置读取n字节写入buf中</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">file_read</span><span class="params">(struct Fd *fd, <span class="keyword">void</span> *buf, u_int n, u_int offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line">	f = (struct Filefd*)fd;</span><br><span class="line">	<span class="comment">//最多读到文件的末尾</span></span><br><span class="line">	size = f-&gt;f_file.f_size;</span><br><span class="line">	<span class="keyword">if</span> (offset &gt; size)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (offset+n &gt; size)</span><br><span class="line">		n = size - offset;</span><br><span class="line">    <span class="comment">//读取的操作实际上是找到该段数据在Fd_data中的位置然后复制过来</span></span><br><span class="line">	user_bcopy((<span class="keyword">char</span>*)fd2data(fd)+offset, buf, n);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_map</span><span class="params">(<span class="keyword">int</span> fdnum, u_int offset, <span class="keyword">void</span> **blk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	u_int va;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span> (fd-&gt;fd_dev_id != devfile.dev_id)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	va = fd2data(fd) + offset;</span><br><span class="line">	<span class="keyword">if</span> (offset &gt;= MAXFILESIZE)</span><br><span class="line">		<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">	<span class="keyword">if</span> (!((* vpd)[PDX(va)]&amp;PTE_V) || !((* vpt)[VPN(va)]&amp;PTE_V))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br><span class="line">	*blk = (<span class="keyword">void</span>*)va;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向fd代表的文件中offset位置处写入从buf中拿到的n字节</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">file_write</span><span class="params">(struct Fd *fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, u_int n, u_int offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	u_int tot;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">	f = (struct Filefd*)fd;</span><br><span class="line">	tot = offset + n;</span><br><span class="line">	<span class="keyword">if</span> (tot &gt; MAXFILESIZE)</span><br><span class="line">		<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">	<span class="keyword">if</span> (tot &gt; f-&gt;f_file.f_size) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = ftruncate(fd2num(fd), tot)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	user_bcopy(buf, (<span class="keyword">char</span>*)fd2data(fd)+offset, n);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">file_stat</span><span class="params">(struct Fd *fd, struct Stat *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">	f = (struct Filefd*)fd;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(st-&gt;st_name, f-&gt;f_file.f_name);</span><br><span class="line">	st-&gt;st_size = f-&gt;f_file.f_size;</span><br><span class="line">	st-&gt;st_isdir = f-&gt;f_file.f_type==FTYPE_DIR;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//截取fdnum索引的fd代表的文件到size大小(size应该小于oldsize)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fdnum, u_int size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line">	u_int oldsize, va, fileid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &gt; MAXFILESIZE)</span><br><span class="line">		<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span> (fd-&gt;fd_dev_id != devfile.dev_id)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">	f = (struct Filefd*)fd;</span><br><span class="line">	fileid = f-&gt;f_fileid;</span><br><span class="line">	oldsize = f-&gt;f_file.f_size;</span><br><span class="line">	<span class="keyword">if</span> ((r = fsipc_set_size(fileid, size)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">	va = fd2data(fd);</span><br><span class="line">	<span class="keyword">for</span> (i = ROUND(oldsize, BY2PG); i &lt; ROUND(size, BY2PG); i += BY2PG) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = fsipc_map(fileid, i, va+i)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			fsipc_set_size(fileid, oldsize);</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = ROUND(size, BY2PG); i &lt; ROUND(oldsize, BY2PG); i+=BY2PG)</span><br><span class="line">		<span class="keyword">if</span> ((r = syscall_mem_unmap(<span class="number">0</span>, va+i)) &lt; <span class="number">0</span>)</span><br><span class="line">			user_panic(<span class="string">"ftruncate: syscall_mem_unmap %08x: %e"</span>, va+i, r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fsipc_remove(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步文件内容,将文件写入磁盘中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fsipc_sync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注 :</p>
<ol>
<li><p><strong>在我们的设计中文件系统是作为磁盘外设看待的,所以上述机制可以自然地推广到其他外设上,例如我们已经实现了的有<code>console</code>与<code>pipe</code></strong></p>
</li>
<li><p><strong>在文件操作中我们使用了大量的结构体,这些结构体有以下的关系</strong> :</p>
<p>这种结构体相互包含的结构颇有面向对象父类与子类的意思</p>
<p><img src="/2019/05/21/OS-lab5/struct.png" alt></p>
<p><strong>它们的使用时机是</strong> :</p>
<ul>
<li><code>File</code>是文件控制块,是在<strong>磁盘文件内容本身中保存在某一块中的(从<code>super</code>可以知道在哪一块),其内容由文件系统的结构决定</strong>,所以该数据结构是我们从磁盘中直接<strong>加载到内存指定位置(映射关系是简单的线性的,详见快缓存机制)使用的,不需要自己建立</strong></li>
<li><code>Fd</code>是文件描述符,<strong>在打开一个文件时建立它的描述符</strong>,在分配时给每个<code>Fd</code><strong>分配一页的空间</strong>,<strong>每一个<code>Fd</code>对应一个<code>4MB</code>大小的<code>Fd_data</code>,对应关系是在各自的顺序结构中下标<code>index</code>相同</strong>,由图中可以看出<code>Fd</code>数据结构指针可以<strong>强制转换为<code>Filefd</code>指针</strong> :<ol>
<li><code>dev_id</code> : 外设唯一编号</li>
<li><code>fd_offset</code> : 对一个打开的文件读取到的偏移量</li>
<li><code>fd_omode</code> : 打开文件的方式</li>
</ol>
</li>
<li><code>Filefd</code>是对<strong>打开文件的进一步描述</strong>,其中<strong><code>fileid</code>是每次打开某一文件的唯一标识</strong>,其都是从<code>Fd</code>转换而来的,存储空间就是为<code>Fd</code>分配那一页</li>
<li><code>open</code>结构体是<strong>在进程服务进程<code>serv.c</code>中使用的</strong>,通过用户进程通信传递的打开文件唯一标识<code>fileid</code>来找到对应的<code>Fildefd</code>结构体,<strong>然后我们就知道了用户进程要求的文件信息应该填在哪里,<code>serve</code>进程根据<code>path</code>找到文件并装载进内存,然后将<code>File</code>文件控制块填入<code>Fildfd</code>中的域,将<code>File</code>指向的数据块填入(建立映射)<code>Fd</code>对应的<code>Fd_data</code>的<code>4MB</code>大小空间</strong></li>
</ul>
</li>
<li><p><strong>进程通信机制</strong> :</p>
<p><img src="/2019/05/21/OS-lab5/ipc.png" alt></p>
</li>
<li><p><strong>最重要的<code>open</code>操作</strong></p>
<p><img src="/2019/05/21/OS-lab5/open.png" alt></p>
</li>
</ol>
<h1 id="一点想法"><a href="#一点想法" class="headerlink" title="一点想法"></a>一点想法</h1><p>我对<code>OS</code>这门课理性的看待之后,我认为有以下几点 :</p>
<ol>
<li>对于一个普通的学生而言,花费很多时间获得的知识最多只能是<strong>看懂这个架构是怎么运行的</strong>,但是对<code>OS</code>设计的<strong>为什么这么做</strong>很难有正确的理解</li>
<li>测试手段太过薄弱,不仅是没有调试的手段,来测试发现<code>bug</code>的手段都十分简陋</li>
<li>指导书真的远远不够(指导作用),我不是说所有的东西都要给出答案,只是要有一点更详细的说明</li>
</ol>
<p><code>lab5-2</code>课上本地无误线上测试玄学,至今不知道哪里错了,哎,我也不说什么不后悔的屁话,伤心肯定是有的,毕竟作为一个普通学生,我自认为在这门课上花的时间也不少,至少和<code>OO</code>可以<del>五五开</del>,但是现在估计结局不会怎么好,怎么说呢,还是太菜,不过真心每次在这种时候都有转系的冲动,自己是不是真的没有能力吃这碗饭</p>
<p><code>I tried, I failed, I died, that&#39;s all, nothing more</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/03/OS-lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/OS-lab4/" itemprop="url">OS-lab4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-03T19:40:14+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="lab4做了什么"><a href="#lab4做了什么" class="headerlink" title="lab4做了什么"></a>lab4做了什么</h1><h2 id="支持缺页中断处理"><a href="#支持缺页中断处理" class="headerlink" title="支持缺页中断处理"></a>支持缺页中断处理</h2><p>正常的缺页重填与写时复制导致的缺页</p>
<h2 id="完成基本的系统调用"><a href="#完成基本的系统调用" class="headerlink" title="完成基本的系统调用"></a>完成基本的系统调用</h2><p>我认为系统调用的实质就是用户态的进程想使用一些内核态下的功能,比如分配内存空间,创建进程等等,但是由于操作系统要保障<strong>安全性</strong>,所以这些接口不能向用户程序开放,所以采用一个折中的方法,即<strong>系统调用</strong>,用户将一些必要的信息以<strong>参数的形式</strong>传递给内核,内核判断你的操作是否<strong>合法</strong>,合法则执行并将结果返回给用户,否则拒绝执行</p>
<h2 id="实现fork"><a href="#实现fork" class="headerlink" title="实现fork"></a>实现fork</h2><p><code>fork</code>就是<strong>以父进程为模板</strong>创建一个与其<strong>高度相似</strong>的子进程,其关键的一点特性是<strong>父子进程中的<code>fork</code>返回值不同</strong>,这也是区分父子进程的方法</p>
<h2 id="实现进程间通信"><a href="#实现进程间通信" class="headerlink" title="实现进程间通信"></a>实现进程间通信</h2><p>通信本质上就是<strong>在进程间传递一个数值</strong>, 通过<strong>共享内存</strong>来实现, 共享的就是内核中的进程控制块</p>
<h1 id="提前准备的知识"><a href="#提前准备的知识" class="headerlink" title="提前准备的知识"></a>提前准备的知识</h1><h2 id="MIPS下C与汇编的参数传递"><a href="#MIPS下C与汇编的参数传递" class="headerlink" title="MIPS下C与汇编的参数传递"></a>MIPS下C与汇编的参数传递</h2><p>首先介绍两个关于MIPS汇编的宏定义 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/asm/asm.h</span></span><br><span class="line"><span class="comment">// 用来定义全局叶子汇编函数 : 即在函数内部不需要调用其他函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEAF(symbol)                                    \</span></span><br><span class="line">                .globl  symbol;                         \</span><br><span class="line">                .align  <span class="number">2</span>;                              \</span><br><span class="line">                .type   symbol,@function;               \</span><br><span class="line">                .ent    symbol,<span class="number">0</span>;                       \</span><br><span class="line">symbol:         .frame  sp,<span class="number">0</span>,ra</span><br><span class="line"><span class="comment">// 用来定义全局非叶子汇编函数 : 即在函数内部还调用其他函数 </span></span><br><span class="line"><span class="comment">// 所以在该宏定义结构中已经做了对栈指针的处理</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NESTED(symbol, framesize, rpc)                  \</span></span><br><span class="line">                .globl  symbol;                         \</span><br><span class="line">                .align  <span class="number">2</span>;                              \</span><br><span class="line">                .type   symbol,@function;               \</span><br><span class="line">                .ent    symbol,<span class="number">0</span>;                       \</span><br><span class="line">symbol:         .frame  sp, framesize, rpc</span><br><span class="line"><span class="comment">// 函数结尾</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> END(function)                                   \</span></span><br><span class="line">                .end    function;                       \</span><br><span class="line">                .size   function,.-function</span><br></pre></td></tr></table></figure>
<p><strong>注意我们一般而言只有在接近底层时才有使用到汇编来实现,所以大部分汇编功能都能通过叶子函数完成</strong></p>
<ol>
<li><p>C函数之间的调用 : </p>
<p>所有的参数传递以及返回值的维护由编译器隐式的实现,不需要考虑</p>
</li>
<li><p>MIPS汇编之间的调用</p>
<ul>
<li>调用者需要在代码中显式的在栈中保存受保护寄存器,返回值寄存器等,然后显式的向<code>$a0-$a3</code>中写入参数值,然后调用,返回时要恢复现场</li>
<li>被调用者需要显式的获取参数</li>
<li>参数较多时通过栈传递</li>
</ul>
<p>其实就是<strong>调用者与被调用者遵守并显式的实现统一的调用规则</strong></p>
</li>
<li><p><strong>C调用MIPS汇编函数</strong> : 最常见的一种情况(依据<code>o32ABI</code>的约定)</p>
<ul>
<li>调用者(即C函数) : <ol>
<li>在栈上创建一个容纳参数的空间,从<code>sp</code>指向的位置开始,第一个参数(即C源码中最左侧的参数)位于最低地址处,<strong>每个参数至少占据一个字的大小空间</strong></li>
<li><strong>为任何一个调用都至少分配16字节的栈参数空间,即使没有这么多参数</strong></li>
<li><strong>实际上优先通过的是寄存器传递参数,即参数结构的前16个字节(即4个字)保存在<code>$a0-$a3</code>的寄存器结构中,而栈中的前16个字节的内容未定义,但是其结构必须保存</strong></li>
</ol>
</li>
<li>被调用者(MIPS函数)<ol>
<li>可以选择盲目的将<code>$a0-$a3</code>的写入栈中,也可以不写(取决于该汇编函数的功能)</li>
<li><strong>前4个参数从寄存器获得,之后的参数从栈中获得</strong></li>
</ol>
</li>
</ul>
<p>// 他说此处应该有个图</p>
</li>
<li><p>MIPS汇编函数调用C函数 :</p>
<ul>
<li><p>调用者(即MIPS汇编代码) : 将参数按照C函数的定义从左向右的顺序存入<code>$a0-$a3</code>寄存器中,如果要求在调用结束后保存某些寄存器则要使用栈区保存(<strong>注意<code>ra</code>寄存器是一定要保存的,并在调用结束之后要恢复</strong>),然后直接跳转到C函数的入口地址处即可</p>
<p>注 : 具体实现方法为<strong>在.S文件中使用<code>extern</code>外联定义C函数<code>c_method()</code>,然后直接使用<code>jal c_method</code>即可</strong>(因为<code>jal</code>会写入返回地址到<code>$ra</code>中,而C函数在最后会自动调用<code>jr ra</code>)</p>
</li>
<li><p>被调用者(C函数) : 不用做任何特殊处理,正常编写即可</p>
</li>
</ul>
</li>
</ol>
<h2 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h2><p><strong>时钟中断,系统调用,以及在指令执行中出现的错误都作为一种异常处理</strong></p>
<h3 id="异常处理程序地址"><a href="#异常处理程序地址" class="headerlink" title="异常处理程序地址"></a>异常处理程序地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tools/sces0_3.lds</span></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  . = <span class="number">0x80000080</span>;</span><br><span class="line">  .except_vec3 : &#123;</span><br><span class="line">	*(.text.exc_vec3)</span><br><span class="line">  &#125;<span class="comment">// 可见我们将所有exc_vec3代码段加载到了0x80000080地址处,而这些代码就是最基本的异常处理程序(异常分发程序),实际上该处的代码并没有真正处理异常,只是根据异常类型将其分发给特定的异常处理程序</span></span><br><span class="line">  <span class="comment">// other code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地址<code>0x80000080</code>是当异常发生时<code>CPU</code>将<code>PC</code>跳转到的地址(由<code>MIPS R3000 CPU</code>的设计决定的)</p>
<p>即异常发生时 : <strong>首先是硬件发挥作用,即CPU进行以下行为</strong> : </p>
<ol>
<li>设置<code>EPC</code>为异常处理结束后重新开始的程序地址</li>
<li>设置<code>CP0</code>的<code>SR</code>寄存器中的<code>EXL</code>位使得<code>CPU</code>进入内核态<strong>禁止中断</strong></li>
<li>设置<code>CP0</code>的<code>CAUSE</code>寄存器编码为异常产生原因</li>
<li>设置<code>PC</code>值为异常处理程序的入口地址(在此处即<code>0x80000080</code>)</li>
</ol>
<h3 id="异常类型注册表"><a href="#异常类型注册表" class="headerlink" title="异常类型注册表"></a>异常类型注册表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/traps.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">handle_int</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">handle_reserved</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">handle_tlb</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">handle_sys</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">handle_mod</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 以上具体的实现在外部函数实现</span></span><br><span class="line"><span class="comment">/* 这个数组即是异常向量</span></span><br><span class="line"><span class="comment"> * 向量下标与CAUSE寄存器中的异常类型编号对用</span></span><br><span class="line"><span class="comment"> * 向量每一项为对应异常种类的处理程序的入口地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> exception_handlers[<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">	set_except_vector(i, handle_reserved);</span><br><span class="line">	set_except_vector(<span class="number">0</span>, handle_int);	<span class="comment">//时钟中断异常处理程序</span></span><br><span class="line">	set_except_vector(<span class="number">1</span>, handle_mod);	<span class="comment">//缺页异常处理程序</span></span><br><span class="line">	set_except_vector(<span class="number">2</span>, handle_tlb);	</span><br><span class="line">	set_except_vector(<span class="number">3</span>, handle_tlb);	<span class="comment">//tlb确实异常处理</span></span><br><span class="line">	set_except_vector(<span class="number">8</span>, handle_sys);	<span class="comment">//系统调用异常处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">set_except_vector</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">void</span> * addr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> handler=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> old_handler=exception_handlers[n];</span><br><span class="line">	exception_handlers[n]=handler;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)old_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注 : 异常类型在<code>CAUSE</code>寄存器中对应的编码值</p>
<p><img src="/2019/05/03/OS-lab4/handle_kind.png" alt></p>
<h3 id="异常分发程序"><a href="#异常分发程序" class="headerlink" title="异常分发程序"></a>异常分发程序</h3><p>异常发生时<strong>直接跳转到</strong>的函数地址</p>
<ul>
<li><p>作用 : 根据<code>CAUSE</code>寄存器的值判断异常类型并跳转到对应的处理程序去</p>
</li>
<li><p>实现 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//boot/start.S</span></span><br><span class="line">.section .text.exc_vec3</span><br><span class="line">NESTED(except_vec3, <span class="number">0</span>, sp) <span class="comment">// 非叶子函数因为要跳转到</span></span><br><span class="line">	.<span class="built_in">set</span>	noat</span><br><span class="line">	.<span class="built_in">set</span>	noreorder</span><br><span class="line"><span class="number">1</span>:	<span class="comment">//j	1b</span></span><br><span class="line">	nop</span><br><span class="line">	mfc0	k1,CP0_CAUSE	    <span class="comment">//$k1中存储CAUSE寄存器中的值</span></span><br><span class="line">	andi	k1,<span class="number">0x7c</span>			   <span class="comment">//$k1中存储异常类型的编码值,具体见下文</span></span><br><span class="line">	la	k0,exception_handlers	<span class="comment">//$k0中存储异常向量的起始地址(即数组的基址)</span></span><br><span class="line">	addu	k0,k1			   <span class="comment">//$k0 + $k1 即基址+偏移获得存储(异常处理程序的入口地址)的地址放入$k0中</span></span><br><span class="line">	lw	k0,(k0)				   <span class="comment">//从该地址中取出异常处理程序的入口地址</span></span><br><span class="line">	NOP</span><br><span class="line">	jr	k0					  <span class="comment">//跳转到对应的异常处理程序</span></span><br><span class="line">	nop</span><br><span class="line">	END(except_vec3)</span><br></pre></td></tr></table></figure>
<p>注 : 对<code>andi k1,0x7c</code>的理解</p>
<ol>
<li><p><code>CAUSE</code>寄存器结构如下 :</p>
<p><img src="/2019/05/03/OS-lab4/cause_register.png" alt></p>
</li>
<li><p><code>0x7c = 0x0111_1100</code>,与该数按位与就是获得<code>2-6</code>位的值,从上图可知就是<code>Exc Code</code>的值,所以该操作可以获得异常类型的编码值</p>
</li>
</ol>
</li>
<li><p>在异常分发完之后就是实际的处理程序的运行了</p>
<p>处理异常完成之后即可<strong>返回<code>EPC</code>保存的地址</strong></p>
</li>
</ul>
<h3 id="流程图示"><a href="#流程图示" class="headerlink" title="流程图示"></a>流程图示</h3><p><img src="/2019/05/03/OS-lab4/epc.png" alt></p>
<h1 id="走进lab4"><a href="#走进lab4" class="headerlink" title="走进lab4"></a>走进lab4</h1><h2 id="基本系统调用"><a href="#基本系统调用" class="headerlink" title="基本系统调用"></a>基本系统调用</h2><h3 id="宏观上看一个系统调用的过程"><a href="#宏观上看一个系统调用的过程" class="headerlink" title="宏观上看一个系统调用的过程"></a>宏观上看一个系统调用的过程</h3><ol>
<li>调用一个封装好的用户空间的库函数</li>
<li>调用用户空间的<code>syscall_*</code> 函数</li>
<li>调用<code>msyscall</code>，用于陷入内核态</li>
<li>陷入内核，内核取得信息，执行对应的内核空间的系统调用函数（<code>sys_*</code>）</li>
<li>执行系统调用，并返回用户态，同时将返回值传递回用户态</li>
<li>从库函数返回，回到用户程序调用处</li>
</ol>
<h3 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h3><ol>
<li><p>用户态的行为 : </p>
<ol>
<li><p>调用<code>syscall_*</code>函数,等待返回值(如果有的话)</p>
<p><strong>用户空间不负责任何实质的处理,只是准备好参数之后陷入内核态即可</strong></p>
<p><strong>所有的系统调用都是通过<code>mysyscall</code>陷入内核,通过第一个参数作为系统调用号来区别不同的系统调用种类</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/syscall_lib.c</span></span><br><span class="line"><span class="comment">//所有函数的调用第一个参数是系统调用号(即系统调用类型)</span></span><br><span class="line"><span class="comment">//默认所有的调用都有6个参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_yield</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	msyscall(SYS_yield,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_env_destroy</span><span class="params">(u_int envid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	msyscall(SYS_env_destroy,envid,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall_set_pgfault_handler</span><span class="params">(u_int envid, u_int func, u_int xstacktop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_set_pgfault_handler,envid,func,xstacktop,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall_mem_alloc</span><span class="params">(u_int envid, u_int va, u_int perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_mem_alloc,envid,va,perm,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall_mem_map</span><span class="params">(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_mem_map,srcid,srcva,dstid,dstva,perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即用户准备好必要的信息,然后<strong>包装一层</strong>将第一个参数设置为<strong>系统调用号</strong>,然后内核根据系统调用号的值(<strong>偏移</strong>)决定<strong>真正执行功能的函数的入口地址</strong></p>
<p>这些系统调用号以一个注册表的形式定义在头文件中 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/unistd.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNISTD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNISTD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_BASE 9527</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_SYSCALLS 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_putchar 		((__SYSCALL_BASE ) + (0 ) ) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_getenvid 		((__SYSCALL_BASE ) + (1 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_yield			((__SYSCALL_BASE ) + (2 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_env_destroy		((__SYSCALL_BASE ) + (3 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_set_pgfault_handler	((__SYSCALL_BASE ) + (4 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_mem_alloc		((__SYSCALL_BASE ) + (5 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_mem_map			((__SYSCALL_BASE ) + (6 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_mem_unmap		((__SYSCALL_BASE ) + (7 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_env_alloc		((__SYSCALL_BASE ) + (8 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_set_env_status	((__SYSCALL_BASE ) + (9 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_set_trapframe		((__SYSCALL_BASE ) + (10 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_panic			((__SYSCALL_BASE ) + (11 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_ipc_can_send		((__SYSCALL_BASE ) + (12 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_ipc_recv		((__SYSCALL_BASE ) + (13 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_cgetc			((__SYSCALL_BASE ) + (14 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用<code>msyscall</code>触发系统调用异常陷入内核态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/syscall_wrap.S</span></span><br><span class="line">LEAF(msyscall)	<span class="comment">//说明该函数是一个全局叶子函数,不需要调用其他函数</span></span><br><span class="line"><span class="comment">// sw	a0,0(sp)</span></span><br><span class="line"><span class="comment">// sw	a1,4(sp)</span></span><br><span class="line"><span class="comment">// sw	a2,8(sp)</span></span><br><span class="line"><span class="comment">// sw	a3,12(sp)</span></span><br><span class="line"><span class="comment">// move	v0, a0</span></span><br><span class="line"><span class="comment">// 将参数存入已经在C函数调用汇编函数时分配好的栈空间中</span></span><br><span class="line"><span class="comment">// 我认为目的就是稳一手,防止在异常分发程序中使用这些寄存器破坏数据(反正空间都已经在那了)</span></span><br><span class="line"><span class="comment">// 稳一手把自己稳炸了,不要写上面这些!!!!</span></span><br><span class="line">syscall	<span class="comment">//触发系统调用异常</span></span><br><span class="line">jr	ra</span><br><span class="line">END(msyscall)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p><strong>当调用<code>syscall</code>时发生了什么 : </strong></p>
<p>触发<strong>系统调用异常</strong>按照<strong>上面描述的异常处理流程</strong>将该异常分发到<strong>系统调用处理程序</strong></p>
</li>
<li><p>上述的保存寄存器代码段是依据于系统调用约定 :</p>
<ol>
<li><del>系统调用号放入<code>$v0</code></del>(课上测试不放我有什么办法)</li>
<li>参数的传递按照<code>o32ABI</code>的约定进行 :</li>
</ol>
<ul>
<li>在<code>syscall_lib.c</code>中C函数调用<code>msyscall(SYS_*, arg1,...arg5)</code>时<strong>依据约定栈区划定24字节空间,前4个参数通过<code>$a0-$a3</code>传递,后两个参数通过栈区传递</strong><ul>
<li><del>我为什么不能把所有的参数都放进栈中,为什么,艹</del></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>内核态的行为</p>
<ol>
<li><p>接下来运行<strong>系统调用异常处理程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/syscall.S</span></span><br><span class="line">NESTED(handle_sys,TF_SIZE, sp)</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有的异常处理的第一步都是保存现场(关于保存现场详情移步lab3)</span></span><br><span class="line">SAVE_ALL	<span class="comment">//保存运行现场,即将寄存器全部压栈</span></span><br><span class="line"><span class="comment">// 在上述保存过程中</span></span><br><span class="line">CLI		    <span class="comment">//关闭中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1: j 1b</span></span><br><span class="line">nop</span><br><span class="line">.<span class="built_in">set</span> at</span><br><span class="line"></span><br><span class="line">lw t1, TF_EPC(sp)</span><br><span class="line">addiu t1, <span class="number">4</span></span><br><span class="line">sw	t1, TF_EPC(sp)</span><br><span class="line"><span class="comment">//从保存的现场中取出EPC再+4之后存回,即为异常处理结束之后的重新开始运行的PC值</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//从保存的现场中取出$4即$a0的值存入a0当中去</span></span><br><span class="line">lw a0, TF_REG4(sp)	<span class="comment">//a0即保存的系统调用号</span></span><br><span class="line">addiu a0, a0, -SYSCALL_BASE	<span class="comment">//获得偏移,即获得了系统调用的具体种类</span></span><br><span class="line">sll	t0, a0,<span class="number">2</span></span><br><span class="line">la	t1, sys_call_table	<span class="comment">//t1为系统调用注册表(即下文的入口地址表)的起始地址</span></span><br><span class="line">addu	t1, t1, t0		<span class="comment">//根据偏移得到(具体系统调用函数的入口地址)的地址</span></span><br><span class="line">lw	t2, <span class="number">0</span>(t1)			<span class="comment">//取出入口地址放入$t2</span></span><br><span class="line">lw	t0,TF_REG29(sp)		<span class="comment">//取出保存现场保存的用户态下的栈指针放入$t0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意参数的不同分布</span></span><br><span class="line"><span class="comment">// 前4个参数由于是通过$ai来传递的,所以在保存现场时被存在TF区域,要从这里恢复</span></span><br><span class="line"><span class="comment">// 后两个参数本身就是通过栈来传递的,所以在用户的sp栈指针所指的栈中,而这个栈指针已经取到$t0中去了</span></span><br><span class="line">lw t3, <span class="number">16</span>($t0)</span><br><span class="line">lw t4, <span class="number">20</span>($t0)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//恢复$a0-$a3参数</span></span><br><span class="line">lw a0, TF_REG4(sp)</span><br><span class="line">lw a1, TF_REG5(sp)</span><br><span class="line">lw a2, TF_REG6(sp)</span><br><span class="line">lw a3, TF_REG7(sp)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//然后准备参数,调用对应的系统调用(调用C函数)</span></span><br><span class="line"><span class="comment">//参数 : 前4个通过寄存器传,后面两个通过sp栈区传</span></span><br><span class="line"><span class="comment">//但是在栈区还是要留前4个参数的空间,只不过什么都不存(我也不知道为什么,艹)</span></span><br><span class="line">addiu sp, sp, <span class="number">-24</span></span><br><span class="line">sw t3, <span class="number">16</span>(sp)</span><br><span class="line">sw t4, <span class="number">20</span>(sp)</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line">jalr t2</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复栈指针</span></span><br><span class="line">addiu sp, sp, <span class="number">24</span></span><br><span class="line">   </span><br><span class="line">sw	v0, TF_REG2(sp)</span><br><span class="line"></span><br><span class="line">j	ret_from_exception</span><br><span class="line">nop</span><br><span class="line">END(handle_sys)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 系统调用注册表    </span></span><br><span class="line">sys_call_table:</span><br><span class="line">.align <span class="number">2</span></span><br><span class="line">    .word sys_putchar	<span class="comment">//每一个word存储该系统调用函数的入口地址</span></span><br><span class="line">    .word sys_getenvid</span><br><span class="line">    .word sys_yield</span><br><span class="line">    .word sys_env_destroy</span><br><span class="line">    .word sys_set_pgfault_handler</span><br><span class="line">    .word sys_mem_alloc</span><br><span class="line">    .word sys_mem_map</span><br><span class="line">    .word sys_mem_unmap</span><br><span class="line">    .word sys_env_alloc</span><br><span class="line">    .word sys_set_env_status</span><br><span class="line">    .word sys_set_trapframe</span><br><span class="line">    .word sys_panic</span><br><span class="line">    .word sys_ipc_can_send</span><br><span class="line">    .word sys_ipc_recv</span><br><span class="line">    .word sys_cgetc</span><br></pre></td></tr></table></figure>
<p><strong>参数分布图示</strong></p>
<p><img src="/2019/05/03/OS-lab4/args.png" alt></p>
<p>下面我就想不通了 : </p>
<ul>
<li>在异常分发阶段只是使用了<code>$k0,$k1</code>寄存器</li>
<li>在进入系统调用异常处理程序即<code>handle_sys</code>已经关闭了时钟中断</li>
<li>在<code>SAVA_ALL</code>和恢复参数之间并没有使用<code>$a0-$a3</code>寄存器</li>
</ul>
<p>所以这个保存现场+恢复在目前看来完全是无用操作,在最后设置参数时只需设置<code>args[4],args[5]</code>即可(实测可以跑)</p>
<p>我认为有以下考虑 :</p>
<ol>
<li>操作的统一性 : 处理异常第一件事就是保存现场</li>
<li>后续扩展功能可能破坏寄存器</li>
<li><del>课上测试换你文件</del></li>
</ol>
</li>
<li><p>接下来便是各种<del>神奇</del>的系统调用了</p>
</li>
</ol>
</li>
</ol>
<h4 id="各种系统调用"><a href="#各种系统调用" class="headerlink" title="各种系统调用"></a>各种系统调用</h4><ol>
<li><p><code>void sys_yield(void)</code> : </p>
<ul>
<li><p>函数作用 : 在用户态下做到进程切换</p>
</li>
<li><p>具体实现 : </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_yield</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先保存现场</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> * <span class="title">src</span> = (<span class="title">struct</span> <span class="title">Trapframe</span> *)(<span class="title">KERNEL_SP</span> - <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trapframe</span>));</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> * <span class="title">dst</span> = (<span class="title">struct</span> <span class="title">Trapframe</span> *)(<span class="title">TIMESTACK</span> - <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trapframe</span>));</span></span><br><span class="line">	bcopy((<span class="keyword">void</span> *)src,(<span class="keyword">void</span> *)dst,<span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">	sched_yield();<span class="comment">//执行时间片轮转调度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两个问题 : </p>
<ul>
<li><p><strong>为什么在此处我们保存现场时将<code>KERNEL_SP</code>栈中的数据保存到<code>TIMESTACK</code>栈中去,而在<code>lab3</code>中的进程切换的保存恢复现场都是在<code>TIMESTACK</code>中进行的 ? </strong></p>
<p><del>很不幸,这个问题沙雕的我不想思考</del></p>
<p>我认为<strong><code>kERNEL_SP</code>是系统调用异常时保存现场的区域,而<code>TIMESTACK</code>是时钟中断异常时保存现场的区域</strong></p>
<p><strong>其实这个关键在于<code>SAVE_ALL</code>中的<code>get_sp</code></strong> : </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/stackframe.h</span></span><br><span class="line">.macro SAVE_ALL    </span><br><span class="line">                                  </span><br><span class="line">		mfc0	k0,CP0_STATUS                   </span><br><span class="line">		sll		k0,<span class="number">3</span>   </span><br><span class="line">		bltz	k0,<span class="number">1f</span>                            </span><br><span class="line">		nop      		           </span><br><span class="line"><span class="number">1</span>:				</span><br><span class="line">		move	k0,sp </span><br><span class="line">		get_sp      <span class="comment">//获取要保存寄存器的栈的栈指针</span></span><br><span class="line">		move	k1,sp                     </span><br><span class="line">		subu	sp,k1,TF_SIZE  <span class="comment">// 栈指针下移获得空间                 </span></span><br><span class="line">		sw	k0,TF_REG29(sp)    <span class="comment">// 保存寄存器</span></span><br><span class="line">		........</span><br><span class="line">.macro get_sp</span><br><span class="line">	mfc0	k1, CP0_CAUSE</span><br><span class="line">	andi	k1, <span class="number">0x107C</span>	<span class="comment">//获取CAUSE寄存器中的ExcCode段</span></span><br><span class="line">	xori	k1, <span class="number">0x1000</span></span><br><span class="line">	bnez	k1, <span class="number">1f</span></span><br><span class="line">	nop</span><br><span class="line">	li	sp, <span class="number">0x82000000</span>	<span class="comment">//取TIMESTACK为保存的栈</span></span><br><span class="line">	j	<span class="number">2f</span></span><br><span class="line">	nop</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">	bltz	sp, <span class="number">2f</span></span><br><span class="line">	nop</span><br><span class="line">	lw	sp, KERNEL_SP  <span class="comment">//取KERNEL_SP为保存的栈</span></span><br><span class="line">	nop</span><br><span class="line"><span class="number">2</span>:	nop</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>
<p>即 : </p>
<ul>
<li><strong>在系统调用时异常处理程序第一步是将寄存器信息保存到<code>KERNEL_SP</code>栈区</strong></li>
<li><strong>在时钟中断时异常处理程序第一步是将寄存器信息保存到<code>TIMESTACK</code>栈区</strong></li>
</ul>
<p>所以该函数的实现如下 : </p>
<ol>
<li><p>进入该函数时寄存器信息已经保存到<code>KERNEL_SP</code>栈区了(<code>handle_sys</code>中进行)</p>
</li>
<li><p><strong>但是在<code>env_run</code>中我们默认是时钟中断导致的进程切换,没有考虑用户显式的命令进程切换,所以我们在切换之前保存当前进程信息都是从<code>TIMESTACK</code>中取数据,所以一定要将<code>KERNEL_SP</code>中的现场在<code>TIMESTACK</code>中备份一份以便进程切换</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/env.c/evn_run()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> *<span class="title">old</span> = (<span class="title">struct</span> <span class="title">Trapframe</span> *)(<span class="title">TIMESTACK</span>-<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trapframe</span>));</span></span><br><span class="line">	<span class="keyword">if</span>(curenv)&#123;</span><br><span class="line">		bcopy(old,&amp;(curenv-&gt;env_tf),<span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">		<span class="comment">//curenv-&gt;env_tf.pc += 4;//aim to mips 32</span></span><br><span class="line">		curenv-&gt;env_tf.pc = old-&gt;cp0_epc;</span><br><span class="line">		<span class="comment">//printf("cp0_epc:%x\n",curenv-&gt;env_tf.pc);</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><strong>调度函数的逻辑需要修改</strong></p>
<p>在<code>lab4</code>的进程切换函数中我们有了新的需求,我认为大概要求如下 : </p>
<ol>
<li>待调度链表中可以有状态为<code>ENV_NOTRUNNABLE</code>的进程控制块,要求其不能被调度</li>
<li><strong>用户态可以使用系统调用设置一个进程为<code>ENV_NOTRUNNABLE</code>状态,要求进入调度算法时当前进程若为<code>ENV_NOTRUNNABLE</code>,即使其时间片还未用完也调度走</strong></li>
</ol>
<p>在<code>lab3</code>的基础上增加几个判断即可,基本思想还是<strong>用两个链表模拟循环链表</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/sched.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_yield</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	counter++;</span><br><span class="line">	<span class="keyword">if</span> (curenv == <span class="literal">NULL</span> || counter &gt;= curenv-&gt;env_pri || curenv-&gt;env_status != ENV_RUNNABLE)	<span class="comment">//进程未NOTRUNNABLE立即调度</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (curenv != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LIST_INSERT_TAIL(&amp;env_sched_liat[t^<span class="number">1</span>], curenv, env_sched_link);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span>  <span class="title">Env</span> *<span class="title">e</span> = <span class="title">LIST_FIRST</span>(&amp;<span class="title">env_sched_list</span>[<span class="title">t</span>]);</span></span><br><span class="line">			<span class="keyword">if</span> (e == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				t = t ^ <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (e-&gt;env_status == ENV_RUNNABLE)</span><br><span class="line">			&#123;</span><br><span class="line">				LIST_REMOVE(e, env_sched_link);</span><br><span class="line">				counter = <span class="number">0</span>;</span><br><span class="line">				env_run(e);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;	<span class="comment">//NOT_RUNNABKLE的扔到另一个链表中</span></span><br><span class="line">				LIST_REMOVE(e, env_sched_link);</span><br><span class="line">				LIST_INSERT_TAIL(&amp;env_sched_list[t^<span class="number">1</span>], e, env_sched_link);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	env_run(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>int sys_mem_alloc(iint sysno, u_int envid, u_int va, u_int perm)</code> : </p>
<ul>
<li><p>函数作用 : 给指定进程<code>envid</code>的指定地址<code>va</code>分配一页地址</p>
</li>
<li><p>具体实现 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_mem_alloc</span><span class="params">(<span class="keyword">int</span> sysno, u_int envid, u_int va, u_int perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//检查虚拟地址va是否合法</span></span><br><span class="line">	<span class="keyword">if</span>(va&gt;=UTOP || va&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,use sys_mem_alloc must promise va &lt; UTOP(%x),but now va:%x\n"</span>,UTOP,va);</span><br><span class="line">		<span class="keyword">return</span> -E_UNSPECIFIED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//检查权限位</span></span><br><span class="line">	<span class="keyword">if</span>((perm &amp; PTE_COW) || !(perm &amp; PTE_V))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,use sys_mem_alloc must promise perm not contain PTE_COW.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">ppage</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(envid2env(envid,&amp;env,<span class="number">0</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,you can't get the env by the given env_id.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//新分配一个物理页</span></span><br><span class="line">	<span class="keyword">if</span>(page_alloc(&amp;ppage)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,use sys_mem_alloc can't get a free page memory.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//在进程的页表中建立映射关系</span></span><br><span class="line">	<span class="keyword">if</span>(page_insert(env-&gt;env_pgdir,ppage,va,perm)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_mem_alloc we can't insert the alloced page to env_pgdir.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>注 : 关于<code>envid2env中的checkperm参数</code> : </p>
<ol>
<li><p>当为0时不影响</p>
<ol start="2">
<li>当为1是要求查询的进程<strong>为当前进程或者当前进程的直接子进程</strong></li>
</ol>
</li>
<li><p><code>int sys_mem_map(int sysno, u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</code> : </p>
<ul>
<li><p>函数作用 : 在目标进程<code>dstid</code>的页表结构中以<code>perm</code>的权限建设从虚拟页<code>dstva</code>到源进程<code>srcid</code>中<code>srcva</code>对应的物理页的页表映射结构</p>
</li>
<li><p>具体实现 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_mem_map</span><span class="params">(<span class="keyword">int</span> sysno, u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	u_int round_srcva, round_dstva;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srcenv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">dstenv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">ppage</span>;</span></span><br><span class="line">	Pte *ppte;</span><br><span class="line">	ppage = <span class="literal">NULL</span>;</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">	round_srcva = ROUNDDOWN(srcva, BY2PG);</span><br><span class="line">	round_dstva = ROUNDDOWN(dstva, BY2PG);</span><br><span class="line">    <span class="comment">//检查地址是否合法</span></span><br><span class="line">	<span class="keyword">if</span>(srcva&gt;=UTOP || dstva&gt;=UTOP || srcva&lt;<span class="number">0</span> || dstva&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,srcva:%x and dstva:%x must &lt;UTOP(%x).\n"</span>,srcva,dstva,UTOP);</span><br><span class="line">		<span class="keyword">return</span> -E_UNSPECIFIED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//检查权限位是否合法</span></span><br><span class="line">	<span class="keyword">if</span>(!(perm &amp; PTE_V))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_mem_map perm is illegal.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获得进程控制结构</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(srcid,&amp;srcenv,<span class="number">0</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,we can't get srcenv!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(envid2env(dstid,&amp;dstenv,<span class="number">0</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,we can't get dstenv!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//从srcenv中获取要映射的物理页</span></span><br><span class="line">	<span class="keyword">if</span>((ppage=page_lookup(srcenv-&gt;env_pgdir,round_srcva,&amp;ppte))==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,we found srcenv not exist page at %x.\n"</span>,round_srcva);</span><br><span class="line">		<span class="keyword">return</span> -E_UNSPECIFIED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在dstenv中建立页表映射关系</span></span><br><span class="line">	<span class="keyword">if</span>(page_insert(dstenv-&gt;env_pgdir,ppage,round_dstva,perm)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_mem_map can't insert src page to dst page.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>int sys_mem_unmap(int sysno, u_int envid, u_int va)</code> : </p>
<ul>
<li><p>函数作用 : 在进程<code>envid</code>的页表结构中去掉<code>va</code>虚拟页的映射结构</p>
</li>
<li><p>具体实现 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_mem_unmap</span><span class="params">(<span class="keyword">int</span> sysno, u_int envid, u_int va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(va&gt;=UTOP)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_mem_unmap va:%x &gt;=UTOP %x.\n"</span>,va,UTOP);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid,&amp;env,PTE_V)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_mem_unmap we can't get env.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	page_remove(env-&gt;env_pgdir,va);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>int sys_env_alloc(void)</code> : 这个函数与一般概念上的建立进程不同</p>
<ul>
<li><p>函数作用 : <strong>以当前进程作为父进程, 以父进程为模板创建一个高度相似的子进程</strong></p>
</li>
<li><p>具体实现 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_env_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="comment">//分配进程控制块</span></span><br><span class="line">	<span class="keyword">if</span>(env_alloc(&amp;e,curenv-&gt;env_id)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,because unable allocate a env,fork failed.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">	e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    e-&gt;env_pri = curenv-&gt;env_pri;</span><br><span class="line">    <span class="comment">//插入调度链表</span></span><br><span class="line">    LIST_INSERT(&amp;env_sched_list[<span class="number">0</span>], e, env_sched_link);</span><br><span class="line">    <span class="comment">//将父进程的环境拷贝一份给子进程</span></span><br><span class="line">	bcopy(KERNEL_SP-<span class="keyword">sizeof</span>(struct Trapframe),&amp;(e-&gt;env_tf),<span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">    <span class="comment">//之后这两条语句很重要,详见下文</span></span><br><span class="line">	e-&gt;env_tf.pc = e-&gt;env_tf.cp0_epc;</span><br><span class="line">	e-&gt;env_tf.regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><strong>注 : 这个函数其实东西比较多 : </strong></p>
<ul>
<li><p><code>e-&gt;env_tf.pc = e-&gt;env_tf.cp0_epc</code></p>
<p><strong>即子进程下一次被调度运行是从父进程创建子进程的系统调用后一条语句开始的</strong></p>
<ol>
<li><p><code>e-&gt;env_tf.cp0_epc</code>是由<strong>父进程拷贝过来</strong>,所以该数据保存的是<strong>父进程调用该系统调用创建子进程时的中断语句</strong></p>
</li>
<li><p><code>e-&gt;env_tf.pc</code>是<strong>子进程下一次开始运行的语句</strong></p>
</li>
</ol>
</li>
<li><p><strong><code>e-&gt;env_tf.regs[2] = 0</code></strong> : <strong>这句话很重要,它是<code>fork</code>机制父子进程返回值不同的基础</strong></p>
<ol>
<li><code>e-&gt;env_tf.regs[2]</code>中保存的是<strong>子进程保护现场中的返回值<code>v0</code>寄存器值,本来应该存储的是父进程的返回值(其实就是子进程的<code>env_id</code>)</strong></li>
<li><strong>将其值人为的赋值为0即可实现在调用子进程恢复现场时使得返回值为0,即实现<code>fork</code>函数子进程返回0,父进程返回子进程<code>id</code></strong></li>
</ol>
</li>
</ul>
<h2 id="缺页中断处理"><a href="#缺页中断处理" class="headerlink" title="缺页中断处理"></a>缺页中断处理</h2><h3 id="一般缺页中断"><a href="#一般缺页中断" class="headerlink" title="一般缺页中断"></a>一般缺页中断</h3><h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><ol>
<li><strong>硬件工作</strong> : <code>CPU</code>根据虚拟地址查<code>tlb</code>时<code>tlb</code>无效,触发异常,记录缺页异常类型,跳转到异常分发代码</li>
<li><strong>软件工作</strong> : <ol>
<li>异常分发代码判断为缺页异常跳转到<code>handle_tlb</code>异常处理代码</li>
<li>该异常处理代码的作用仅是跳转到<code>do_refill</code>函数</li>
<li>在该函数中具体判断是<strong><code>tlb</code>缺失但页表映射的物理页面存在还是物理页面都不存在</strong><ul>
<li><code>tlb</code>缺失但是物理页面存在进行<code>tlb</code>重填,即<code>tlbwr</code>函数</li>
<li>物理页面不存在进行页表项填写,即<code>pageout</code>函数</li>
</ul>
</li>
<li>异常处理完之后返回,继续运行</li>
</ol>
</li>
</ol>
<h4 id="代码细节-1"><a href="#代码细节-1" class="headerlink" title="代码细节"></a>代码细节</h4><ol>
<li><code>handle_tlb &amp; do_refill</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数的作用是根据CP0状态跳转到TLB重填代码或者页表重填代码</span></span><br><span class="line">NESTED(do_refill,<span class="number">0</span> , sp)</span><br><span class="line">	.<span class="keyword">extern</span>	mCONTEXT</span><br><span class="line"><span class="number">1</span>:			</span><br><span class="line">	nop</span><br><span class="line">	lw		k1,mCONTEXT</span><br><span class="line">	<span class="keyword">and</span>		k1,<span class="number">0xfffff000</span></span><br><span class="line">	mfc0	k0,CP0_BADVADDR	<span class="comment">//CP0_BADVADDR中存储的是导致缺页中断的虚拟地址</span></span><br><span class="line">	srl		k0,<span class="number">20</span></span><br><span class="line">	<span class="keyword">and</span>		k0,<span class="number">0xfffffffc</span></span><br><span class="line">	addu	k0,k1</span><br><span class="line">	lw		k1,<span class="number">0</span>(k0)</span><br><span class="line">	nop</span><br><span class="line">	move	t0,k1</span><br><span class="line">	<span class="keyword">and</span>		t0,<span class="number">0x0200</span></span><br><span class="line">	beqz	t0,NOPAGE</span><br><span class="line">	nop</span><br><span class="line">	<span class="keyword">and</span>		k1,<span class="number">0xfffff000</span></span><br><span class="line">	mfc0	k0,CP0_BADVADDR</span><br><span class="line">	srl		k0,<span class="number">10</span></span><br><span class="line">	<span class="keyword">and</span>		k0,<span class="number">0xfffffffc</span></span><br><span class="line">	<span class="keyword">and</span>		k0,<span class="number">0x00000fff</span></span><br><span class="line">	addu	k0,k1</span><br><span class="line">	<span class="keyword">or</span>		k0,<span class="number">0x80000000</span></span><br><span class="line">	lw		k1,<span class="number">0</span>(k0)</span><br><span class="line">	nop</span><br><span class="line">	move	t0,k1</span><br><span class="line">	<span class="keyword">and</span>		t0,<span class="number">0x0200</span></span><br><span class="line">	beqz	t0,NOPAGE</span><br><span class="line">	nop</span><br><span class="line">	move	k0,k1</span><br><span class="line">	<span class="keyword">and</span>		k0,<span class="number">0x1</span></span><br><span class="line">	beqz	k0,NoCOW</span><br><span class="line">	nop</span><br><span class="line">	<span class="keyword">and</span>		k1,<span class="number">0xfffffbff</span></span><br><span class="line">NoCOW:</span><br><span class="line">	mtc0	k1,CP0_ENTRYLO0</span><br><span class="line">	nop</span><br><span class="line">	tlbwr	<span class="comment">//tlb重写填写</span></span><br><span class="line">	j		<span class="number">2f</span></span><br><span class="line">	nop</span><br><span class="line">NOPAGE:</span><br><span class="line">	nop</span><br><span class="line">	mfc0	a0,CP0_BADVADDR</span><br><span class="line">	lw		a1,mCONTEXT</span><br><span class="line">	nop</span><br><span class="line">	sw	 	ra,tlbra</span><br><span class="line">	jal		pageout	<span class="comment">//缺页处理页表项重填</span></span><br><span class="line">	nop</span><br><span class="line">	nop</span><br><span class="line">	lw		ra,tlbra</span><br><span class="line">	nop</span><br><span class="line">	j	<span class="number">1b</span></span><br><span class="line"><span class="number">2</span>:	nop</span><br><span class="line">	jr		ra</span><br><span class="line">	nop</span><br><span class="line">END(do_refill)</span><br><span class="line">    </span><br><span class="line">BUILD_HANDLER tlb	do_refill	cli	   <span class="comment">//宏定义定义全局函数handle_tlb,作用仅为跳转到do_refill</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>pageout</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mm/pmap.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pageout</span><span class="params">(<span class="keyword">int</span> va, <span class="keyword">int</span> context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_long r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (context &lt; <span class="number">0x80000000</span>) &#123;</span><br><span class="line">        panic(<span class="string">"tlb refill and alloc error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((va &gt; <span class="number">0x7f400000</span>) &amp;&amp; (va &lt; <span class="number">0x7f800000</span>)) &#123;</span><br><span class="line">        panic(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;it's env's zone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (va &lt; <span class="number">0x10000</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"current env id is:%d,va:%x,context:%x\n"</span>,curenv-&gt;env_id,va,context);</span><br><span class="line">        panic(<span class="string">"^^^^^^TOO LOW^^^^^^^^^"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = page_alloc(&amp;p)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic (<span class="string">"page alloc error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//p-&gt;pp_ref++; 讲道理我觉得这不能有,因为insert中进行了ref++,但这代码不是我写的,我又能怎么办呢	</span></span><br><span class="line">    page_insert((Pde *)context, p, VA2PFN(va), PTE_R);	<span class="comment">//页表项填写</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pageout:\t@@@___0x%x___@@@  ins a page \n"</span>, va);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写时复制导致的缺页中断"><a href="#写时复制导致的缺页中断" class="headerlink" title="写时复制导致的缺页中断"></a>写时复制导致的缺页中断</h3><h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><p>父子进程共享物理内存是有前提条件的 : <strong>共享的物理内存不会被任一进程修改</strong>,当父子进程中有修改共享内存内存（一般是数据段,<strong>标志是用<code>COW</code>保护</strong>）的行为发生时,就会触发一个缺页异常,内核捕获这种缺页中断后,再为发生内存修改的进程相应的地址分配物理页面.</p>
<h4 id="处理流程-1"><a href="#处理流程-1" class="headerlink" title="处理流程"></a>处理流程</h4><ol>
<li><strong>硬件工作</strong> : <code>CPU</code>根据虚拟地址查页表时发现物理地址被<code>COW</code>位保护,触发异常,记录缺页异常类型,跳转到异常分发代码</li>
<li><strong>软件工作</strong> : <ol>
<li>异常分发代码判断为缺页异常,跳转到写时复制缺页异常处理代码</li>
<li><strong>在微内核的设计当中内核不做具体的处理,具体的缺页重填代码在用户态实现</strong></li>
<li>用户态分配物理页,建立映射机制</li>
<li>异常中断返回,重新访问该地址,程序继续运行</li>
</ol>
</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="缺页异常处理-内核中"><a href="#缺页异常处理-内核中" class="headerlink" title="缺页异常处理(内核中)"></a>缺页异常处理(内核中)</h5><ol>
<li><p><strong>缺页异常的处理被分发到<code>handle_mod</code>函数处理</strong>(具体的跳转流程详见异常类型注册表与异常分发程序)</p>
<p>这个<code>handle_mod</code>函数藏得很深,使用汇编宏定义来定义</p>
<p>在这个函数中实际上<strong>保存现场关闭中断</strong>之后跳转到实际处理函数<code>page_fault_handler</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/genex.S</span></span><br><span class="line"><span class="comment">//定义全局的异常处理程序的宏定义</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * exception为异常的类型(tlb/mod),函数名为handle_\exception(对应异常类型注册表中的handle_tlb,handle_mod)</span></span><br><span class="line"><span class="comment"> * handler为实际处理该异常的函数,即在该程序内部要跳转到的程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">.macro	BUILD_HANDLER exception handler clear</span><br><span class="line">	.align	<span class="number">5</span></span><br><span class="line">	NESTED(handle_\exception, TF_SIZE, sp)  </span><br><span class="line">	nop</span><br><span class="line">	SAVE_ALL				</span><br><span class="line">	__build_clear_\clear</span><br><span class="line">	.<span class="built_in">set</span>	at</span><br><span class="line">	move	a0, sp</span><br><span class="line">	jal	\handler</span><br><span class="line">	nop</span><br><span class="line">	j	ret_from_exception</span><br><span class="line">	nop</span><br><span class="line">	END(handle_\exception)</span><br><span class="line">.endm</span><br><span class="line">BUILD_HANDLER reserved do_reserved cli	<span class="comment">//定义全局函数handle_resereverd</span></span><br><span class="line">BUILD_HANDLER mod	page_fault_handler cli	<span class="comment">//定义全局函数hanle_mod,在函数中跳转到page_fault_handler中去</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>page_fault_handler</code>函数 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/trap.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">page_fault_handler</span><span class="params">(struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"><span class="comment">//tf参数时在调用放在$a0中,即当前的栈指针,当中保存着运行现场,为一个struct Trapframe结构体大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_int va;</span><br><span class="line">    u_int *tos, d;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">PgTrapFrame</span>;</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">curenv</span>;</span></span><br><span class="line">	bcopy(tf, &amp;PgTrapFrame,<span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">    <span class="comment">//之后这个判断语句主要是为了支持异常处理的重入</span></span><br><span class="line">	<span class="keyword">if</span>(tf-&gt;regs[<span class="number">29</span>] &gt;= (curenv-&gt;env_xstacktop - BY2PG) &amp;&amp; tf-&gt;regs[<span class="number">29</span>] &lt;= (curenv-&gt;env_xstacktop - <span class="number">1</span>))</span><br><span class="line">	&#123;	<span class="comment">//在处理缺页异常时又出现异常</span></span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] = tf-&gt;regs[<span class="number">29</span>] - <span class="keyword">sizeof</span>(struct  Trapframe);</span><br><span class="line">		bcopy(&amp;PgTrapFrame, tf-&gt;regs[<span class="number">29</span>], <span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	<span class="comment">//正常运行中第一次触发缺页异常</span></span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] = curenv-&gt;env_xstacktop - <span class="keyword">sizeof</span>(struct  Trapframe);</span><br><span class="line">		bcopy(&amp;PgTrapFrame, curenv-&gt;env_xstacktop - <span class="keyword">sizeof</span>(struct  Trapframe), <span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//设置重新开始运行的代码为处理缺页异常的</span></span><br><span class="line">	tf-&gt;cp0_epc = curenv-&gt;env_pgfault_handler;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>有关缺页异常处理的重入机制</strong></p>
<p>主要表现在<strong>栈顶指针的设置</strong>上</p>
<ol>
<li><p>正常的程序运行中出现缺页异常对应程序中<code>else</code>情况</p>
<p>此时<strong><code>tf</code>中保存的栈顶指针(即<code>tf-&gt;regs[29]</code>)应该是在<code>USTACKTOP</code>之下,即<code>normal user stack</code>区域</strong></p>
<p>在该情况下要进入缺页异常处理应该<strong>设置栈顶指针为异常处理栈指针</strong>,即<code>tf-&gt;regs[29] = curenv-&gt;env_xstacktop - sizeof(struct  Trapframe)</code></p>
</li>
<li><p>在缺页异常处过程中触发缺页异常对应程序中<code>if</code>情况</p>
<p>此时<strong><code>tf</code>中保存的栈顶指针(即<code>tf-&gt;regs[29]</code>)应该是在<code>UXSTACKTOP</code>之下,即<code>user exception stack</code>区域</strong></p>
<p>在该情况下要进入缺页异常处理应该<strong>将异常处理栈的栈指针下移即可</strong>,即<code>tf-&gt;regs[29] = tf-&gt;regs[29] - sizeof(struct  Trapframe)</code></p>
</li>
</ol>
</li>
<li><p><strong>很奇怪的一点就是这个异常处理函数处理分配异常处理栈区保存现场之外什么也没有做,真正的缺重填在哪?安装微内核设计的原则应该在用户态,但是又是怎么跳转到那里的呢?</strong></p>
<p>关键就在于<strong><code>tf-&gt;cp0_epc = curenv-&gt;env_pgfault_handler</code>, 每个进程控制块中有一项<code>env_pgfault_handler</code>该项中保存的就是请求异常处理程序的入口,通过将其设置为<code>epc</code>实现在异常处理完成恢复现场时设置重新开始运行的地方就是处理缺页异常的代码</strong></p>
</li>
</ul>
</li>
</ol>
<h5 id="缺页异常处理程序注册-用户中"><a href="#缺页异常处理程序注册-用户中" class="headerlink" title="缺页异常处理程序注册(用户中)"></a>缺页异常处理程序注册(用户中)</h5><p>由上文知我们需要 :</p>
<ul>
<li><strong>一段所有进程公用的缺页异常处理代码</strong></li>
<li>在进程建立时<strong>进行缺页异常处理程序入口的注册,即将函数入口地址赋值给<code>env-&gt;env_pgfault_handler</code></strong></li>
</ul>
<p><strong>所以<code>env_pgfault_handler</code>才是真正的处理函数</strong></p>
<p>具体流程如下 :</p>
<ol>
<li><p>在<code>fork</code>中创建子进程时调用<code>set_pgfault_handler(pgfault)</code>注册异常处理程序</p>
</li>
<li><p><code>set_pgfault_handler()</code> :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/pgfault.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_pgfault_handler</span><span class="params">(<span class="keyword">void</span> (*fn)(u_int va, u_int err))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;	</span><br><span class="line">	<span class="keyword">if</span> (__pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_alloc(<span class="number">0</span>, UXSTACKTOP - BY2PG, PTE_V|PTE_R)&lt;<span class="number">0</span> || syscall_set_pgfault_handler(<span class="number">0</span>, __asm_pgfault_handler, UXSTACKTOP)&lt;<span class="number">0</span>)</span><br><span class="line"> <span class="comment">//为异常处理分配所需的栈并且完成异常处理注册</span></span><br><span class="line">		&#123;</span><br><span class="line">			writef(<span class="string">"cannot set pgfault handler\n"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	__pgfault_handler = fn;	<span class="comment">//fn即传入的函数指针指向pgfault()函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述函数将<code>__pgfault_handler</code>的值设为<code>pafault()</code>(<strong>真正深藏不露的缺页异常处理函数</strong>)的入口地址 :</p>
<p><strong>该函数将<code>COW</code>保护的物理页复制一份并在当前进程建立映射,这要父子进程的修改就互不相干了</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/fork.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pgfault</span><span class="params">(u_int va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int temp = UTOP - <span class="number">2</span> * BY2PG;	<span class="comment">//临时使用的一个虚拟地址(使用invaild区域作为临时使用)</span></span><br><span class="line">	va = ROUNDDOWN(va,BY2PG);	<span class="comment">//要复制的目标对应的虚拟地址</span></span><br><span class="line">	u_int perm = (*vpt)[VPN(va)]&amp; <span class="number">0xfff</span>;</span><br><span class="line">	<span class="keyword">if</span>(perm &amp; PTE_COW)&#123;</span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_alloc(<span class="number">0</span>,temp,perm &amp;(~PTE_COW))&lt;<span class="number">0</span>)&#123; <span class="comment">//为临时虚拟地址temp分配一个物理页</span></span><br><span class="line">			user_panic(<span class="string">"syscall_mem_alloc error.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		user_bcopy((<span class="keyword">void</span> *)va,(<span class="keyword">void</span> *)temp,BY2PG);<span class="comment">//将va对应物理页中数据复制到temp对应的物理页中</span></span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_map(<span class="number">0</span>,temp,<span class="number">0</span>,va,perm &amp;(~PTE_COW))&lt;<span class="number">0</span>)&#123;<span class="comment">//修改va映射的物理页为temp映射的物理页</span></span><br><span class="line">			user_panic(<span class="string">"syscall_mem_map error.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_unmap(<span class="number">0</span>,temp)&lt;<span class="number">0</span>)&#123;<span class="comment">//解除临时虚拟地址temp的映射关系</span></span><br><span class="line">			user_panic(<span class="string">"syscall_mem_unmap error.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		user_panic(<span class="string">"va page is not PTE_COW.\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述函数调用了<code>syscall_set_pgfault_handler</code>,这是一个系统调用,其对应的内核中的功能代码如下 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/syscall_all.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_set_pgfault_handler</span><span class="params">(<span class="keyword">int</span> sysno, u_int envid, u_int func, u_int xstacktop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid,&amp;env,PTE_V)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_set_pgfault_handler we can't get env by envid.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	env-&gt;env_pgfault_handler = func;	<span class="comment">//设置真正的处理缺页异常的代码</span></span><br><span class="line">	env-&gt;env_xstacktop = xstacktop;		<span class="comment">//设置异常处理栈</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由上述代码我们知道真正的异常处理函数(即<code>env_pgfault_handler</code>)应该是<strong><code>__asm_pgfault_handler</code></strong> (其实里面还是通过调用<code>pgfault</code>实现 ) :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/entry.S</span></span><br><span class="line">__asm_pgfault_handler:</span><br><span class="line">nop</span><br><span class="line">	lw	a0, TF_BADVADDR(sp)</span><br><span class="line">	lw	t1, __pgfault_handler	<span class="comment">//这个函数就是pgfault()</span></span><br><span class="line">	jalr	t1</span><br><span class="line"></span><br><span class="line">nop</span><br><span class="line"><span class="comment">//异常处理结束,恢复现场</span></span><br><span class="line">	lw	v1,TF_LO(sp)                                       </span><br><span class="line">		mtlo	v1                               </span><br><span class="line">		lw	v0,TF_HI(sp)                                         </span><br><span class="line">		lw	v1,TF_EPC(sp)                    </span><br><span class="line">		mthi	v0                               </span><br><span class="line">		mtc0	v1,CP0_EPC                                             </span><br><span class="line">		lw	$<span class="number">31</span>,TF_REG31(sp)                 </span><br><span class="line">		........</span><br><span class="line">		lw	$<span class="number">1</span>,TF_REG1(sp) </span><br><span class="line">		lw	k0,TF_EPC(sp) 	</span><br><span class="line">		jr	k0			</span><br><span class="line">		lw	sp,TF_REG29(sp)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="流程图示-1"><a href="#流程图示-1" class="headerlink" title="流程图示"></a>流程图示</h4><p><img src="/2019/05/03/OS-lab4/cow.png" alt></p>
<h2 id="fork实现"><a href="#fork实现" class="headerlink" title="fork实现"></a>fork实现</h2><h3 id="fork的功能"><a href="#fork的功能" class="headerlink" title="fork的功能"></a>fork的功能</h3><ol>
<li>以父进程为模板创建一个高度相似的子进程</li>
<li>要求父子进程中<code>fork</code>函数的返回值不同<ul>
<li>在父进程中返回子进程的<code>envid</code></li>
<li>在子进程中返回0</li>
</ul>
</li>
</ol>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/entry.S</span></span><br><span class="line">vpt:</span><br><span class="line">	.word UVPT</span><br><span class="line">vpd:</span><br><span class="line">	.word (UVPT+(UVPT&gt;&gt;<span class="number">12</span>)*<span class="number">4</span>)</span><br><span class="line"><span class="comment">//user/fork.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int newenvid;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">envs</span>;</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span><span class="comment">//将其指向当前的进程，如果子进程无法创建，则指向父进程</span></span><br><span class="line">	u_int i;</span><br><span class="line">	<span class="comment">//设置缺页中断处理</span></span><br><span class="line">	set_pgfault_handler(pgfault);	</span><br><span class="line">	<span class="keyword">if</span>((newenvid = syscall_env_alloc())==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//在syscall中直接设置子进程保存现场中的返回值为0,所以实现返回值不同</span></span><br><span class="line">        <span class="comment">//即当前是子进程运行的话直接进入该分支返回</span></span><br><span class="line">		env = &amp;envs[ENVX(syscall_getenvid())];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	我们只需要将父进程中相关的用户空间的页复制到子进程用户空间即可</span></span><br><span class="line"><span class="comment">	所谓的复制实际上只是建立映射到同一物理地址的映射而已,物理数据只有一份</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	注意创建一个进程的时候会调用env_vm_init函数，这个函数中以内核页表为模板建立UTOP以上的映射,所以我们创建子进程，复制父进程的地址空间只需要复制UTOP以下的页即可</span></span><br><span class="line"><span class="comment">	(很重要!!! : 注意这里不包括异常处理栈以及invaild区域这两页)，</span></span><br><span class="line"><span class="comment">	因为所有进程UTOP以上的页都是利用boot_pgdir作为模板复制的，不需要再次复制拷贝</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">    这里的(*vpd/t)[]的用法就相当于数组下标的用法</span></span><br><span class="line"><span class="comment">    (*vpd)[i]为第i个页目录项</span></span><br><span class="line"><span class="comment">    (*vpt)[i]为第i个页表项</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    下面的保护页表设置进行了一些优化,减少了循环次数</span></span><br><span class="line"><span class="comment">    先进行页目录项的有效性,若无效则直接跳过一个页目录的页大小(1024 * BY2PG)</span></span><br><span class="line"><span class="comment">    页目录有效才进行对一页页表的遍历</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; UTOP - <span class="number">2</span> * BY2PG) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((*vpd)[VPN(i)/<span class="number">1024</span>] &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">            i += <span class="number">1024</span> * BY2PG;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (((*vpt)[VPN(i)] &amp; PTE_V) ==<span class="number">0</span> ) &#123;</span><br><span class="line">        	i += BY2PG;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        duppage(newenvid,VPN(i));</span><br><span class="line">        i += BY2PG;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//搭建异常处理栈，分配一个页，让别的进程不抢占此页</span></span><br><span class="line">	<span class="keyword">if</span>(syscall_mem_alloc(newenvid,UXSTACKTOP-BY2PG,PTE_V|PTE_R)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		user_panic(<span class="string">"failed alloc UXSTACK.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//帮助子进程注册错误处理函数</span></span><br><span class="line">	<span class="keyword">if</span>(syscall_set_pgfault_handler(newenvid,__asm_pgfault_handler,UXSTACKTOP)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		user_panic(<span class="string">"page fault handler setup failed.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//至此子进程可以进行调度运行了</span></span><br><span class="line">	syscall_set_env_status(newenvid,ENV_RUNNABLE);</span><br><span class="line">	writef(<span class="string">"OK! newenvid is:%d\n"</span>,newenvid);</span><br><span class="line">	<span class="keyword">return</span> newenvid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>duppage</code>函数 :</p>
<p>该函数作用 : </p>
<ul>
<li>建立子进程中到共享物理页的映射</li>
<li>将可写入的共享区域的页用<code>COW</code>的权限位保护起来</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/fork.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">duppage</span><span class="params">(u_int envid, u_int pn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int perm;</span><br><span class="line">	perm = (*vpt)[pn] &amp; <span class="number">0xfff</span>; <span class="comment">//取出标记位</span></span><br><span class="line">	<span class="keyword">if</span>((((perm &amp; PTE_R) !=<span class="number">0</span>) || ((perm &amp; PTE_COW)!=<span class="number">0</span>)) &amp;&amp; (perm &amp; PTE_V))&#123;</span><br><span class="line">		<span class="keyword">if</span>(perm &amp; PTE_LIBRARY)&#123;</span><br><span class="line">			perm = PTE_V | PTE_R | PTE_LIBRARY;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			perm = PTE_V | PTE_R | PTE_COW;</span><br><span class="line">		&#125;</span><br><span class="line">       	<span class="comment">//以保护权限建立子进程到共享物理页的映射</span></span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_map(<span class="number">0</span>,pn*BY2PG,envid,pn*BY2PG,perm)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			user_panic(<span class="string">"syscall_mem_map for son failed.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//在父进程中对共享物理页做权限保护</span></span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_map(<span class="number">0</span>,pn*BY2PG,<span class="number">0</span>,pn*BY2PG,perm)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			user_panic(<span class="string">"syscall_mem_map for father failed.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_map(<span class="number">0</span>,pn*BY2PG,envid,pn*BY2PG,perm)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			user_panic(<span class="string">"syscall_mem_map for son failed.1\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fork图示"><a href="#fork图示" class="headerlink" title="fork图示"></a>fork图示</h3><p><img src="/2019/05/03/OS-lab4/fork.png" alt></p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过所有进程共享的内核空间中的进程控制块结构<code>envs[]</code>来实现不同进程之间的传递数据(即通信)</p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><ol>
<li><p><code>env</code>控制块中的对应该功能的数据域</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/env.h</span></span><br><span class="line">    u_int env_ipc_value;            <span class="comment">// 进程间要传递的数据</span></span><br><span class="line">	u_int env_ipc_from;             <span class="comment">// 发送信息到该进程的源进程</span></span><br><span class="line">	u_int env_ipc_recving;          <span class="comment">// 为1表示该进程在等待接受信息状态</span></span><br><span class="line">	u_int env_ipc_dstva;		   <span class="comment">// 该进程进程间的共享物理页面映射到的虚拟地址</span></span><br><span class="line">	u_int env_ipc_perm;			   <span class="comment">// 建立映射的权限位</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接受信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/syscall_all.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_ipc_recv</span><span class="params">(<span class="keyword">int</span> sysno, u_int dstva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//检查地址有效性</span></span><br><span class="line">	<span class="keyword">if</span>(dstva&gt;=UTOP)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_ipc_recv the dstva %x need &lt; UTOP %x\n"</span>,dstva,UTOP);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	curenv-&gt;env_ipc_recving = <span class="number">1</span>;	<span class="comment">//设置该进程未等待接受信息状态</span></span><br><span class="line">	curenv-&gt;env_ipc_dstva = dstva;	<span class="comment">//设置将共享共享物理页映射到的虚拟地址</span></span><br><span class="line">	curenv-&gt;env_status = ENV_NOT_RUNNABLE;	<span class="comment">//阻塞该进程,等待接受信息之后才能继续运行</span></span><br><span class="line">	sys_yield();	<span class="comment">//调度其他进程给该进程发送信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/syscall_all.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_ipc_can_send</span><span class="params">(<span class="keyword">int</span> sysno, u_int envid, u_int value, u_int srcva, u_int perm)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 参数含义 :</span></span></span><br><span class="line"><span class="function"><span class="comment">   1. envid为要发送信息的目标进程的进程号</span></span></span><br><span class="line"><span class="function"><span class="comment">   2. value为要传递的数据信息</span></span></span><br><span class="line"><span class="function"><span class="comment">   3. srcva为要共享的物理页在该进程(发送进程)中映射到的虚拟地址</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">	Pte *ppte;</span><br><span class="line">	<span class="keyword">if</span>(srcva&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"in sys_ipc_can_send found va is 0\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(srcva&gt;=UTOP)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_ipc_can_send srcva %x need &lt;UTOP %x.\n"</span>,srcva,UTOP);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid,&amp;e,<span class="number">0</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_ipc_can_send the envid can't found the env.envid is:%d\n"</span>,envid);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(e-&gt;env_ipc_recving==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_ipc_can_send we found env_ipc_recving is 0.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((p=page_lookup(curenv-&gt;env_pgdir,srcva,<span class="number">0</span>))&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"send srcva is not exist.srcva is:%x\n"</span>,srcva);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(page_insert(e-&gt;env_pgdir,p,e-&gt;env_ipc_dstva,perm)&lt;<span class="number">0</span>)&#123; <span class="comment">//建立目标进程中共享物理页面的映射</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"dst pot failed.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	e-&gt;env_ipc_perm = perm|PTE_V|PTE_R;</span><br><span class="line">	e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">	e-&gt;env_status = ENV_RUNNABLE;	<span class="comment">//目标进程接受到信息,可以继续运行</span></span><br><span class="line">	e-&gt;env_ipc_value = value;		<span class="comment">//写入要传递的数据</span></span><br><span class="line">	e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="通信图示"><a href="#通信图示" class="headerlink" title="通信图示"></a>通信图示</h3><p><img src="/2019/05/03/OS-lab4/ipc.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/13/OS-lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/13/OS-lab3/" itemprop="url">OS-lab3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-13T08:02:53+08:00">
                2019-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="env进程结构管理"><a href="#env进程结构管理" class="headerlink" title="env进程结构管理"></a>env进程结构管理</h1><p>先给大家安利一个神器：<code>Understand</code>，有了它，妈妈再也不担心我源码看吐了</p>
<p>首先神图镇楼</p>
<p><img src="/2019/04/13/OS-lab3/mm.png" alt></p>
<h2 id="一点与lab3无关的"><a href="#一点与lab3无关的" class="headerlink" title="一点与lab3无关的"></a>一点与lab3无关的</h2><p><strong>在刚开始时，我个人一直疑惑的一个问题便是什么是OS的工作，而什么是硬件支持的工作，这个问题其实我现在还不是很清楚，下面写一点我的拙见：</strong></p>
<ol>
<li><p>关于地址：</p>
<ul>
<li>页表项的填写是要操作系统来负责的，即在代码中显式填写</li>
<li>在代码中给一个虚拟地址来访问数据是由硬件支持的，并且他可以判断在<code>ULIM</code>上硬件就直接最高位置0然后访问，如果在下面就通过页表查找访问</li>
</ul>
<p><strong>这就解释了我们许多地方的地址变化看似功能上不是内核中的事，但是我们的虚拟地址都是用内核中才满足的转换函数，其实我个人认为就是由于我们页表结构还没填好所以暂时建立一个映射而已，其作用只是一个访问的作用而已，等利用他把页表建立好它也就没用了</strong></p>
</li>
<li><p>关于中断：</p>
<ul>
<li>在时间片用完之后硬件产生时间中断，跳转PC值</li>
<li>操作系统要负责记录当前进程的上下文，并且构建将要调度执行的进程的上下文（其实还要设置一大堆CPU的状态寄存器）</li>
</ul>
</li>
<li><p>……..</p>
</li>
</ol>
<h2 id="基本常数定义"><a href="#基本常数定义" class="headerlink" title="基本常数定义"></a>基本常数定义</h2><h3 id="最大进程数目"><a href="#最大进程数目" class="headerlink" title="最大进程数目"></a>最大进程数目</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG2NENV	10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NENV		(1&lt;&lt;LOG2NENV)</span></span><br></pre></td></tr></table></figure>
<p>即最多有2^10即1024个进程</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENV_FREE	0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENV_RUNNABLE		1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENV_NOT_RUNNABLE	2</span></span><br></pre></td></tr></table></figure>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><h3 id="env进程管理块"><a href="#env进程管理块" class="headerlink" title="env进程管理块"></a>env进程管理块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span> 	   <span class="comment">// 保存进程切换前后的寄存器值（即所谓的保存上下文）</span></span><br><span class="line">	LIST_ENTRY(Env) env_link;	   <span class="comment">// 在空闲进程队列env_free_list中链接下一项的指针</span></span><br><span class="line">	u_int env_id;                  <span class="comment">// 进程id号（每个进程的唯一标识）</span></span><br><span class="line">	u_int env_parent_id;           <span class="comment">// 父进程的id号 </span></span><br><span class="line">	u_int env_status;              <span class="comment">// 进程的状态</span></span><br><span class="line">	Pde  *env_pgdir;               <span class="comment">// 进程的页目录的内核中的起始虚拟地址 </span></span><br><span class="line">	u_int env_cr3;				  <span class="comment">// 进程的页目录的起始物理地址（即cr3寄存器中存储的值）</span></span><br><span class="line">	LIST_ENTRY(Env) env_sched_link;<span class="comment">// 在调度队列env_sched_list中链接下一项的指针</span></span><br><span class="line">	u_int env_pri;				  <span class="comment">// 进程的优先级，定义为进程可用的时间片个数</span></span><br><span class="line">    <span class="comment">// 之后的lab4再补充以下结构</span></span><br><span class="line">	u_int env_ipc_value;           </span><br><span class="line">	u_int env_ipc_from;           </span><br><span class="line">	u_int env_ipc_recving;        </span><br><span class="line">	u_int env_ipc_dstva;		</span><br><span class="line">	u_int env_ipc_perm;		</span><br><span class="line">	u_int env_pgfault_handler;    </span><br><span class="line">	u_int env_xstacktop;          </span><br><span class="line">	u_int env_runs;		</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">// 数据结构展开</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span> </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> regs[<span class="number">32</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cp0_status;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> hi;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> lo;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cp0_badvaddr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cp0_cause;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cp0_epc;	<span class="comment">//中断异常时执行的指令地址</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pc;		<span class="comment">//在进程切换回来时应该开始执行的地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_ENTRY(type)						\</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>								\</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">le_next</span>;</span>	<span class="comment">/* next element */</span>			\</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">type</span> **<span class="title">le_prev</span>;</span>	<span class="comment">/* address of previous next element */</span>	\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="env-free-list"><a href="#env-free-list" class="headerlink" title="env_free_list"></a>env_free_list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env_list</span> <span class="title">env_free_list</span>;</span></span><br></pre></td></tr></table></figure>
<p>该结构的作用将<strong>待分配</strong>的空闲<code>env</code>控制块串成链表形式，该链表中的<code>env</code>控制块都是<strong><code>ENV_FREE</code>状态</strong></p>
<h3 id="env-sched-list"><a href="#env-sched-list" class="headerlink" title="env_sched_list"></a>env_sched_list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env_list</span> <span class="title">env_sched_list</span>[2];</span></span><br></pre></td></tr></table></figure>
<p>该结构的作用是将已经处于<strong>可运行状态</strong>的<code>env</code>控制块串成链表形式以便调度程序来调度运行（<strong>本质上就是分配给时间片</strong>），该链表中的<code>env</code>控制块都是<strong><code>ENV_RUNNABLE</code>状态</strong></p>
<p>具体使用详见进程调度算法</p>
<h3 id="进程的状态转移"><a href="#进程的状态转移" class="headerlink" title="进程的状态转移"></a>进程的状态转移</h3><p><img src="/2019/04/13/OS-lab3/env_status.png" alt></p>
<p>注 ： <strong>对用户而言只能调用<code>create</code>,不能使用<code>alloc</code>所以在其看来进程一旦创建便处于可执行状态了</strong></p>
<p>？？或者在<code>env_alloc</code>中设置为<code>ENV_NOT_RUNNABLE</code>,把设置<code>status = ENV_RUNNABLE</code>放在<code>create</code>层次其实更好？？</p>
<p><strong>此处有个坑(测试杀我) ： 评测函数env_check()中会调用env_alloc()，所以会创建一堆只建立了页表但是没有加载可执行文件的残疾进程，所以如果你在调度时只是简单的判断是否是<code>RUNNABLE</code>状态，则会让这些进程运行，然后就会报<code>TOO LOW</code>的错误</strong></p>
<h2 id="对进程的操作"><a href="#对进程的操作" class="headerlink" title="对进程的操作"></a>对进程的操作</h2><h3 id="初始化控制结构"><a href="#初始化控制结构" class="headerlink" title="初始化控制结构"></a>初始化控制结构</h3><h4 id="构建控制块数组"><a href="#构建控制块数组" class="headerlink" title="构建控制块数组"></a>构建控制块数组</h4><ol>
<li><p>函数实现</p>
<p><strong>该函数的流程与物理内存控制块<code>pages</code>的构建流程基本一样</strong></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pmap.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mips_vm_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// code</span></span><br><span class="line">	envs = (struct Env *)alloc(NENV * <span class="keyword">sizeof</span>(struct Env), BY2PG, <span class="number">1</span>);</span><br><span class="line">    n = ROUND(NENV * <span class="keyword">sizeof</span>(struct Env), BY2PG);</span><br><span class="line">    boot_map_segment(pgdir, UENVS, n, PADDR(envs), PTE_R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>图示分析</p>
<p><img src="/2019/04/13/OS-lab3/envs.png" alt></p>
</li>
</ol>
<h4 id="初始化控制结构-1"><a href="#初始化控制结构-1" class="headerlink" title="初始化控制结构"></a>初始化控制结构</h4><ol>
<li>函数实现</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 初始化空闲进程块链表</span></span><br><span class="line">	LIST_INIT(&amp;env_free_list);</span><br><span class="line">    <span class="comment">// 初始化待调度进程控制块链表</span></span><br><span class="line">	LIST_INIT(&amp;env_sched_list[<span class="number">0</span>]);</span><br><span class="line">	LIST_INIT(&amp;env_sched_list[<span class="number">1</span>]);</span><br><span class="line">	<span class="comment">// 初始时所有的进程控制块都是空闲的</span></span><br><span class="line">	<span class="keyword">for</span>(i=NENV<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		envs[i].env_status = ENV_FREE;</span><br><span class="line">		LIST_INSERT_HEAD(&amp;env_free_list,&amp;envs[i],env_link);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建一个进程"><a href="#创建一个进程" class="headerlink" title="创建一个进程"></a>创建一个进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_create_priority</span><span class="params">(u_char *binary, <span class="keyword">int</span> size, <span class="keyword">int</span> priority)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="comment">//分配进程控制块</span></span><br><span class="line">	<span class="keyword">if</span>(env_alloc(&amp;e,<span class="number">0</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,env can't create because alloc env failed!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//设计进程优先级，在我们的系统中即是一次可以使用的时间片个数</span></span><br><span class="line">	e-&gt;env_pri = priority；</span><br><span class="line">    <span class="comment">//加载二进制镜像</span></span><br><span class="line">	load_icode(e,binary,size);</span><br><span class="line">    <span class="comment">//将加载完之后的进程加入等待被调度的链表中</span></span><br><span class="line">	LIST_INSERT_HEAD(&amp;env_sched_link[<span class="number">0</span>], &amp;e, env_sched_link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数调用分析"><a href="#函数调用分析" class="headerlink" title="函数调用分析"></a>函数调用分析</h4><p><img src="/2019/04/13/OS-lab3/create_call.png" alt></p>
<h4 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h4><h5 id="分配进程所需资源"><a href="#分配进程所需资源" class="headerlink" title="分配进程所需资源"></a>分配进程所需资源</h5><p>即函数<code>env_alloc()</code>的作用，分配进程运行的必需资源，详细分析如下：</p>
<ol>
<li><p>函数流程 ：</p>
<ol>
<li>从进程控制块空闲链表中取出一个</li>
<li><strong>使用<code>snv_setup_vm</code>分配空间资源</strong></li>
<li>填写控制块中的各项数值</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">env_alloc</span><span class="params">(struct Env **<span class="keyword">new</span>, u_int parent_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="comment">// 从空闲进程块中分配一个控制块</span></span><br><span class="line">	<span class="keyword">if</span>((e=LIST_FIRST(&amp;env_free_list))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,alloc env failed!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 为进程分配运行必需的空间资源</span></span><br><span class="line">	env_setup_vm(e);</span><br><span class="line">    <span class="comment">// 填写控制块的项</span></span><br><span class="line">	e-&gt;env_parent_id = parent_id;</span><br><span class="line">	e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	e-&gt;env_runs = <span class="number">0</span>;</span><br><span class="line">	e-&gt;env_id = mkenvid(e);			    <span class="comment">//生成唯一的进程标识符</span></span><br><span class="line">    e-&gt;env_tf.cp0_status = <span class="number">0x10001004</span>;</span><br><span class="line">	e-&gt;env_tf.regs[<span class="number">29</span>] = USTACKTOP;		<span class="comment">//填写栈寄存器</span></span><br><span class="line">	<span class="comment">// 将使用过的控制块从空闲链表中移除</span></span><br><span class="line">	*<span class="keyword">new</span> = e;</span><br><span class="line">	LIST_REMOVE(e,env_link);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重点说明 ：</p>
<ol>
<li><p><code>env_setup_vm()</code>函数 ：</p>
<p>该函数作用是建立进程的页目录结构</p>
<p>注意点 ：</p>
<ul>
<li>对进程页目录的初始化（一部分来自拷贝了内核页目录）</li>
<li><strong>自映射机制的构建</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">env_setup_vm</span><span class="params">(struct Env *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	Pde *pgdir;</span><br><span class="line">    <span class="comment">// 给进程的页目录分配一个物理页</span></span><br><span class="line">	<span class="keyword">if</span> ((r = page_alloc(&amp;p)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		panic(<span class="string">"env_setup_vm - page_alloc error\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;pp_ref++;</span><br><span class="line">	pgdir = (Pde *)page2kva(p);<span class="comment">//将分配的物理页映射到kseg0中的一个虚拟地址方便之后填写</span></span><br><span class="line">  	<span class="comment">/* 之后的工作是对这个进程的页表中的项进行填写</span></span><br><span class="line"><span class="comment">  	 * 注意填写要区分</span></span><br><span class="line"><span class="comment">  	 * 1.没有在内核页表中完成映射的虚拟空间（UTOP向下：用户堆栈区) : 清空初始化</span></span><br><span class="line"><span class="comment">  	 * 2.已经在内核页表中映射好的虚拟空间（UTOP向上：ENVS,PAGES,USER VPT, kseg） ： 拷贝内核中对应页表项</span></span><br><span class="line"><span class="comment">  	 * 注：ENV,PAGES的映射是在mips_vm_init中通过boot_map_segment实现的</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PDX(UTOP); i++) &#123;</span><br><span class="line">		pgdir[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (i = PDX(UTOP); i &lt;= PDX(~<span class="number">0</span>); i++) &#123;</span><br><span class="line">		pgdir[i] = boot_pgdir[i];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 填写控制块信息</span></span><br><span class="line">	e-&gt;env_pgdir = pgdir;	<span class="comment">//进程页目录的起始虚拟内核地址</span></span><br><span class="line">	e-&gt;env_cr3   = PADDR(pgdir); <span class="comment">//进程页目录的起始物理地址</span></span><br><span class="line">	<span class="comment">// 之后的两条语句完成自映射机制</span></span><br><span class="line">    e-&gt;env_pgdir[PDX(VPT)]   = e-&gt;env_cr3 | PTE_V;<span class="comment">//将（进程页目录的起始物理地址）以（只读的权限）写入页目录中（内核空间的页目录起始虚拟地址VPT）对应的项</span></span><br><span class="line">    e-&gt;env_pgdir[PDX(UVPT)]  = e-&gt;env_cr3 | PTE_V | PTE_R;<span class="comment">//将（进程页目录的起始物理地址）以（读写的权限）写入页目录中（用户空间的页目录起始虚拟地址UVPT）对应的项</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>mkenvid()</code>函数</p>
<p>该函数的作用是生成唯一的进程标识符</p>
<ul>
<li><p>生成标识符 ：标识符分为两段</p>
<ul>
<li><p>使用<code>next_env_id</code>静态递增变量来<strong>保证不同进程的进程号一定不同</strong></p>
<p>占据高位段</p>
</li>
<li><p>使用<code>idx</code>即该进程控制块在<code>envs[]</code>的数组下标段来<strong>保证可以从进程号获得<code>env</code>控制块</strong></p>
<p>占据低11位段（因为只有1024项）</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function">u_int <span class="title">mkenvid</span><span class="params">(struct Env *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> u_long next_env_id = <span class="number">0</span>;</span><br><span class="line">	u_int idx = e - envs;</span><br><span class="line">    <span class="comment">//拼接两部分</span></span><br><span class="line">	<span class="keyword">return</span> (++next_env_id &lt;&lt; (<span class="number">1</span> + LOG2NENV)) | idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">envid2env</span><span class="params">(u_int envid, struct Env **penv, <span class="keyword">int</span> checkperm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="comment">//当前第一个进程还未创建其他进程</span></span><br><span class="line">	<span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">		*penv = curenv;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//依据低11位来取出index获得env结构体</span></span><br><span class="line">	e = &amp;envs[ENVX(envid)];</span><br><span class="line">    <span class="comment">//该进程未使用，</span></span><br><span class="line">    <span class="comment">//或者唯一进程标识符不同，</span></span><br><span class="line">    <span class="comment">//则取进程失败</span></span><br><span class="line">	<span class="keyword">if</span> (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid) &#123;</span><br><span class="line">		*penv = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//取出进程不是由当前进程创建的，即父子关系不对，则取出失败</span></span><br><span class="line">    <span class="keyword">if</span> (checkperm &amp;&amp; e != curenv &amp;&amp; e-&gt;env_parent_id != curenv-&gt;env_id)&#123;</span><br><span class="line">        *penv = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">	*penv = e;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>e-&gt;env_tf.cp0_status = 0x10001004;</code>语句：</p>
<p>待施工….。</p>
</li>
</ol>
</li>
</ol>
<h5 id="加载二进制映像"><a href="#加载二进制映像" class="headerlink" title="加载二进制映像"></a>加载二进制映像</h5><p>即函数<code>load_icode(struct Env *e, u_char *binary, u_int size)</code>的作用 ：</p>
<ol>
<li><p>函数流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_icode</span><span class="params">(struct Env *e, u_char *binary, u_int size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	u_long entry_point;</span><br><span class="line">	u_long r;</span><br><span class="line">    u_long perm;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span>(page_alloc(&amp;p)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,alloc page failed!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//为用户栈空间分配一页物理内存并完成从[USTACKTOP-BY2PG, USTACKTOP]到分配物理空间的二级页结构映射</span></span><br><span class="line">    <span class="comment">//即构建进程的运行栈空间</span></span><br><span class="line">	perm = PTE_V|PTE_R;</span><br><span class="line">	page_insert(e-&gt;env_pgdir,p,USTACKTOP-BY2PG,perm);</span><br><span class="line">    <span class="comment">//加载二进文件</span></span><br><span class="line">    r = load_elf(binary,size,&amp;entry_point,e,load_icode_mapper);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry.load entire image failed!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	e-&gt;env_tf.pc = entry_point;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>重点说明</p>
<ol>
<li><p><code>load_elf()</code>函数 ：</p>
<ul>
<li><p>参数含义 ：</p>
<ul>
<li><code>binary</code> ：待加载的二级制<code>ELF</code>文件的起始虚拟地址</li>
<li><code>size</code> ： <code>ELF</code>文件的字节数目</li>
<li><code>entry_point</code> ：程序的入口地址</li>
<li><code>*map</code>：函数指针，在此处即是调用<code>load_icode_mapper()</code></li>
</ul>
</li>
<li><p>函数作用 ：</p>
<p><strong>解析<code>ELF</code>文件头信息</strong>并把它加载到指定的虚拟内存区域，并建立对物理空间的二级页表映射</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel_elfloader.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">load_elf</span><span class="params">(u_char *binary, <span class="keyword">int</span> size, u_long *entry_point, <span class="keyword">void</span> *user_data,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">int</span> (*<span class="built_in">map</span>)(u_long va, <span class="keyword">u_int32_t</span> sgsize,</span></span></span><br><span class="line"><span class="function"><span class="params">						u_char *bin, <span class="keyword">u_int32_t</span> bin_size, <span class="keyword">void</span> *user_data))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//解析ELF文件头的信息（具体结构在下文）</span></span><br><span class="line">	Elf32_Ehdr *ehdr = (Elf32_Ehdr *)binary;</span><br><span class="line">	Elf32_Phdr *phdr = <span class="literal">NULL</span>;</span><br><span class="line">	u_char *ptr_ph_table = <span class="literal">NULL</span>;</span><br><span class="line">	Elf32_Half ph_entry_count;</span><br><span class="line">	Elf32_Half ph_entry_size;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="comment">//判断ELF文件是否合法</span></span><br><span class="line">	<span class="keyword">if</span> (size &lt; <span class="number">4</span> || !is_elf_format(binary)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获得segment结构头的起始地址指针</span></span><br><span class="line">	ptr_ph_table = binary + ehdr-&gt;e_phoff;</span><br><span class="line">    <span class="comment">//获得segment段的数目</span></span><br><span class="line">	ph_entry_count = ehdr-&gt;e_phnum;</span><br><span class="line">    <span class="comment">//获得一个segment结构头的大小</span></span><br><span class="line">	ph_entry_size = ehdr-&gt;e_phentsize;</span><br><span class="line">	<span class="comment">//遍历所有segment结构头</span></span><br><span class="line">	<span class="keyword">while</span> (ph_entry_count--) &#123;</span><br><span class="line">		phdr = (Elf32_Phdr *)ptr_ph_table;</span><br><span class="line">        <span class="comment">//如果该segment的类型是加载类型</span></span><br><span class="line">		<span class="keyword">if</span> (phdr-&gt;p_type == PT_LOAD) &#123;</span><br><span class="line">            <span class="comment">//将该segment段加载到其头结构指出的虚拟地址空间并建立二级页表映射</span></span><br><span class="line">			r = <span class="built_in">map</span>(phdr-&gt;p_vaddr, phdr-&gt;p_memsz,</span><br><span class="line">					binary + phdr-&gt;p_offset, phdr-&gt;p_filesz, user_data);</span><br><span class="line">			<span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> r;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//指下一个segment结构头</span></span><br><span class="line">		ptr_ph_table += ph_entry_size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 程序入口地址</span></span><br><span class="line">	*entry_point = ehdr-&gt;e_entry;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>load_icode_mapper()</code>函数 ：</p>
<ul>
<li><p>参数含义 ：</p>
<ul>
<li><code>va</code> : 该段要加载到的虚拟地址</li>
<li><code>sgsize</code> : 该段在内存中的大小</li>
<li><code>bin</code> : 该段在<code>ELF</code>文件中的内容的起始地址</li>
<li><code>bin_size</code> : 该段在文件中的大小</li>
</ul>
</li>
<li><p>函数作用 ：</p>
<p><strong>将<code>ELF</code>文件中的一个<code>segment</code>加载到指定的虚拟地址处并建立好对应的二级页表映射（主要通过<code>page_inset</code>建立），若内存中大小比在文件中大，则多余的位用0补</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_icode_mapper</span><span class="params">(u_long va, <span class="keyword">u_int32_t</span> sgsize,</span></span></span><br><span class="line"><span class="function"><span class="params">							 u_char *bin, <span class="keyword">u_int32_t</span> bin_size, <span class="keyword">void</span> *user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span> = (<span class="title">struct</span> <span class="title">Env</span> *)<span class="title">user_data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	u_long i;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">    <span class="comment">//获得va在其所在页中的偏移offset</span></span><br><span class="line">	u_long offset = va - ROUNDDOWN(va, BY2PG);</span><br><span class="line">	<span class="comment">//为二进制文件分配存储的物理页</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; bin_size; i += BY2PG) &#123;</span><br><span class="line">		<span class="keyword">if</span>(page_alloc(&amp;p)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Sorry,alloc page failed!\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;pp_ref++;</span><br><span class="line">        <span class="comment">//void bcopy(const void *src, void *dst, size_t len)</span></span><br><span class="line">        <span class="comment">//从src（虚拟源地址）复制len个字节到dst(虚拟目标地址)</span></span><br><span class="line">        <span class="comment">//下面的两个copy不好理解，具体看下图</span></span><br><span class="line">        <span class="comment">//总的来说，就是比较剩下待拷贝的数据大小与页的大小来决定拷贝的数据量，然后逐页拷贝</span></span><br><span class="line">        <span class="comment">//对第一个分配的页，可能页不从首地址开始，所以要特殊考虑</span></span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">			bcopy(bin,(<span class="keyword">char</span> *)page2kva(p)+offset,((BY2PG-offset)&lt;bin_size-i)?(BY2PG-offset):(bin_size - i));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			bcopy(bin+i-offset,(<span class="keyword">char</span> *)page2kva(p),(BY2PG&lt;bin_size-i+offset)?BY2PG:(bin_size-i+offset));</span><br><span class="line">        <span class="comment">//拷贝完之后p对应物理页中存储二进制数据</span></span><br><span class="line">        <span class="comment">//然后以读写的权限通过该进程的页表将va+i（即当前一页二进制数据应该加载到虚拟地址）映射到p对应的物理页上</span></span><br><span class="line">		r = page_insert(env-&gt;env_pgdir,p,va+i,PTE_V|PTE_R);</span><br><span class="line">		<span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Sorry,insert a page is failed!\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//当该segment在内存中的大小大于在文件中时</span></span><br><span class="line">    <span class="comment">//给多余的地址空间赋值为0（在page_alloc()中就已经清0） </span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; sgsize) &#123;</span><br><span class="line">		<span class="keyword">if</span>(page_alloc(&amp;p)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Sorry,alloc page failed!\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;pp_ref++;</span><br><span class="line">		r = page_insert(env-&gt;env_pgdir,p,va+i,PTE_V|PTE_R);</span><br><span class="line">		<span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Sorry,alloc page failed!\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">		&#125;</span><br><span class="line">		i+=BY2PG;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>图示</strong></p>
<ul>
<li><p><code>ELF</code>文件结构示意图</p>
<p><img src="/2019/04/13/OS-lab3/ELF.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ELF文件头结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	e_ident[EI_NIDENT];	<span class="comment">/* Magic number and other info */</span></span><br><span class="line">	Elf32_Half	e_type;			<span class="comment">/* Object file type */</span></span><br><span class="line">	Elf32_Half	e_machine;		<span class="comment">/* Architecture */</span></span><br><span class="line">	Elf32_Word	e_version;		<span class="comment">/* Object file version */</span></span><br><span class="line">	Elf32_Addr	e_entry;		<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">	Elf32_Off	e_phoff;		<span class="comment">/* Program header table file offset */</span></span><br><span class="line">	Elf32_Off	e_shoff;		<span class="comment">/* Section header table file offset */</span></span><br><span class="line">	Elf32_Word	e_flags;		<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">	Elf32_Half	e_ehsize;		<span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">	Elf32_Half	e_phentsize;	<span class="comment">/* Program header table entry size */</span></span><br><span class="line">	Elf32_Half	e_phnum;		<span class="comment">/* Program header table entry count */</span></span><br><span class="line">	Elf32_Half	e_shentsize;	<span class="comment">/* Section header table entry size */</span></span><br><span class="line">	Elf32_Half	e_shnum;		<span class="comment">/* Section header table entry count */</span></span><br><span class="line">	Elf32_Half	e_shstrndx;		<span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个segment结构头的结构，其管理一份segment段</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Elf32_Word	p_type;			<span class="comment">/* Segment type */</span></span><br><span class="line">	Elf32_Off	p_offset;		<span class="comment">/* Segment file offset */</span></span><br><span class="line">	Elf32_Addr	p_vaddr;		<span class="comment">/* Segment virtual address */</span></span><br><span class="line">	Elf32_Addr	p_paddr;		<span class="comment">/* Segment physical address */</span></span><br><span class="line">	Elf32_Word	p_filesz;		<span class="comment">/* Segment size in file */</span></span><br><span class="line">	Elf32_Word	p_memsz;		<span class="comment">/* Segment size in memory */</span></span><br><span class="line">	Elf32_Word	p_flags;		<span class="comment">/* Segment flags */</span></span><br><span class="line">	Elf32_Word	p_align;		<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载一个<code>segment</code>的示意图</p>
<p><img src="/2019/04/13/OS-lab3/segment1.png" alt></p>
<p><img src="/2019/04/13/OS-lab3/segment2.png" alt></p>
<p><img src="/2019/04/13/OS-lab3/segment3.png" alt></p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h3><p>主要使用<code>env_run(e)</code>方法运行线程e ：</p>
<ul>
<li>函数流程 ：<ol>
<li>从内存中取出当前线程（<code>curenv</code>）保存上下文的地方</li>
<li>将上下文信息存入当前线程（<code>curenv</code>）的控制块的<code>env_tf</code>结构中以便他切走</li>
<li>设置<code>e</code>为当前进程，并加载<code>e</code>进程的上下文信息</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMESTACK 0x82000000</span></span><br><span class="line"><span class="comment">//由当前进程切换到e进程执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_run</span><span class="params">(struct Env *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//old即为当前进程进程的上下文存储的地方</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> *<span class="title">old</span> = (<span class="title">struct</span> <span class="title">Trapframe</span> *)(<span class="title">TIMESTACK</span>-<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trapframe</span>));</span></span><br><span class="line">	<span class="keyword">if</span>(curenv)&#123;</span><br><span class="line">        <span class="comment">//将当前进程的上下文保存其进程控制块的的env_tf结构体变量中</span></span><br><span class="line">		bcopy(old,&amp;(curenv-&gt;env_tf),<span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">        <span class="comment">/* 填写存储进程再次切换回来时应该开始执行的指令地址</span></span><br><span class="line"><span class="comment">         * 我们的进程切换时由于分配时间片使用完之后导致的时钟中断</span></span><br><span class="line"><span class="comment">         * cp0_epc存储的是产生中断时的执行指令地址</span></span><br><span class="line"><span class="comment">         * 所以它就是我们进程再次切回时应该执行的指令，将其保存在env_tf。pc中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		curenv-&gt;env_tf.pc = old-&gt;cp0_epc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将当前进程切换到e</span></span><br><span class="line">	curenv = e;</span><br><span class="line">	curenv-&gt;env_runs ++;</span><br><span class="line">	<span class="comment">//（即切换页目录）加载要运行进程的页目录（env_cr3中保存了页目录的起始物理地址)</span></span><br><span class="line">	lcontext(KADDR(curenv-&gt;env_cr3));	</span><br><span class="line">    <span class="comment">//加载当前要运行的进程的上下文</span></span><br><span class="line">	env_pop_tf(&amp;(curenv-&gt;env_tf),GET_ENV_ASID(curenv-&gt;env_id));	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>分析<code>lcontext(KADDR(curenv-&gt;env_cr3))</code></p>
<p><strong>该函数的所用其实是加载要运行的进程的页目录虚拟地址到<code>mCONTEXT</code>这个全局变量中，其实也是构造进程运行环境的一部分</strong></p>
<p>让我们先追踪溯源 ：</p>
<ol>
<li><p><code>lcontext</code>的函数定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env_asm.S</span></span><br><span class="line">LEAF(lcontext)</span><br><span class="line">		.<span class="keyword">extern</span>	mCONTEXT</span><br><span class="line">		<span class="comment">//该操作即是将该进程的页目录的内核虚拟地址存入mCONTEXT中</span></span><br><span class="line">		sw		a0,mCONTEXT<span class="comment">//a0代表第一个参数，即为KADDR(curenv-&gt;cr3)</span></span><br><span class="line">		jr	ra</span><br><span class="line">		nop</span><br><span class="line">END(lcontext)</span><br></pre></td></tr></table></figure>
</li>
<li><p>出现了变量<code>mCONTEXT</code>我们继续来追踪溯源 ：</p>
<ul>
<li><p>定义处 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//start.S第45行</span></span><br><span class="line">			.globl mCONTEXT</span><br><span class="line">mCONTEXT:</span><br><span class="line">   			.word <span class="number">0</span><span class="comment">//即初值为0的一个字大小的全局变量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用处 ：我们目前只关注在这之前改变他值的操作，暂时不关心使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pmap.c第160行</span></span><br><span class="line">pgdir = alloc(BY2PG, BY2PG, <span class="number">1</span>);</span><br><span class="line">mCONTEXT = (<span class="keyword">int</span>)pgdir;<span class="comment">//mCONTEXT中保存的是内核中的页目录的起始内核虚拟地址</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><p>分析<code>env_pop_tf(&amp;(curenv-&gt;env_tf),GET_ENV_ASID(curenv-&gt;env_id));</code></p>
<p><strong>该函数的作用是构造要运行的进程的上下文环境，即从它的<code>env_tf</code>中取出上一次执行到结束时的环境，然后赋值给当前的运行环境，保证和上一次运行衔接</strong></p>
<ul>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env_asm.S第15行</span></span><br><span class="line">LEAF(env_pop_tf)</span><br><span class="line"><span class="comment">/*传入参数</span></span><br><span class="line"><span class="comment"> *$a0 : 当前进程的env-&gt;env_tf起始地址，即上下文信息</span></span><br><span class="line"><span class="comment"> *$a1 : 当前进程的唯一标识（经过一定处理）//我也不知道他为什么要处理。。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.<span class="built_in">set</span>	mips1          </span><br><span class="line">		<span class="comment">//1:	j	1b</span></span><br><span class="line">	nop    </span><br><span class="line">		move	k0,a0 </span><br><span class="line">		mtc0	a1,CP0_ENTRYHI</span><br><span class="line">		<span class="comment">//是设置中断位，从禁止中断（即之前在时钟中断进入的核心态）到允许中断即将EXL：IE从10--&gt;00（详见下图）(?????)</span></span><br><span class="line">		mfc0	t0,CP0_STATUS                    </span><br><span class="line">		ori		t0,<span class="number">0x3</span>                          </span><br><span class="line">		xori	t0,<span class="number">0x3</span>                          </span><br><span class="line">		mtc0	t0,CP0_STATUS                    </span><br><span class="line">		<span class="comment">//加载进程控制块的储存上下文信息的tf中的值到对应的寄存器中去	</span></span><br><span class="line">		lw	v1,TF_LO(k0)                                       </span><br><span class="line">		mtlo	v1                               </span><br><span class="line">		lw	v0,TF_HI(k0)                     </span><br><span class="line">		lw	v1,TF_EPC(k0)                    </span><br><span class="line">		mthi	v0                               </span><br><span class="line">		mtc0	v1,CP0_EPC  </span><br><span class="line">		lw	$<span class="number">31</span>,TF_REG31(k0)                 </span><br><span class="line">		...........                </span><br><span class="line">		lw	$<span class="number">1</span>,TF_REG1(k0)</span><br><span class="line">		lw	k1,TF_PC(k0)</span><br><span class="line">		lw	k0,TF_STATUS(k0)                 </span><br><span class="line">		nop</span><br><span class="line">        <span class="comment">//跟新CP0协处理器的状态</span></span><br><span class="line">		mtc0	k0,CP0_STATUS</span><br><span class="line">		j	k1</span><br><span class="line">		rfe</span><br><span class="line">		nop</span><br><span class="line">END(env_pop_tf)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/OS-lab3/SR.png" alt></p>
<p><img src="/2019/04/13/OS-lab3/E.png" alt></p>
</li>
<li><p>图解进程切换</p>
<p><img src="/2019/04/13/OS-lab3/save.png" alt></p>
<p><img src="/2019/04/13/OS-lab3/write.png" alt></p>
</li>
</ul>
</li>
</ul>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>我的傻瓜调度 ：</p>
<p>进程调度主要依赖于函数<code>sched_yield()</code>以及数据结构<code>env_sched_list[2]</code>（这两个链表构造出一种类似于循环链表的形式） :</p>
<ul>
<li><p>调度原理</p>
<ol>
<li><p>初始经过<code>env_create_priority()</code>创建的进程（已经加载过二进制文件随时可以调度执行）加入到<code>env_sched_list[0]</code>中去</p>
</li>
<li><p>每次符合调度条件时，将当前要调度走的进程插入另一个调度队列，然后试图从当前调度队列中拿出一项可调度的，<strong>如果没有则换另一个链表寻找</strong></p>
</li>
<li>拿到要切换到的进程后，<strong>将时间片计数值清0</strong>，然后调用<code>env_run()</code>进行切换</li>
</ol>
<p>注：在调度第一个进程时行为有所不同</p>
</li>
<li><p>调度算法实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sched.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_yield</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录当前进程已经使用的时间片数目</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//t = 0/1表示从哪个待调度队列中取进程</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	counter++;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 切换进程的条件</span></span><br><span class="line"><span class="comment">     * 1. 当前进程时NULL，这种情况只发生在运行第一个进程的时候</span></span><br><span class="line"><span class="comment">     * 2. 当前进程的时间片已经用完了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">if</span> (curenv == <span class="literal">NULL</span> || counter &gt;= curenv-&gt;env_pri)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 如果不是第一次运行进程，则要将当前进程添加到另一个待调度队列中以便下一次调度</span></span><br><span class="line">		<span class="keyword">if</span> (curenv != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LIST_INSERT_TAIL(&amp;env_sched_link[t^<span class="number">1</span>], curenv, env_sched_link);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//在当前调度队列中寻找下一个可调度来运行的进程</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span>  <span class="title">Env</span> *<span class="title">e</span> = <span class="title">LIST_FIRST</span>(&amp;<span class="title">env_sched_link</span>[<span class="title">t</span>]);</span></span><br><span class="line">            <span class="comment">//如果没找到，则换一个调度队列继续找</span></span><br><span class="line">			<span class="keyword">if</span> (e == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				t = t ^ <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//找到一个可执行的</span></span><br><span class="line">			<span class="keyword">if</span> (e-&gt;env_status == ENV_RUNNABLE)</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">//从待调度队列中移除</span></span><br><span class="line">				LIST_REMOVE(e, env_sched_link);</span><br><span class="line">                <span class="comment">//初始化已使用时间片个数</span></span><br><span class="line">				counter = <span class="number">0</span>;</span><br><span class="line">				env_run(e);<span class="comment">//在env_run()方法中会将curenv设置为e</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果不需要调度则当前进程继续执行</span></span><br><span class="line">	env_run(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图示</p>
<p>以我们指导书的两个线程为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENV_CREATE_PRIORITY(user_A, <span class="number">2</span>);</span><br><span class="line">ENV_CREATE_PRIORITY(user_B, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//调度顺序应该为BABABA</span></span><br><span class="line"><span class="comment">//其中一次B占1个时间片，一个A占2个时间片</span></span><br></pre></td></tr></table></figure>
<ol>
<li>初始进程建立好之后</li>
</ol>
<p><img src="/2019/04/13/OS-lab3/1.png" alt></p>
<ol start="2">
<li>第一次调度执行B</li>
</ol>
<p><img src="/2019/04/13/OS-lab3/2.png" alt></p>
<ol start="3">
<li>第二次调度执行A</li>
</ol>
<p><img src="/2019/04/13/OS-lab3/3.png" alt></p>
<ol start="3">
<li>第三次调度又执行B</li>
</ol>
<p><img src="/2019/04/13/OS-lab3/4.png" alt></p>
<p><img src="/2019/04/13/OS-lab3/5.png" alt></p>
</li>
</ul>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>在<code>lab3</code>中所有的进程切换都是时钟中断导致的</p>
<p>流程如下 : (异常处理详见<code>lab4</code>)</p>
<ol>
<li>硬件完成 : 产生时间中断,CPU保存信息(异常原因,<code>EPC</code>等),跳转到异常分发代码</li>
<li>软件完成 : <ol>
<li>根据<code>CAUSE</code>寄存器中的<code>ExcCode</code>判断为时钟中断,跳转到对于的处理函数<code>hand_int</code></li>
<li>处理函数进行异常的处理</li>
<li>处理完之后返回,恢复运行</li>
</ol>
</li>
</ol>
<p>异常处理函数如下 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NESTED(handle_int, TF_SIZE, sp)</span><br><span class="line">nop</span><br><span class="line">SAVE_ALL	<span class="comment">//保存现场,将寄存器的值压栈(TIMESTACK栈)</span></span><br><span class="line">CLI			<span class="comment">//异常处理中关闭时钟中断</span></span><br><span class="line">.<span class="built_in">set</span>	at</span><br><span class="line">mfc0	t0, CP0_CAUSE</span><br><span class="line">mfc0	t2, CP0_STATUS</span><br><span class="line"><span class="keyword">and</span>	t0, t2</span><br><span class="line">andi	t1, t0, STATUSF_IP4</span><br><span class="line">bnez	t1, timer_irq	<span class="comment">//timer_irq为真正的处理函数</span></span><br><span class="line">nop</span><br><span class="line">END(handle_int)</span><br><span class="line"></span><br><span class="line">timer_irq:</span><br><span class="line"><span class="number">1</span>:	j	sched_yield	<span class="comment">//异常处理即为切换进程</span></span><br><span class="line">	nop</span><br><span class="line">	j	ret_from_exception	<span class="comment">//恢复现场(其实不会恢复,因为j跳转不会记录返回地址)</span></span><br><span class="line">	<span class="comment">//真正的恢复寄存器的值应该是新调度运行的进程的,而不是老进程的,即由env_pop_tf函数完成</span></span><br><span class="line">	nop</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/12/Write-Read/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/Write-Read/" itemprop="url">Write-Read</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-12T19:09:01+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PV操作"><a href="#PV操作" class="headerlink" title="PV操作"></a>PV操作</h1><h2 id="实现Write-Read模型"><a href="#实现Write-Read模型" class="headerlink" title="实现Write-Read模型"></a>实现Write-Read模型</h2><h3 id="写优先级"><a href="#写优先级" class="headerlink" title="写优先级"></a>写优先级</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readcount = <span class="number">0</span>;	<span class="comment">//当前读者数目</span></span><br><span class="line"><span class="keyword">int</span> writecount = <span class="number">0</span>;</span><br><span class="line">semaphore rmutex = <span class="number">1</span>;	<span class="comment">//保护readcount的互斥信号量</span></span><br><span class="line">semaphore wmutex = <span class="number">1</span>;	<span class="comment">//保护writecount的互斥信号量</span></span><br><span class="line">semaphore <span class="built_in">queue</span> = <span class="number">1</span>;		<span class="comment">//读进程的等待队列</span></span><br><span class="line">semaphore w_sem = <span class="number">1</span>;		<span class="comment">//写进程的互斥信号量</span></span><br><span class="line">semaphore r_sem = <span class="number">1</span>;		<span class="comment">//读进程用来与写进程互斥的量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWait(<span class="built_in">queue</span>);</span><br><span class="line">        	semWait(r_sem);</span><br><span class="line">        		semWait(rmutex);	<span class="comment">//保证对readcount操作的原子性</span></span><br><span class="line">        			<span class="comment">//如果是第一个读者，则阻塞写进程</span></span><br><span class="line">        			<span class="keyword">if</span> (readcount == <span class="number">0</span>)	 semWait(w_sem);</span><br><span class="line">        			readcount++;</span><br><span class="line">        		semSignal(rmutex);</span><br><span class="line">        	semSignal(r_sem);</span><br><span class="line">        semSignal(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="comment">// read data code</span></span><br><span class="line">        semWait(rmutex);	<span class="comment">//保证对readcount操作的原子性</span></span><br><span class="line">        	readcount--;</span><br><span class="line">        	<span class="comment">// 读者结束优先唤醒写者</span></span><br><span class="line">        	<span class="keyword">if</span> (readcount == <span class="number">0</span>)	 semSignal(w_sem);</span><br><span class="line">        semSignal(rmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWait(wmutex);	<span class="comment">// 保证对writecount操作的原子性</span></span><br><span class="line">        	<span class="keyword">if</span> (writecount == <span class="number">0</span>)	semWait(r_sem);</span><br><span class="line">        	writecount++;</span><br><span class="line">        semSignal(wmutex);</span><br><span class="line">       	semWait(w_sem);</span><br><span class="line">        <span class="comment">// write data code</span></span><br><span class="line">        semSignal(w_sem);</span><br><span class="line">        semWait(wmutex);</span><br><span class="line">        	writecount--;</span><br><span class="line">        	<span class="comment">// 当写完事后才释放读者的使用权</span></span><br><span class="line">        	<span class="keyword">if</span> (writecount == <span class="number">0</span>)	semSignal(r_sem);</span><br><span class="line">        semSignal(wmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/09/cache结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/09/cache结构/" itemprop="url">访存结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-09T12:06:36+08:00">
                2019-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><h2 id="cache的工作原理"><a href="#cache的工作原理" class="headerlink" title="cache的工作原理"></a>cache的工作原理</h2><p>基本的<code>cache</code>一项至少包含数据信息以及标记位</p>
<p>现代体系结构中的<code>cache</code>多采用组相联,多级<code>cache</code>结构</p>
<p>为方便起见以下使用一级<code>cache</code>说明,多级就等价于将低级<code>cache</code>看做是高级<code>cache</code>的高速缓存</p>
<ol>
<li>通过地址获得在<code>cache</code>中的索引</li>
<li>由索引得到<code>cache</code>中的一组,比较该组中各项的标记是否与给出地址符合</li>
<li>比较后 :<ul>
<li>若存在符合,则<code>cache</code>命中,返回得到的物理内存中的数据值</li>
<li>若不存在符合,<strong>则产生缺失,这时需要到内存中(实际上一般是下一级<code>cache</code>)中寻找该地址对应的数据,并将该数据写到<code>cache</code>中来</strong></li>
</ul>
</li>
</ol>
<p><img src="/2019/04/09/cache结构/cache-work.png" alt></p>
<p>注 : 在<code>cache</code>使用实际中涉及缺失时的替换策略,写时的数据一致性等等工程细节问题,此处只做简单说明</p>
<ul>
<li><p>替换策略 : 随机替换,最近最少使用策略,先进先出策略</p>
<p><strong>在考虑策略时要注意硬件实现的复杂性</strong></p>
</li>
<li><p>写操作一致性 : </p>
<ul>
<li>写回法 : 暂时只向<code>cache</code>中写入,并标记是否修改,直到该块被替换出去才将值写会内存中</li>
<li>写直达 : 在每次写<code>cache</code>的同时也写入内存中</li>
</ul>
</li>
</ul>
<h2 id="cache结构种类"><a href="#cache结构种类" class="headerlink" title="cache结构种类"></a>cache结构种类</h2><h3 id="VIVT"><a href="#VIVT" class="headerlink" title="VIVT"></a>VIVT</h3><p><code>Virtual index Virtual Tag</code> : 使用虚拟地址索引域和虚拟地址的标记位,其中存储的是其对应物理内存的数据值</p>
<ul>
<li><p>优势 :</p>
<p>直接使用CPU发出的虚拟地址的索引域和标记域来查找<code>cache line</code>,而不用经过<code>MMU</code>的翻译,所以查找的速度是最快的</p>
</li>
<li><p>问题 :</p>
<ul>
<li><code>synonyms</code> : 多个不同的虚拟地址可能会被映射到同一个物理地址,即缓存别名情况<ol>
<li>例如在多进程通信时,多个虚拟地址映射到一个物理地址,导致<strong>同一个物理地址有多个高速缓存</strong>,对任何一个缓存的修改都会导致数据不一致</li>
</ol>
</li>
<li><code>homonyms</code> : 相同的虚拟地址指向不同的物理地址,<strong>这种情况下仅仅依靠<code>Virtual Index</code>无法区分这些相同的<code>cache</code>项</strong><ol>
<li>在不同的进程中可能出现该情况</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="VIPT"><a href="#VIPT" class="headerlink" title="VIPT"></a>VIPT</h3><p><code>Virtual Index Physical Tag</code>：使用虚拟地址的索引域和物理地址的标记域,其中存储在内存中物理地址的数据值,<strong>这种方法综合较优</strong></p>
<ul>
<li><p>优势 :</p>
<p><strong>可以通过一定程度的并行设计来提高访存效率</strong></p>
<ol>
<li><p><code>CPU</code>指令给出虚拟地址 :</p>
<ul>
<li><p>虚拟地址进入<code>cache</code>结构寻找对应的组</p>
</li>
<li><p>虚拟地址进入<code>TLB</code>结构查询是否有对应的物理页号生成物理地址</p>
</li>
</ul>
</li>
<li><p>得到物理地址后作为生成<code>tag</code>访问对应的缓存项</p>
</li>
<li><p>检查是否命中 :</p>
<ul>
<li>命中则返回数据</li>
<li>没有命中则根据物理地址访问内存</li>
</ul>
</li>
</ol>
</li>
<li><p>问题解决 :</p>
<ul>
<li><p>显然,由于是通过物理地址的标记位来确定是否命中的,所以不存在相同的虚拟地址指向不同物理地址的情况</p>
</li>
<li><p>对于<code>synonyms</code>问题 :</p>
<p>把握一点 : <strong>虚实地址的映射关系是通过页结构完成的,即页对齐思想</strong></p>
<p>以4KB大小为一页来分析 :</p>
<ol>
<li><strong>相互对应的虚拟和物理地址的页内偏移一定相同,即低12位一定相同</strong></li>
<li>当多个虚拟地址映射到同一个物理地址时,这些虚拟地址的低12位一定是相同的</li>
<li>只要项内偏移 + <code>cache</code>索引没有超过12位,则这些虚拟地址对应同一个<code>cache</code>组,而物理标记位一定是唯一的,所以对应同一项</li>
<li>所以不会出现缓存别名情况</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="PIPT"><a href="#PIPT" class="headerlink" title="PIPT"></a>PIPT</h3><p><code>Physical Index Physical Tag</code>：使用物理地址的索引域和物理地址的标记域</p>
<p><strong>问题在于访存太慢</strong></p>
<ol>
<li><code>CPU</code>给出虚拟地址来访问数据，<code>TLB</code>接收到这个地址之后查找是否有对应的页表项。</li>
<li>假设页表项存在，则根据物理地址在<code>cache</code>中查询；如果不存在，则<code>MMU</code>执行正常的页表查询工作之后再根据物理地址在<code>cache</code>中查询，同时更新<code>TLB</code>中的内容。</li>
<li>如果<code>cache</code>命中，则直接返回给<code>CPU</code>数据；如果没有命中则按照相应的算法进行cache<code>的替换或者装填，之后返回给</code>CPU`数据。</li>
</ol>
<p><strong>当<code>TLB</code>没用命中但是这个地址是在<code>cache</code>中时会带来巨大的性能损失</strong></p>
<p><img src="/2019/04/09/cache结构/PIPT.png" alt></p>
<h1 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h1><p><strong><code>TLB</code>本质上就是页表结构的<code>cache</code></strong></p>
<h2 id="页表的使用"><a href="#页表的使用" class="headerlink" title="页表的使用"></a>页表的使用</h2><p>实现从<code>VPN--&gt;PPN</code>的转换</p>
<p><img src="/2019/04/09/cache结构/page.png" alt></p>
<p>注 : </p>
<ul>
<li><code>V</code>是标记位,标记该页表项是否有效</li>
<li><code>AR</code>是权限位,检查访存权限</li>
</ul>
<h2 id="TLB中的信息"><a href="#TLB中的信息" class="headerlink" title="TLB中的信息"></a>TLB中的信息</h2><p><strong><code></code>TLB<code>作为一种特殊的</code>cache`结构工作</strong></p>
<ul>
<li>访问时使用的<code>index</code>是<code>VPN</code>的低位</li>
<li>判断使用命中时使用的<code>tag</code>是<code>VPN</code>的高位</li>
<li>每一项中存储的信息包括比较时使用的<code>tag</code>以及真正使用的数据<code>PPN</code>(含标记位)</li>
</ul>
<p><img src="/2019/04/09/cache结构/TLB.png" alt></p>
<h1 id="cache-TLB-工作"><a href="#cache-TLB-工作" class="headerlink" title="cache + TLB 工作"></a>cache + TLB 工作</h1><p><img src="/2019/04/09/cache结构/TLB+Cache.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/03/OS-lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/03/OS-lab2/" itemprop="url">OS-lab2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-03T21:54:25+08:00">
                2019-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="OS-lab2-memory-management"><a href="#OS-lab2-memory-management" class="headerlink" title="OS-lab2 memory management"></a>OS-lab2 memory management</h1><h2 id="基本设定"><a href="#基本设定" class="headerlink" title="基本设定"></a>基本设定</h2><ul>
<li><p>虚拟内存4G大小,分布如下:</p>
<p><img src="/2019/04/03/OS-lab2/mm.png" alt></p>
</li>
<li><p>物理内存大小为64MB</p>
</li>
<li>分页大小为一页4KB</li>
<li>页表结构为两层,页表项大小为4K,即一页页表为1K项,每一项映射4KB即一页大小空间,所以一页页表映射4MB空间</li>
<li>页表第一级为页目录,只有一页,1K项,每一项中保存一个页表的物理首地址</li>
<li>页表第二级为页表,有1K页,每页1K项,每一项中保存一个物理页的首地址</li>
<li><strong>由于自映射机制可知页目录即为某一页页表</strong></li>
<li><strong>其中<code>kseg0</code>区域的物理虚拟地址转换不需要经过页表,只需要将最高位改变即可</strong></li>
<li>规定内核映射的虚拟空间范围为<code>0x8001_0000 - 0x8040_0000</code></li>
</ul>
<h2 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol>
<li><p><code>Page</code>物理内存管理单元结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span>							</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span>	<span class="comment">// 指向链表中下一个元素</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span>	<span class="comment">// 指向链表中前一个元素中指向后一个的指针(二重指针)</span></span><br><span class="line">	&#125;pp_linhk;	</span><br><span class="line">	u_short pp_ref;	<span class="comment">// 表示该物理页被引用多少次</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>宏定义链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供了大量的宏定义链表操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_HEAD(name, type)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_HEAD_INITIALIZER(head)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_ENTRY(type)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_EMPTY(head)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_FIRST(head)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_FOREACH(var, head, field)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_INIT(head)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_NEXT(elm, field)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_INSERT_AFTER(listelm, elm, field)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_INSERT_BEFORE(listelm, elm, field)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_INSERT_HEAD(head, elm, field)</span></span><br></pre></td></tr></table></figure>
<p><strong>该链表设计的巧妙之处在于二重指针<code>*le_prev</code>,该指针指向前一个元素数据域中指向下一个的那个指针,该设计的作用是在删除一个链表节点时只需要有指向该节点的指针即可,即要删除<code>A</code>指向的节点,只需令<code>*(A-&gt;pp_link.le_prev) = A-&gt;pp_link.le_next</code>即可</strong></p>
</li>
</ol>
<h3 id="地址操作"><a href="#地址操作" class="headerlink" title="地址操作"></a>地址操作</h3><ol>
<li><p>在<code>kseg0</code>中的地址操作只需要改变最高位即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在kseg0区域内</span></span><br><span class="line"><span class="comment">// 虚存中的区域起始地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ULIM 0x80000000</span></span><br><span class="line"><span class="comment">// 由虚拟地址得到物理地址 : -0x8000_0000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PADDR(kva)						\</span></span><br><span class="line">(&#123;								\</span><br><span class="line">	u_long a = (u_long) (kva);				\</span><br><span class="line">	<span class="keyword">if</span> (a &lt; ULIM)					\</span><br><span class="line">		panic(<span class="string">"PADDR called with invalid kva %08lx"</span>, a);\</span><br><span class="line">	a - ULIM;						\</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 有物理地址得到虚拟地址 : +0x8000_0000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KADDR(pa)						\</span></span><br><span class="line">(&#123;								\</span><br><span class="line">	u_long ppn = PPN(pa);					\</span><br><span class="line">	<span class="keyword">if</span> (ppn &gt;= npage)					\</span><br><span class="line">		panic(<span class="string">"KADDR called with invalid pa %08lx"</span>, (u_long)pa);\</span><br><span class="line">	(pa) + ULIM;					\</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在用户空间中需要使用二级页表结构来实现地址转换</p>
<ul>
<li><p>由<strong>硬件完成</strong>的地址映射机制</p>
<p><img src="/2019/04/03/OS-lab2/page.png" alt></p>
</li>
<li><p>在程序中要进行的是在最开始初始化页表,即建立内存管理时<strong>对页表项的填写</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由虚拟地址得到页目录项的索引</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDX(va)		((((u_long)(va))&gt;&gt;22) &amp; 0x03FF)</span></span><br><span class="line"><span class="comment">// 由虚拟地址得到页表项的索引</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTX(va)		((((u_long)(va))&gt;&gt;12) &amp; 0x03FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意 :</span></span><br><span class="line"><span class="comment">所有的虚拟地址都通过u_long类型的指针表示,因为u_long类型占4B空间,刚好时页表或页目录一项的大小,这样首地址加索引便是指向某一项的指针(类似于数组,利用了一页空间的连续性)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>有关对齐</strong></p>
<ul>
<li><p>在页表中每一项按字(4B)对齐</p>
</li>
<li><p><strong>在分配物理内存时按页(4KB)分配对齐</strong></p>
</li>
<li><p><strong>地址对齐函数</strong> :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BY2PG		4096	<span class="comment">// 4KB</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROUND(a, n)	(((((u_long)(a))+(n)-1)) &amp; ~((n)-1))</span></span><br><span class="line"><span class="comment">// 将address按4KB对齐</span></span><br><span class="line">address = ROUND(address, BY2PG);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><h3 id="从物理虚拟内存角度"><a href="#从物理虚拟内存角度" class="headerlink" title="从物理虚拟内存角度"></a>从物理虚拟内存角度</h3><ul>
<li>对物理内存的管理依赖于<code>Page</code>结构体数组<code>pages[]</code>,以及由数组中的某些项链接构成的可使用空闲物理页<code>page_free_list</code></li>
<li><p>对虚拟内存的管理依赖</p>
<ul>
<li><code>kseg0</code>中虚实地址直接转换</li>
<li><code>kuseg</code>中利用二级页表进行虚实地址转换</li>
</ul>
</li>
<li><strong>在程序中直接访问的一定是虚拟地址,但是可能写入的数据是物理地址 : 例如填写页表项</strong></li>
</ul>
<h3 id="从构建阶段角度"><a href="#从构建阶段角度" class="headerlink" title="从构建阶段角度"></a>从构建阶段角度</h3><ul>
<li>在物理内存被页式管理之前,使用<code>alloc</code>函数来分配固定大小的物理内存</li>
<li>在物理内存被页式管理之后,从<code>page_free_list</code>中取空闲的物理页分配</li>
</ul>
<h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><h3 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h3><p>内核在虚拟地址空间的<code>kseg0</code>中的<code>0x8001_0000 - 0x8040_0000</code>中</p>
<p>映射到物理空间是<code>0x0001_0000 - 0x0040_0000</code>区域</p>
<h3 id="初始化内存管理"><a href="#初始化内存管理" class="headerlink" title="初始化内存管理"></a>初始化内存管理</h3><p>从<code>mips_init</code>函数入手,总流程如下图</p>
<p> <img src="/2019/04/03/OS-lab2/summary.png" alt></p>
<p><strong>其他都好理解,难点在于<code>boot_map_segment</code>函数</strong></p>
<p>该函数的作用是建立将分配好物理内存的<code>pages[]</code>通过建立页表,填写页表项,填写页目录项映射到虚拟空间中的<code>kuseg</code>区间中</p>
<p><code>boot_map_segment(pdgir, UPAGES, n, PADDR(pages), PTE_R)</code></p>
<ul>
<li><p>参数说明 :</p>
<ul>
<li><code>pgdir(*u_long)</code> : 之前建立的页目录的起始虚地址</li>
<li><code>UPAGES(u_long)</code> : 虚拟空间用户空间中的<code>PAGES</code>段起始地址</li>
<li><code>n(u_long)</code> : <code>pages[]</code>占用的空间页数</li>
<li><code>PADDR(pages)</code> : <code>pages[]</code>占用的物理空间的起始地址</li>
</ul>
</li>
<li><p>具体流程 :</p>
<ol>
<li>对虚拟空间中的每一页调用<code>boot_pgdir_walk(pgdir, va , 1)</code><ol>
<li>由<code>pgdir + PDX(va)</code>得到<code>va</code>对应的页目录项地址</li>
<li>取出页目录项值 : 必为无效值<ol>
<li>从物理内存中使用<code>alloc</code>分配一页并映射到<code>kseg0</code>空间作为该项对应一页页表,返回该页虚拟起始地址<code>pgtable</code></li>
<li>将该页物理地址<code>KADDR(pgtable)</code>填入页目录项中</li>
</ol>
</li>
<li>由<code>pgtable + PTX(va)</code>得到该建立的页表中<code>va</code>对应的页表项地址</li>
</ol>
</li>
<li>将该页对应的物理地址填入页表项中</li>
</ol>
</li>
</ul>
<h3 id="图解流程"><a href="#图解流程" class="headerlink" title="图解流程"></a>图解流程</h3><h4 id="加载内核-1"><a href="#加载内核-1" class="headerlink" title="加载内核"></a>加载内核</h4><p><img src="/2019/04/03/OS-lab2/2.png" alt></p>
<h4 id="创建页目录"><a href="#创建页目录" class="headerlink" title="创建页目录"></a>创建页目录</h4><p><img src="/2019/04/03/OS-lab2/3.png" alt></p>
<h4 id="创建物理块并建立它的二级页表映射"><a href="#创建物理块并建立它的二级页表映射" class="headerlink" title="创建物理块并建立它的二级页表映射"></a>创建物理块并建立它的二级页表映射</h4><p><img src="/2019/04/03/OS-lab2/4.png" alt></p>
<h4 id="页结构内存管理"><a href="#页结构内存管理" class="headerlink" title="页结构内存管理"></a>页结构内存管理</h4><p><img src="/2019/04/03/OS-lab2/6.png" alt></p>
<h2 id="初始化之后的内存操作"><a href="#初始化之后的内存操作" class="headerlink" title="初始化之后的内存操作"></a>初始化之后的内存操作</h2><p><strong>在初始化之后所有的内存操作都要基于页结构来完成,不能再使用<code>alloc</code>函数直接分配</strong></p>
<h3 id="基本工具-1"><a href="#基本工具-1" class="headerlink" title="基本工具"></a>基本工具</h3><p><strong>利用了物理内存控制块对应物理内存的连续性以及页对齐的特性</strong></p>
<ul>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由该页的控制块获得其在pages[]中的下标</span></span><br><span class="line">page2ppn(struct Page *pp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pp - pages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>由物理页的控制块指针获得其物理地址</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSHIFT		12</span></span><br><span class="line">page2pa(struct Page *pp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得下标之后即代表是第几个物理页,一页4KB,所以左移12位即可得到物理地址</span></span><br><span class="line">	<span class="keyword">return</span> page2ppn(pp)&lt;&lt;PGSHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>由物理地址得到指向其控制块的指针</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 物理地址右移12位得到该物理页对应控制块在pages[]中的下标</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PPN(va)		(((u_long)(va))&gt;&gt;12)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct Page *<span class="title">pa2page</span><span class="params">(u_long pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (PPN(pa) &gt;= npage)</span><br><span class="line">		panic(<span class="string">"pa2page called with invalid pa: %x"</span>, pa);</span><br><span class="line">    <span class="comment">// 返回控制块指针</span></span><br><span class="line">	<span class="keyword">return</span> &amp;pages[PPN(pa)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><ul>
<li><p><code>int page_alloc(struct Page **pp)</code> :</p>
<ul>
<li>函数功能 : 在<code>page_free_list</code>中找到一个空闲页清空之后让<code>*pp</code>指向该节点</li>
<li>分配成功返回0.否则返回<code>-E_NO_MEM</code></li>
</ul>
</li>
<li><p><code>void page_free(struct Page *pp)</code> :</p>
<ul>
<li>函数功能 : 如果控制块<code>pp</code>代表的物理地址的引用<code>pp_ref</code>为0的话则将该控制块加入空闲页链表<code>page_free_list</code></li>
</ul>
</li>
<li><p><strong>重要的基本函数</strong> :</p>
<p><code>int pgdir_walk(Pde *pgdir, u_long va, int create, Pte **ppte)</code> :</p>
<ul>
<li><p>函数功能 : 查找<code>va</code>对应的页表项的指针赋值给<code>*ppte</code>,若没有则新分配一页页表,并将分配的页表的物理地址填入页目录的对应项,将页表项的指针赋值给<code>*ppte</code></p>
</li>
<li><p>参数定义 :</p>
<ul>
<li><code>pgdir</code>为页目录起始虚地址</li>
<li><code>va</code>为要访问的虚地址</li>
<li><code>create = 1</code>时若缺失则建立映射</li>
<li><code>*ppte</code> : 指向<code>va</code>对应的页表项</li>
</ul>
</li>
<li><p>函数流程 :</p>
<ol>
<li><p>查找页目录项 :</p>
<p><code>Pde *pgdir_entryp = pgdir+PDX(va);</code></p>
</li>
<li><p>获得页目录项内容(<code>*pgdir_entryp</code>),即页表(<code>kseg0</code>中)的起始物理地址,并转换为虚拟地址</p>
<p><code>pgtable = KADDR(PTE_ADDR(*pgdir_entryp));</code></p>
</li>
<li><p>检查页目录项内容是否有效</p>
<ol>
<li>若无效且<code>creat == 1</code> : 从空闲链表<code>page_free_list</code>中拿出一页内存(<code>ppage</code>)作为页表并映射到<code>kseg0</code>,<ol>
<li>使用<code>page_alloc(&amp;ppage)</code>分配</li>
<li>使用<code>ppage_pa = page2pa(page)</code>得到页表起始物理地址</li>
<li>使用<code>pgtable = KADDR(ppage_pa)</code>得到页表起始虚拟地址</li>
<li><strong>使用<code>*pgdir_entryp = page2pa(ppage)|PTE_V;</code>将<code>ppage_pa</code>填入页目录项中</strong></li>
</ol>
</li>
<li>若有效则无操作</li>
</ol>
</li>
<li><p>使用<code>*ppte = pgtable + PTX(va);</code>将<code>*ppte</code>指向<code>va</code>对应的页表项</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p><code>int page_insert(Pde *pgdir, struct Page *pp, u_long va, u_int perm)</code></p>
<ul>
<li><p>函数功能 : <strong>以<code>perm</code>的权限建立<code>va</code>到<code>pp</code>的二级页表映射</strong></p>
<p>检查<code>va</code>对应的页表项的值 : </p>
<p><code>pgdir_walk(pgdir, va, 0, &amp;pgtable_entry)</code></p>
<ul>
<li><p>若页表项存在 : </p>
<ul>
<li><p>若对应<code>pp</code> : 增加<code>perm</code>权限 <code>*pgtable_entry = (page2pa(pp) | PERM)</code></p>
</li>
<li><p>若不对应<code>pp</code> : 则从该页表中删除<code>va</code>对应的映射关系</p>
<p><code>page_remove(pgdir, va)</code></p>
</li>
</ul>
</li>
<li><p>若页表项不存在或不对应<code>pp</code></p>
<ol>
<li><p>申请一页新的页表并写入页目录中</p>
<p><code>pgdir_walk(pgdir, va, 1, &amp;pgtable_entry)</code></p>
</li>
<li><p>页表中对应项页权限位写入<code>pp</code>对应的物理地址,即建立<code>va</code>到<code>pp</code>的二级页表映射</p>
<p><code>*pgtable_entry = (page2pa(pp) | PERM)</code></p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>struct Page *page_lookup(Pde *pgdir, u_long va, Pte **ppte)</code></p>
<ul>
<li>函数功能 :<ul>
<li>返回<code>va</code>虚拟地址对应的页控制块的指针</li>
<li><code>*ppte</code>赋值指向<code>va</code>对应的页表项</li>
</ul>
</li>
</ul>
</li>
<li><p><code>void page_remove(Pde *pgdir, u_long va)</code></p>
<ul>
<li>函数功能 : <ol>
<li>删除<code>va</code>对应的页表项中的映射关系(即置0),对应物理块的引用<code>pp_ref</code>减一</li>
<li>如果删除后引用次数为0.则释放该页<code>page_free(ppage)</code></li>
</ol>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/cmd-command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/28/cmd-command/" itemprop="url">cmd command</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-28T20:54:56+08:00">
                2019-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/command/" itemprop="url" rel="index">
                    <span itemprop="name">command</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常用cmd命令"><a href="#常用cmd命令" class="headerlink" title="常用cmd命令"></a>常用cmd命令</h1><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><ul>
<li><p>进入首层盘 </p>
<p><code>D:</code></p>
</li>
<li><p>进入其他文件夹</p>
<p><code>cd [foldername]</code></p>
</li>
<li><p>返回上一层</p>
<p><code>cd ..</code></p>
</li>
<li><p>查看目录文件</p>
<p><code>dir</code></p>
</li>
</ul>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ul>
<li><p>创建目录</p>
<p><code>md [foldername]</code></p>
</li>
<li><p>删除目录</p>
<p><code>rd [foldername]</code></p>
</li>
<li><p>复制文件</p>
<p><code>copy sourcePath destinationPath</code></p>
</li>
<li><p>移动文件(剪切+粘贴)</p>
<p><code>move sourcePath destinationPath</code></p>
</li>
<li><p>删除文件(不能文件夹)</p>
<p><code>del filename</code></p>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>清除屏幕</p>
<p><code>cls</code></p>
</li>
<li><p>查看本机ip</p>
<p><code>ipconfig</code></p>
</li>
</ul>
<h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><ul>
<li><p><code>help</code>命令查看所有<code>dos</code>命令</p>
</li>
<li><p>在任何一个命令后<code>+ /?</code>查看其他属性(包括用法和参数)</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/idea-debug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/28/idea-debug/" itemprop="url">idea-debug</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-28T20:54:56+08:00">
                2019-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/debug/" itemprop="url" rel="index">
                    <span itemprop="name">debug</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用idea进行debug"><a href="#使用idea进行debug" class="headerlink" title="使用idea进行debug"></a>使用idea进行debug</h1><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><ol>
<li>甲壳虫标记以Debug模式启动服务。</li>
<li>断点：在左边行号栏单击左键.</li>
<li>Debug窗口：访问请求到达第一个断点后，会自动激活Debug窗口。</li>
<li>调试按钮：一共有8个按钮，调试的主要功能就对应着这几个按钮，鼠标悬停在按钮上可以查看对应的快捷键。在菜单栏Run里可以找到同样的对应的功能</li>
<li>服务按钮：可以在这里关闭/启动服务，设置断点等。</li>
<li>方法调用栈：这里显示了该线程调试所经过的所有方法，勾选右上角的[Show All Frames]按钮，就不会显示其它类库的方法了，否则这里会有一大堆的方法。</li>
<li>Variables：在变量区可以查看当前断点之前的当前方法内的变量。</li>
<li>Watches：查看变量，可以将Variables区中的变量拖到Watches中查看 </li>
</ol>
<p><img src="/2019/02/28/idea-debug/856154-20170905221418147-1205043020.png" alt></p>
<h3 id="基本按钮"><a href="#基本按钮" class="headerlink" title="基本按钮"></a>基本按钮</h3><p><img src="/2019/02/28/idea-debug/856154-20170905134837851-1615718043.png" alt></p>
<p>从左到右:</p>
<ol>
<li>快速回到代码当前所在执行行</li>
<li>逐步执行(不进入方法)</li>
<li>步入: 进入当前行方法,多是自定义方法</li>
<li>强制步入: 可以进入任何方法(可用此来查看官方库代码)</li>
<li>步出 :从步入的方法中返回(<strong>进入的方法还是会执行完,只是没有显示过程</strong>)</li>
<li><strong>回退断点</strong></li>
<li>运行到光标处:会将代码运行到光标定位的那一行</li>
<li><strong>计算表达式</strong></li>
</ol>
<h3 id="变量查看"><a href="#变量查看" class="headerlink" title="变量查看"></a>变量查看</h3><ul>
<li>参数所在行后面显示</li>
<li>光标悬停所在参数显示值</li>
<li>Variables中有方法的所有变量</li>
</ul>
<h2 id="技巧类"><a href="#技巧类" class="headerlink" title="技巧类"></a>技巧类</h2><h3 id="计算表达式"><a href="#计算表达式" class="headerlink" title="计算表达式"></a>计算表达式</h3><ol>
<li>选中某个表达式再<code>Alt + F8</code>，弹出计算表达式的窗口<strong>表达式的计算可以是参数值,变量值,方法的返回值等</strong></li>
<li>在计算表达式的面板中,<strong>可以改变变量的值看不同的情况</strong></li>
</ol>
<h3 id="智能进入"><a href="#智能进入" class="headerlink" title="智能进入"></a>智能进入</h3><p>当一行中同时有多个方法时,智能步入可以选择某个方法进入(<em>默认按顺序</em>)</p>
<p><img src="/2019/02/28/idea-debug/856154-20170905163730929-1374653206.png" alt></p>
<p>使用<code>shift +F7</code>可以选择当前行的进入方法</p>
<h3 id="设置断点条件"><a href="#设置断点条件" class="headerlink" title="设置断点条件"></a>设置断点条件</h3><p>当在遍历数组时,只有当满足一定的条件才在断点处停止</p>
<p><img src="/2019/02/28/idea-debug/856154-20170905165253944-1162138475.png" alt></p>
<p>在断点上右键直接设置当前断点的条件</p>
<h2 id="多线程调试"><a href="#多线程调试" class="headerlink" title="多线程调试"></a>多线程调试</h2><p>待施工…..</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">fjh</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fjh</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
