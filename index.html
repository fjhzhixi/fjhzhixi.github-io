<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Matrix">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Matrix">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Matrix</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Matrix</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">just do it !</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/03/OS-lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/OS-lab4/" itemprop="url">OS-lab4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-03T19:40:14+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="lab4做了什么"><a href="#lab4做了什么" class="headerlink" title="lab4做了什么"></a>lab4做了什么</h1><h2 id="支持缺页中断处理"><a href="#支持缺页中断处理" class="headerlink" title="支持缺页中断处理"></a>支持缺页中断处理</h2><p>正常的缺页重填与写时复制导致的缺页</p>
<h2 id="完成基本的系统调用"><a href="#完成基本的系统调用" class="headerlink" title="完成基本的系统调用"></a>完成基本的系统调用</h2><p>我认为系统调用的实质就是用户态的进程想使用一些内核态下的功能,比如分配内存空间,创建进程等等,但是由于操作系统要保障<strong>安全性</strong>,所以这些接口不能向用户程序开放,所以采用一个折中的方法,即<strong>系统调用</strong>,用户将一些必要的信息以<strong>参数的形式</strong>传递给内核,内核判断你的操作是否<strong>合法</strong>,合法则执行并将结果返回给用户,否则拒绝执行</p>
<h2 id="实现fork"><a href="#实现fork" class="headerlink" title="实现fork"></a>实现fork</h2><p><code>fork</code>就是<strong>以父进程为模板</strong>创建一个与其<strong>高度相似</strong>的子进程,其关键的一点特性是<strong>父子进程中的<code>fork</code>返回值不同</strong>,这也是区分父子进程的方法</p>
<h2 id="实现进程间通信"><a href="#实现进程间通信" class="headerlink" title="实现进程间通信"></a>实现进程间通信</h2><p>通信本质上就是<strong>在进程间传递一个数值</strong>, 通过<strong>共享内存</strong>来实现, 共享的就是内核中的进程控制块</p>
<h1 id="提前准备的知识"><a href="#提前准备的知识" class="headerlink" title="提前准备的知识"></a>提前准备的知识</h1><h2 id="MIPS下C与汇编的参数传递"><a href="#MIPS下C与汇编的参数传递" class="headerlink" title="MIPS下C与汇编的参数传递"></a>MIPS下C与汇编的参数传递</h2><p>首先介绍两个关于MIPS汇编的宏定义 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/asm/asm.h</span></span><br><span class="line"><span class="comment">// 用来定义全局叶子汇编函数 : 即在函数内部不需要调用其他函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEAF(symbol)                                    \</span></span><br><span class="line">                .globl  symbol;                         \</span><br><span class="line">                .align  <span class="number">2</span>;                              \</span><br><span class="line">                .type   symbol,@function;               \</span><br><span class="line">                .ent    symbol,<span class="number">0</span>;                       \</span><br><span class="line">symbol:         .frame  sp,<span class="number">0</span>,ra</span><br><span class="line"><span class="comment">// 用来定义全局非叶子汇编函数 : 即在函数内部还调用其他函数 </span></span><br><span class="line"><span class="comment">// 所以在该宏定义结构中已经做了对栈指针的处理</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NESTED(symbol, framesize, rpc)                  \</span></span><br><span class="line">                .globl  symbol;                         \</span><br><span class="line">                .align  <span class="number">2</span>;                              \</span><br><span class="line">                .type   symbol,@function;               \</span><br><span class="line">                .ent    symbol,<span class="number">0</span>;                       \</span><br><span class="line">symbol:         .frame  sp, framesize, rpc</span><br><span class="line"><span class="comment">// 函数结尾</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> END(function)                                   \</span></span><br><span class="line">                .end    function;                       \</span><br><span class="line">                .size   function,.-function</span><br></pre></td></tr></table></figure>
<p><strong>注意我们一般而言只有在接近底层时才有使用到汇编来实现,所以大部分汇编功能都能通过叶子函数完成</strong></p>
<ol>
<li><p>C函数之间的调用 : </p>
<p>所有的参数传递以及返回值的维护由编译器隐式的实现,不需要考虑</p>
</li>
<li><p>MIPS汇编之间的调用</p>
<ul>
<li>调用者需要在代码中显式的在栈中保存受保护寄存器,返回值寄存器等,然后显式的向<code>$a0-$a3</code>中写入参数值,然后调用,返回时要恢复现场</li>
<li>被调用者需要显式的获取参数</li>
<li>参数较多时通过栈传递</li>
</ul>
<p>其实就是<strong>调用者与被调用者遵守并显式的实现统一的调用规则</strong></p>
</li>
<li><p><strong>C调用MIPS汇编函数</strong> : 最常见的一种情况(依据<code>o32ABI</code>的约定)</p>
<ul>
<li>调用者(即C函数) : <ol>
<li>在栈上创建一个容纳参数的空间,从<code>sp</code>指向的位置开始,第一个参数(即C源码中最左侧的参数)位于最低地址处,<strong>每个参数至少占据一个字的大小空间</strong></li>
<li><strong>为任何一个调用都至少分配16字节的栈参数空间,即使没有这么多参数</strong></li>
<li><strong>实际上优先通过的是寄存器传递参数,即参数结构的前16个字节(即4个字)保存在<code>$a0-$a3</code>的寄存器结构中,而栈中的前16个字节的内容未定义,但是其结构必须保存</strong></li>
</ol>
</li>
<li>被调用者(MIPS函数)<ol>
<li>可以选择盲目的将<code>$a0-$a3</code>的写入栈中,也可以不写(取决于该汇编函数的功能)</li>
<li><strong>前4个参数从寄存器获得,之后的参数从栈中获得</strong></li>
</ol>
</li>
</ul>
<p>// 他说此处应该有个图</p>
</li>
<li><p>MIPS汇编函数调用C函数 :</p>
<ul>
<li><p>调用者(即MIPS汇编代码) : 将参数按照C函数的定义从左向右的顺序存入<code>$a0-$a3</code>寄存器中,如果要求在调用结束后保存某些寄存器则要使用栈区保存(<strong>注意<code>ra</code>寄存器是一定要保存的,并在调用结束之后要恢复</strong>),然后直接跳转到C函数的入口地址处即可</p>
<p>注 : 具体实现方法为<strong>在.S文件中使用<code>extern</code>外联定义C函数<code>c_method()</code>,然后直接使用<code>jal c_method</code>即可</strong>(因为<code>jal</code>会写入返回地址到<code>$ra</code>中,而C函数在最后会自动调用<code>jr ra</code>)</p>
</li>
<li><p>被调用者(C函数) : 不用做任何特殊处理,正常编写即可</p>
</li>
</ul>
</li>
</ol>
<h2 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h2><p><strong>时钟中断,系统调用,以及在指令执行中出现的错误都作为一种异常处理</strong></p>
<h3 id="异常处理程序地址"><a href="#异常处理程序地址" class="headerlink" title="异常处理程序地址"></a>异常处理程序地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tools/sces0_3.lds</span></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  . = <span class="number">0x80000080</span>;</span><br><span class="line">  .except_vec3 : &#123;</span><br><span class="line">	*(.text.exc_vec3)</span><br><span class="line">  &#125;<span class="comment">// 可见我们将所有exc_vec3代码段加载到了0x80000080地址处,而这些代码就是最基本的异常处理程序(异常分发程序),实际上该处的代码并没有真正处理异常,只是根据异常类型将其分发给特定的异常处理程序</span></span><br><span class="line">  <span class="comment">// other code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地址<code>0x80000080</code>是当异常发生时<code>CPU</code>将<code>PC</code>跳转到的地址(由<code>MIPS R3000 CPU</code>的设计决定的)</p>
<p>即异常发生时 : <strong>首先是硬件发挥作用,即CPU进行以下行为</strong> : </p>
<ol>
<li>设置<code>EPC</code>为异常处理结束后重新开始的程序地址</li>
<li>设置<code>CP0</code>的<code>SR</code>寄存器中的<code>EXL</code>位使得<code>CPU</code>进入内核态<strong>禁止中断</strong></li>
<li>设置<code>CP0</code>的<code>CAUSE</code>寄存器编码为异常产生原因</li>
<li>设置<code>PC</code>值为异常处理程序的入口地址(在此处即<code>0x80000080</code>)</li>
</ol>
<h3 id="异常类型注册表"><a href="#异常类型注册表" class="headerlink" title="异常类型注册表"></a>异常类型注册表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/traps.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">handle_int</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">handle_reserved</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">handle_tlb</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">handle_sys</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">handle_mod</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 以上具体的实现在外部函数实现</span></span><br><span class="line"><span class="comment">/* 这个数组即是异常向量</span></span><br><span class="line"><span class="comment"> * 向量下标与CAUSE寄存器中的异常类型编号对用</span></span><br><span class="line"><span class="comment"> * 向量每一项为对应异常种类的处理程序的入口地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> exception_handlers[<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">	set_except_vector(i, handle_reserved);</span><br><span class="line">	set_except_vector(<span class="number">0</span>, handle_int);	<span class="comment">//时钟中断异常处理程序</span></span><br><span class="line">	set_except_vector(<span class="number">1</span>, handle_mod);	<span class="comment">//缺页异常处理程序</span></span><br><span class="line">	set_except_vector(<span class="number">2</span>, handle_tlb);	</span><br><span class="line">	set_except_vector(<span class="number">3</span>, handle_tlb);	<span class="comment">//tlb确实异常处理</span></span><br><span class="line">	set_except_vector(<span class="number">8</span>, handle_sys);	<span class="comment">//系统调用异常处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">set_except_vector</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">void</span> * addr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> handler=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> old_handler=exception_handlers[n];</span><br><span class="line">	exception_handlers[n]=handler;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)old_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注 : 异常类型在<code>CAUSE</code>寄存器中对应的编码值</p>
<p><img src="/2019/05/03/OS-lab4/handle_kind.png" alt></p>
<h3 id="异常分发程序"><a href="#异常分发程序" class="headerlink" title="异常分发程序"></a>异常分发程序</h3><p>异常发生时<strong>直接跳转到</strong>的函数地址</p>
<ul>
<li><p>作用 : 根据<code>CAUSE</code>寄存器的值判断异常类型并跳转到对应的处理程序去</p>
</li>
<li><p>实现 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//boot/start.S</span></span><br><span class="line">.section .text.exc_vec3</span><br><span class="line">NESTED(except_vec3, <span class="number">0</span>, sp) <span class="comment">// 非叶子函数因为要跳转到</span></span><br><span class="line">	.<span class="built_in">set</span>	noat</span><br><span class="line">	.<span class="built_in">set</span>	noreorder</span><br><span class="line"><span class="number">1</span>:	<span class="comment">//j	1b</span></span><br><span class="line">	nop</span><br><span class="line">	mfc0	k1,CP0_CAUSE	    <span class="comment">//$k1中存储CAUSE寄存器中的值</span></span><br><span class="line">	andi	k1,<span class="number">0x7c</span>			   <span class="comment">//$k1中存储异常类型的编码值,具体见下文</span></span><br><span class="line">	la	k0,exception_handlers	<span class="comment">//$k0中存储异常向量的起始地址(即数组的基址)</span></span><br><span class="line">	addu	k0,k1			   <span class="comment">//$k0 + $k1 即基址+偏移获得存储(异常处理程序的入口地址)的地址放入$k0中</span></span><br><span class="line">	lw	k0,(k0)				   <span class="comment">//从该地址中取出异常处理程序的入口地址</span></span><br><span class="line">	NOP</span><br><span class="line">	jr	k0					  <span class="comment">//跳转到对应的异常处理程序</span></span><br><span class="line">	nop</span><br><span class="line">	END(except_vec3)</span><br></pre></td></tr></table></figure>
<p>注 : 对<code>andi k1,0x7c</code>的理解</p>
<ol>
<li><p><code>CAUSE</code>寄存器结构如下 :</p>
<p><img src="/2019/05/03/OS-lab4/cause_register.png" alt></p>
</li>
<li><p><code>0x7c = 0x0111_1100</code>,与该数按位与就是获得<code>2-6</code>位的值,从上图可知就是<code>Exc Code</code>的值,所以该操作可以获得异常类型的编码值</p>
</li>
</ol>
</li>
<li><p>在异常分发完之后就是实际的处理程序的运行了</p>
<p>处理异常完成之后即可<strong>返回<code>EPC</code>保存的地址</strong></p>
</li>
</ul>
<h3 id="流程图示"><a href="#流程图示" class="headerlink" title="流程图示"></a>流程图示</h3><p><img src="/2019/05/03/OS-lab4/epc.png" alt></p>
<h1 id="走进lab4"><a href="#走进lab4" class="headerlink" title="走进lab4"></a>走进lab4</h1><h2 id="基本系统调用"><a href="#基本系统调用" class="headerlink" title="基本系统调用"></a>基本系统调用</h2><h3 id="宏观上看一个系统调用的过程"><a href="#宏观上看一个系统调用的过程" class="headerlink" title="宏观上看一个系统调用的过程"></a>宏观上看一个系统调用的过程</h3><ol>
<li>调用一个封装好的用户空间的库函数</li>
<li>调用用户空间的<code>syscall_*</code> 函数</li>
<li>调用<code>msyscall</code>，用于陷入内核态</li>
<li>陷入内核，内核取得信息，执行对应的内核空间的系统调用函数（<code>sys_*</code>）</li>
<li>执行系统调用，并返回用户态，同时将返回值传递回用户态</li>
<li>从库函数返回，回到用户程序调用处</li>
</ol>
<h3 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h3><ol>
<li><p>用户态的行为 : </p>
<ol>
<li><p>调用<code>syscall_*</code>函数,等待返回值(如果有的话)</p>
<p><strong>用户空间不负责任何实质的处理,只是准备好参数之后陷入内核态即可</strong></p>
<p><strong>所有的系统调用都是通过<code>mysyscall</code>陷入内核,通过第一个参数作为系统调用号来区别不同的系统调用种类</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/syscall_lib.c</span></span><br><span class="line"><span class="comment">//所有函数的调用第一个参数是系统调用号(即系统调用类型)</span></span><br><span class="line"><span class="comment">//默认所有的调用都有6个参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_yield</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	msyscall(SYS_yield,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_env_destroy</span><span class="params">(u_int envid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	msyscall(SYS_env_destroy,envid,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall_set_pgfault_handler</span><span class="params">(u_int envid, u_int func, u_int xstacktop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_set_pgfault_handler,envid,func,xstacktop,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall_mem_alloc</span><span class="params">(u_int envid, u_int va, u_int perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_mem_alloc,envid,va,perm,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall_mem_map</span><span class="params">(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_mem_map,srcid,srcva,dstid,dstva,perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即用户准备好必要的信息,然后<strong>包装一层</strong>将第一个参数设置为<strong>系统调用号</strong>,然后内核根据系统调用号的值(<strong>偏移</strong>)决定<strong>真正执行功能的函数的入口地址</strong></p>
<p>这些系统调用号以一个注册表的形式定义在头文件中 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/unistd.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNISTD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNISTD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_BASE 9527</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_SYSCALLS 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_putchar 		((__SYSCALL_BASE ) + (0 ) ) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_getenvid 		((__SYSCALL_BASE ) + (1 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_yield			((__SYSCALL_BASE ) + (2 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_env_destroy		((__SYSCALL_BASE ) + (3 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_set_pgfault_handler	((__SYSCALL_BASE ) + (4 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_mem_alloc		((__SYSCALL_BASE ) + (5 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_mem_map			((__SYSCALL_BASE ) + (6 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_mem_unmap		((__SYSCALL_BASE ) + (7 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_env_alloc		((__SYSCALL_BASE ) + (8 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_set_env_status	((__SYSCALL_BASE ) + (9 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_set_trapframe		((__SYSCALL_BASE ) + (10 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_panic			((__SYSCALL_BASE ) + (11 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_ipc_can_send		((__SYSCALL_BASE ) + (12 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_ipc_recv		((__SYSCALL_BASE ) + (13 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_cgetc			((__SYSCALL_BASE ) + (14 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用<code>msyscall</code>触发系统调用异常陷入内核态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/syscall_wrap.S</span></span><br><span class="line">LEAF(msyscall)	<span class="comment">//说明该函数是一个全局叶子函数,不需要调用其他函数</span></span><br><span class="line"><span class="comment">// sw	a0,0(sp)</span></span><br><span class="line"><span class="comment">// sw	a1,4(sp)</span></span><br><span class="line"><span class="comment">// sw	a2,8(sp)</span></span><br><span class="line"><span class="comment">// sw	a3,12(sp)</span></span><br><span class="line"><span class="comment">// move	v0, a0</span></span><br><span class="line"><span class="comment">// 将参数存入已经在C函数调用汇编函数时分配好的栈空间中</span></span><br><span class="line"><span class="comment">// 我认为目的就是稳一手,防止在异常分发程序中使用这些寄存器破坏数据(反正空间都已经在那了)</span></span><br><span class="line"><span class="comment">// 稳一手把自己稳炸了,不要写上面这些!!!!</span></span><br><span class="line">syscall	<span class="comment">//触发系统调用异常</span></span><br><span class="line">jr	ra</span><br><span class="line">END(msyscall)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p><strong>当调用<code>syscall</code>时发生了什么 : </strong></p>
<p>触发<strong>系统调用异常</strong>按照<strong>上面描述的异常处理流程</strong>将该异常分发到<strong>系统调用处理程序</strong></p>
</li>
<li><p>上述的保存寄存器代码段是依据于系统调用约定 :</p>
<ol>
<li><del>系统调用号放入<code>$v0</code></del>(课上测试不放我有什么办法)</li>
<li>参数的传递按照<code>o32ABI</code>的约定进行 :</li>
</ol>
<ul>
<li>在<code>syscall_lib.c</code>中C函数调用<code>msyscall(SYS_*, arg1,...arg5)</code>时<strong>依据约定栈区划定24字节空间,前4个参数通过<code>$a0-$a3</code>传递,后两个参数通过栈区传递</strong><ul>
<li><del>我为什么不能把所有的参数都放进栈中,为什么,艹</del></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>内核态的行为</p>
<ol>
<li><p>接下来运行<strong>系统调用异常处理程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/syscall.S</span></span><br><span class="line">NESTED(handle_sys,TF_SIZE, sp)</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有的异常处理的第一步都是保存现场(关于保存现场详情移步lab3)</span></span><br><span class="line">SAVE_ALL	<span class="comment">//保存运行现场,即将寄存器全部压栈</span></span><br><span class="line"><span class="comment">// 在上述保存过程中</span></span><br><span class="line">CLI		    <span class="comment">//关闭中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1: j 1b</span></span><br><span class="line">nop</span><br><span class="line">.<span class="built_in">set</span> at</span><br><span class="line"></span><br><span class="line">lw t1, TF_EPC(sp)</span><br><span class="line">addiu t1, <span class="number">4</span></span><br><span class="line">sw	t1, TF_EPC(sp)</span><br><span class="line"><span class="comment">//从保存的现场中取出EPC再+4之后存回,即为异常处理结束之后的重新开始运行的PC值</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//从保存的现场中取出$4即$a0的值存入a0当中去</span></span><br><span class="line">lw a0, TF_REG4(sp)	<span class="comment">//a0即保存的系统调用号</span></span><br><span class="line">addiu a0, a0, -SYSCALL_BASE	<span class="comment">//获得偏移,即获得了系统调用的具体种类</span></span><br><span class="line">sll	t0, a0,<span class="number">2</span></span><br><span class="line">la	t1, sys_call_table	<span class="comment">//t1为系统调用注册表(即下文的入口地址表)的起始地址</span></span><br><span class="line">addu	t1, t1, t0		<span class="comment">//根据偏移得到(具体系统调用函数的入口地址)的地址</span></span><br><span class="line">lw	t2, <span class="number">0</span>(t1)			<span class="comment">//取出入口地址放入$t2</span></span><br><span class="line">lw	t0,TF_REG29(sp)		<span class="comment">//取出保存现场保存的用户态下的栈指针放入$t0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意参数的不同分布</span></span><br><span class="line"><span class="comment">// 前4个参数由于是通过$ai来传递的,所以在保存现场时被存在TF区域,要从这里恢复</span></span><br><span class="line"><span class="comment">// 后两个参数本身就是通过栈来传递的,所以在用户的sp栈指针所指的栈中,而这个栈指针已经取到$t0中去了</span></span><br><span class="line">lw t3, <span class="number">16</span>($t0)</span><br><span class="line">lw t4, <span class="number">20</span>($t0)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//恢复$a0-$a3参数</span></span><br><span class="line">lw a0, TF_REG4(sp)</span><br><span class="line">lw a1, TF_REG5(sp)</span><br><span class="line">lw a2, TF_REG6(sp)</span><br><span class="line">lw a3, TF_REG7(sp)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//然后准备参数,调用对应的系统调用(调用C函数)</span></span><br><span class="line"><span class="comment">//参数 : 前4个通过寄存器传,后面两个通过sp栈区传</span></span><br><span class="line"><span class="comment">//但是在栈区还是要留前4个参数的空间,只不过什么都不存(我也不知道为什么,艹)</span></span><br><span class="line">addiu sp, sp, <span class="number">-24</span></span><br><span class="line">sw t3, <span class="number">16</span>(sp)</span><br><span class="line">sw t4, <span class="number">20</span>(sp)</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line">jalr t2</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复栈指针</span></span><br><span class="line">addiu sp, sp, <span class="number">24</span></span><br><span class="line">   </span><br><span class="line">sw	v0, TF_REG2(sp)</span><br><span class="line"></span><br><span class="line">j	ret_from_exception</span><br><span class="line">nop</span><br><span class="line">END(handle_sys)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 系统调用注册表    </span></span><br><span class="line">sys_call_table:</span><br><span class="line">.align <span class="number">2</span></span><br><span class="line">    .word sys_putchar	<span class="comment">//每一个word存储该系统调用函数的入口地址</span></span><br><span class="line">    .word sys_getenvid</span><br><span class="line">    .word sys_yield</span><br><span class="line">    .word sys_env_destroy</span><br><span class="line">    .word sys_set_pgfault_handler</span><br><span class="line">    .word sys_mem_alloc</span><br><span class="line">    .word sys_mem_map</span><br><span class="line">    .word sys_mem_unmap</span><br><span class="line">    .word sys_env_alloc</span><br><span class="line">    .word sys_set_env_status</span><br><span class="line">    .word sys_set_trapframe</span><br><span class="line">    .word sys_panic</span><br><span class="line">    .word sys_ipc_can_send</span><br><span class="line">    .word sys_ipc_recv</span><br><span class="line">    .word sys_cgetc</span><br></pre></td></tr></table></figure>
<p><strong>参数分布图示</strong></p>
<p><img src="/2019/05/03/OS-lab4/args.png" alt></p>
<p>下面我就想不通了 : </p>
<ul>
<li>在异常分发阶段只是使用了<code>$k0,$k1</code>寄存器</li>
<li>在进入系统调用异常处理程序即<code>handle_sys</code>已经关闭了时钟中断</li>
<li>在<code>SAVA_ALL</code>和恢复参数之间并没有使用<code>$a0-$a3</code>寄存器</li>
</ul>
<p>所以这个保存现场+恢复在目前看来完全是无用操作,在最后设置参数时只需设置<code>args[4],args[5]</code>即可(实测可以跑)</p>
<p>我认为有以下考虑 :</p>
<ol>
<li>操作的统一性 : 处理异常第一件事就是保存现场</li>
<li>后续扩展功能可能破坏寄存器</li>
<li><del>课上测试换你文件</del></li>
</ol>
</li>
<li><p>接下来便是各种<del>神奇</del>的系统调用了</p>
</li>
</ol>
</li>
</ol>
<h4 id="各种系统调用"><a href="#各种系统调用" class="headerlink" title="各种系统调用"></a>各种系统调用</h4><ol>
<li><p><code>void sys_yield(void)</code> : </p>
<ul>
<li><p>函数作用 : 在用户态下做到进程切换</p>
</li>
<li><p>具体实现 : </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_yield</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先保存现场</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> * <span class="title">src</span> = (<span class="title">struct</span> <span class="title">Trapframe</span> *)(<span class="title">KERNEL_SP</span> - <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trapframe</span>));</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> * <span class="title">dst</span> = (<span class="title">struct</span> <span class="title">Trapframe</span> *)(<span class="title">TIMESTACK</span> - <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trapframe</span>));</span></span><br><span class="line">	bcopy((<span class="keyword">void</span> *)src,(<span class="keyword">void</span> *)dst,<span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">	sched_yield();<span class="comment">//执行时间片轮转调度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两个问题 : </p>
<ul>
<li><p><strong>为什么在此处我们保存现场时将<code>KERNEL_SP</code>栈中的数据保存到<code>TIMESTACK</code>栈中去,而在<code>lab3</code>中的进程切换的保存恢复现场都是在<code>TIMESTACK</code>中进行的 ? </strong></p>
<p><del>很不幸,这个问题沙雕的我不想思考</del></p>
<p>我认为<strong><code>kERNEL_SP</code>是系统调用异常时保存现场的区域,而<code>TIMESTACK</code>是时钟中断异常时保存现场的区域</strong></p>
<p><strong>其实这个关键在于<code>SAVE_ALL</code>中的<code>get_sp</code></strong> : </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/stackframe.h</span></span><br><span class="line">.macro SAVE_ALL    </span><br><span class="line">                                  </span><br><span class="line">		mfc0	k0,CP0_STATUS                   </span><br><span class="line">		sll		k0,<span class="number">3</span>   </span><br><span class="line">		bltz	k0,<span class="number">1f</span>                            </span><br><span class="line">		nop      		           </span><br><span class="line"><span class="number">1</span>:				</span><br><span class="line">		move	k0,sp </span><br><span class="line">		get_sp      <span class="comment">//获取要保存寄存器的栈的栈指针</span></span><br><span class="line">		move	k1,sp                     </span><br><span class="line">		subu	sp,k1,TF_SIZE  <span class="comment">// 栈指针下移获得空间                 </span></span><br><span class="line">		sw	k0,TF_REG29(sp)    <span class="comment">// 保存寄存器</span></span><br><span class="line">		........</span><br><span class="line">.macro get_sp</span><br><span class="line">	mfc0	k1, CP0_CAUSE</span><br><span class="line">	andi	k1, <span class="number">0x107C</span>	<span class="comment">//获取CAUSE寄存器中的ExcCode段</span></span><br><span class="line">	xori	k1, <span class="number">0x1000</span></span><br><span class="line">	bnez	k1, <span class="number">1f</span></span><br><span class="line">	nop</span><br><span class="line">	li	sp, <span class="number">0x82000000</span>	<span class="comment">//取TIMESTACK为保存的栈</span></span><br><span class="line">	j	<span class="number">2f</span></span><br><span class="line">	nop</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">	bltz	sp, <span class="number">2f</span></span><br><span class="line">	nop</span><br><span class="line">	lw	sp, KERNEL_SP  <span class="comment">//取KERNEL_SP为保存的栈</span></span><br><span class="line">	nop</span><br><span class="line"><span class="number">2</span>:	nop</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>
<p>即 : </p>
<ul>
<li><strong>在系统调用时异常处理程序第一步是将寄存器信息保存到<code>KERNEL_SP</code>栈区</strong></li>
<li><strong>在时钟中断时异常处理程序第一步是将寄存器信息保存到<code>TIMESTACK</code>栈区</strong></li>
</ul>
<p>所以该函数的实现如下 : </p>
<ol>
<li><p>进入该函数时寄存器信息已经保存到<code>KERNEL_SP</code>栈区了(<code>handle_sys</code>中进行)</p>
</li>
<li><p><strong>但是在<code>env_run</code>中我们默认是时钟中断导致的进程切换,没有考虑用户显式的命令进程切换,所以我们在切换之前保存当前进程信息都是从<code>TIMESTACK</code>中取数据,所以一定要将<code>KERNEL_SP</code>中的现场在<code>TIMESTACK</code>中备份一份以便进程切换</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/env.c/evn_run()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> *<span class="title">old</span> = (<span class="title">struct</span> <span class="title">Trapframe</span> *)(<span class="title">TIMESTACK</span>-<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trapframe</span>));</span></span><br><span class="line">	<span class="keyword">if</span>(curenv)&#123;</span><br><span class="line">		bcopy(old,&amp;(curenv-&gt;env_tf),<span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">		<span class="comment">//curenv-&gt;env_tf.pc += 4;//aim to mips 32</span></span><br><span class="line">		curenv-&gt;env_tf.pc = old-&gt;cp0_epc;</span><br><span class="line">		<span class="comment">//printf("cp0_epc:%x\n",curenv-&gt;env_tf.pc);</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><strong>调度函数的逻辑需要修改</strong></p>
<p>在<code>lab4</code>的进程切换函数中我们有了新的需求,我认为大概要求如下 : </p>
<ol>
<li>待调度链表中可以有状态为<code>ENV_NOTRUNNABLE</code>的进程控制块,要求其不能被调度</li>
<li><strong>用户态可以使用系统调用设置一个进程为<code>ENV_NOTRUNNABLE</code>状态,要求进入调度算法时当前进程若为<code>ENV_NOTRUNNABLE</code>,即使其时间片还未用完也调度走</strong></li>
</ol>
<p>在<code>lab3</code>的基础上增加几个判断即可,基本思想还是<strong>用两个链表模拟循环链表</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/sched.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_yield</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	counter++;</span><br><span class="line">	<span class="keyword">if</span> (curenv == <span class="literal">NULL</span> || counter &gt;= curenv-&gt;env_pri || curenv-&gt;env_status != ENV_RUNNABLE)	<span class="comment">//进程未NOTRUNNABLE立即调度</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (curenv != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LIST_INSERT_TAIL(&amp;env_sched_liat[t^<span class="number">1</span>], curenv, env_sched_link);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span>  <span class="title">Env</span> *<span class="title">e</span> = <span class="title">LIST_FIRST</span>(&amp;<span class="title">env_sched_list</span>[<span class="title">t</span>]);</span></span><br><span class="line">			<span class="keyword">if</span> (e == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				t = t ^ <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (e-&gt;env_status == ENV_RUNNABLE)</span><br><span class="line">			&#123;</span><br><span class="line">				LIST_REMOVE(e, env_sched_link);</span><br><span class="line">				counter = <span class="number">0</span>;</span><br><span class="line">				env_run(e);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;	<span class="comment">//NOT_RUNNABKLE的扔到另一个链表中</span></span><br><span class="line">				LIST_REMOVE(e, env_sched_link);</span><br><span class="line">				LIST_INSERT_TAIL(&amp;env_sched_list[t^<span class="number">1</span>], e, env_sched_link);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	env_run(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>int sys_mem_alloc(iint sysno, u_int envid, u_int va, u_int perm)</code> : </p>
<ul>
<li><p>函数作用 : 给指定进程<code>envid</code>的指定地址<code>va</code>分配一页地址</p>
</li>
<li><p>具体实现 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_mem_alloc</span><span class="params">(<span class="keyword">int</span> sysno, u_int envid, u_int va, u_int perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//检查虚拟地址va是否合法</span></span><br><span class="line">	<span class="keyword">if</span>(va&gt;=UTOP || va&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,use sys_mem_alloc must promise va &lt; UTOP(%x),but now va:%x\n"</span>,UTOP,va);</span><br><span class="line">		<span class="keyword">return</span> -E_UNSPECIFIED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//检查权限位</span></span><br><span class="line">	<span class="keyword">if</span>((perm &amp; PTE_COW) || !(perm &amp; PTE_V))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,use sys_mem_alloc must promise perm not contain PTE_COW.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">ppage</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(envid2env(envid,&amp;env,<span class="number">0</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,you can't get the env by the given env_id.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//新分配一个物理页</span></span><br><span class="line">	<span class="keyword">if</span>(page_alloc(&amp;ppage)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,use sys_mem_alloc can't get a free page memory.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">	ppage-&gt;pp_ref++;</span><br><span class="line">    <span class="comment">//在进程的页表中建立映射关系</span></span><br><span class="line">	<span class="keyword">if</span>(page_insert(env-&gt;env_pgdir,ppage,va,perm)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_mem_alloc we can't insert the alloced page to env_pgdir.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注 : 关于<code>envid2env中的checkperm参数</code> : </p>
<ol>
<li>当为0时不影响</li>
<li>当为1是要求查询的进程<strong>为当前进程或者当前进程的直接子进程</strong></li>
</ol>
</li>
</ul>
</li>
<li><p><code>int sys_mem_map(int sysno, u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</code> : </p>
<ul>
<li><p>函数作用 : 在目标进程<code>dstid</code>的页表结构中以<code>perm</code>的权限建设从虚拟页<code>dstva</code>到源进程<code>srcid</code>中<code>srcva</code>对应的物理页的页表映射结构</p>
</li>
<li><p>具体实现 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_mem_map</span><span class="params">(<span class="keyword">int</span> sysno, u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	u_int round_srcva, round_dstva;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srcenv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">dstenv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">ppage</span>;</span></span><br><span class="line">	Pte *ppte;</span><br><span class="line">	ppage = <span class="literal">NULL</span>;</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">	round_srcva = ROUNDDOWN(srcva, BY2PG);</span><br><span class="line">	round_dstva = ROUNDDOWN(dstva, BY2PG);</span><br><span class="line">    <span class="comment">//检查地址是否合法</span></span><br><span class="line">	<span class="keyword">if</span>(srcva&gt;=UTOP || dstva&gt;=UTOP || srcva&lt;<span class="number">0</span> || dstva&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,srcva:%x and dstva:%x must &lt;UTOP(%x).\n"</span>,srcva,dstva,UTOP);</span><br><span class="line">		<span class="keyword">return</span> -E_UNSPECIFIED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//检查权限位是否合法</span></span><br><span class="line">	<span class="keyword">if</span>(!(perm &amp; PTE_V))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_mem_map perm is illegal.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获得进程控制结构</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(srcid,&amp;srcenv,<span class="number">0</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,we can't get srcenv!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(envid2env(dstid,&amp;dstenv,<span class="number">0</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,we can't get dstenv!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//从srcenv中获取要映射的物理页</span></span><br><span class="line">	<span class="keyword">if</span>((ppage=page_lookup(srcenv-&gt;env_pgdir,round_srcva,&amp;ppte))==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,we found srcenv not exist page at %x.\n"</span>,round_srcva);</span><br><span class="line">		<span class="keyword">return</span> -E_UNSPECIFIED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在dstenv中建立页表映射关系</span></span><br><span class="line">	<span class="keyword">if</span>(page_insert(dstenv-&gt;env_pgdir,ppage,round_dstva,perm)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_mem_map can't insert src page to dst page.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>int sys_mem_unmap(int sysno, u_int envid, u_int va)</code> : </p>
<ul>
<li><p>函数作用 : 在进程<code>envid</code>的页表结构中去掉<code>va</code>虚拟页的映射结构</p>
</li>
<li><p>具体实现 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_mem_unmap</span><span class="params">(<span class="keyword">int</span> sysno, u_int envid, u_int va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(va&gt;=UTOP)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_mem_unmap va:%x &gt;=UTOP %x.\n"</span>,va,UTOP);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid,&amp;env,PTE_V)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_mem_unmap we can't get env.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	page_remove(env-&gt;env_pgdir,va);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>int sys_env_alloc(void)</code> : 这个函数与一般概念上的建立进程不同</p>
<ul>
<li><p>函数作用 : <strong>以当前进程作为父进程, 以父进程为模板创建一个高度相似的子进程</strong></p>
</li>
<li><p>具体实现 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_env_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="comment">//分配进程控制块</span></span><br><span class="line">	<span class="keyword">if</span>(env_alloc(&amp;e,curenv-&gt;env_id)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,because unable allocate a env,fork failed.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">	e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    e-&gt;env_pri = curenv-&gt;env_pri;</span><br><span class="line">    <span class="comment">//插入调度链表</span></span><br><span class="line">    LIST_INSERT(&amp;env_sched_list[<span class="number">0</span>], e, env_sched_link);</span><br><span class="line">    <span class="comment">//将父进程的环境拷贝一份给子进程</span></span><br><span class="line">	bcopy(KERNEL_SP-<span class="keyword">sizeof</span>(struct Trapframe),&amp;(e-&gt;env_tf),<span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">    <span class="comment">//之后这两条语句很重要,详见下文</span></span><br><span class="line">	e-&gt;env_tf.pc = e-&gt;env_tf.cp0_epc;</span><br><span class="line">	e-&gt;env_tf.regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><strong>注 : 这个函数其实东西比较多 : </strong></p>
<ul>
<li><p><code>e-&gt;env_tf.pc = e-&gt;env_tf.cp0_epc</code></p>
<p><strong>即子进程下一次被调度运行是从父进程创建子进程的系统调用后一条语句开始的</strong></p>
<ol>
<li><p><code>e-&gt;env_tf.cp0_epc</code>是由<strong>父进程拷贝过来</strong>,所以该数据保存的是<strong>父进程调用该系统调用创建子进程时的中断语句</strong></p>
</li>
<li><p><code>e-&gt;env_tf.pc</code>是<strong>子进程下一次开始运行的语句</strong></p>
</li>
</ol>
</li>
<li><p><strong><code>e-&gt;env_tf.regs[2] = 0</code></strong> : <strong>这句话很重要,它是<code>fork</code>机制父子进程返回值不同的基础</strong></p>
<ol>
<li><code>e-&gt;env_tf.regs[2]</code>中保存的是<strong>子进程保护现场中的返回值<code>v0</code>寄存器值,本来应该存储的是父进程的返回值(其实就是子进程的<code>env_id</code>)</strong></li>
<li><strong>将其值人为的赋值为0即可实现在调用子进程恢复现场时使得返回值为0,即实现<code>fork</code>函数子进程返回0,父进程返回子进程<code>id</code></strong></li>
</ol>
</li>
</ul>
<h2 id="缺页中断处理"><a href="#缺页中断处理" class="headerlink" title="缺页中断处理"></a>缺页中断处理</h2><h3 id="一般缺页中断"><a href="#一般缺页中断" class="headerlink" title="一般缺页中断"></a>一般缺页中断</h3><h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><ol>
<li><strong>硬件工作</strong> : <code>CPU</code>根据虚拟地址查<code>tlb</code>时<code>tlb</code>无效,触发异常,记录缺页异常类型,跳转到异常分发代码</li>
<li><strong>软件工作</strong> : <ol>
<li>异常分发代码判断为缺页异常跳转到<code>handle_tlb</code>异常处理代码</li>
<li>该异常处理代码的作用仅是跳转到<code>do_refill</code>函数</li>
<li>在该函数中具体判断是<strong><code>tlb</code>缺失但页表映射的物理页面存在还是物理页面都不存在</strong><ul>
<li><code>tlb</code>缺失但是物理页面存在进行<code>tlb</code>重填,即<code>tlbwr</code>函数</li>
<li>物理页面不存在进行页表项填写,即<code>pageout</code>函数</li>
</ul>
</li>
<li>异常处理完之后返回,继续运行</li>
</ol>
</li>
</ol>
<h4 id="代码细节-1"><a href="#代码细节-1" class="headerlink" title="代码细节"></a>代码细节</h4><ol>
<li><code>handle_tlb &amp; do_refill</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数的作用是根据CP0状态跳转到TLB重填代码或者页表重填代码</span></span><br><span class="line">NESTED(do_refill,<span class="number">0</span> , sp)</span><br><span class="line">	.<span class="keyword">extern</span>	mCONTEXT</span><br><span class="line"><span class="number">1</span>:			</span><br><span class="line">	nop</span><br><span class="line">	lw		k1,mCONTEXT</span><br><span class="line">	<span class="keyword">and</span>		k1,<span class="number">0xfffff000</span></span><br><span class="line">	mfc0	k0,CP0_BADVADDR	<span class="comment">//CP0_BADVADDR中存储的是导致缺页中断的虚拟地址</span></span><br><span class="line">	srl		k0,<span class="number">20</span></span><br><span class="line">	<span class="keyword">and</span>		k0,<span class="number">0xfffffffc</span></span><br><span class="line">	addu	k0,k1</span><br><span class="line">	lw		k1,<span class="number">0</span>(k0)</span><br><span class="line">	nop</span><br><span class="line">	move	t0,k1</span><br><span class="line">	<span class="keyword">and</span>		t0,<span class="number">0x0200</span></span><br><span class="line">	beqz	t0,NOPAGE</span><br><span class="line">	nop</span><br><span class="line">	<span class="keyword">and</span>		k1,<span class="number">0xfffff000</span></span><br><span class="line">	mfc0	k0,CP0_BADVADDR</span><br><span class="line">	srl		k0,<span class="number">10</span></span><br><span class="line">	<span class="keyword">and</span>		k0,<span class="number">0xfffffffc</span></span><br><span class="line">	<span class="keyword">and</span>		k0,<span class="number">0x00000fff</span></span><br><span class="line">	addu	k0,k1</span><br><span class="line">	<span class="keyword">or</span>		k0,<span class="number">0x80000000</span></span><br><span class="line">	lw		k1,<span class="number">0</span>(k0)</span><br><span class="line">	nop</span><br><span class="line">	move	t0,k1</span><br><span class="line">	<span class="keyword">and</span>		t0,<span class="number">0x0200</span></span><br><span class="line">	beqz	t0,NOPAGE</span><br><span class="line">	nop</span><br><span class="line">	move	k0,k1</span><br><span class="line">	<span class="keyword">and</span>		k0,<span class="number">0x1</span></span><br><span class="line">	beqz	k0,NoCOW</span><br><span class="line">	nop</span><br><span class="line">	<span class="keyword">and</span>		k1,<span class="number">0xfffffbff</span></span><br><span class="line">NoCOW:</span><br><span class="line">	mtc0	k1,CP0_ENTRYLO0</span><br><span class="line">	nop</span><br><span class="line">	tlbwr	<span class="comment">//tlb重写填写</span></span><br><span class="line">	j		<span class="number">2f</span></span><br><span class="line">	nop</span><br><span class="line">NOPAGE:</span><br><span class="line">	nop</span><br><span class="line">	mfc0	a0,CP0_BADVADDR</span><br><span class="line">	lw		a1,mCONTEXT</span><br><span class="line">	nop</span><br><span class="line">	sw	 	ra,tlbra</span><br><span class="line">	jal		pageout	<span class="comment">//缺页处理页表项重填</span></span><br><span class="line">	nop</span><br><span class="line">	nop</span><br><span class="line">	lw		ra,tlbra</span><br><span class="line">	nop</span><br><span class="line">	j	<span class="number">1b</span></span><br><span class="line"><span class="number">2</span>:	nop</span><br><span class="line">	jr		ra</span><br><span class="line">	nop</span><br><span class="line">END(do_refill)</span><br><span class="line">    </span><br><span class="line">BUILD_HANDLER tlb	do_refill	cli	   <span class="comment">//宏定义定义全局函数handle_tlb,作用仅为跳转到do_refill</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>pageout</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mm/pmap.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pageout</span><span class="params">(<span class="keyword">int</span> va, <span class="keyword">int</span> context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_long r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (context &lt; <span class="number">0x80000000</span>) &#123;</span><br><span class="line">        panic(<span class="string">"tlb refill and alloc error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((va &gt; <span class="number">0x7f400000</span>) &amp;&amp; (va &lt; <span class="number">0x7f800000</span>)) &#123;</span><br><span class="line">        panic(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;it's env's zone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (va &lt; <span class="number">0x10000</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"current env id is:%d,va:%x,context:%x\n"</span>,curenv-&gt;env_id,va,context);</span><br><span class="line">        panic(<span class="string">"^^^^^^TOO LOW^^^^^^^^^"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = page_alloc(&amp;p)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic (<span class="string">"page alloc error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;pp_ref++;</span><br><span class="line">    page_insert((Pde *)context, p, VA2PFN(va), PTE_R);	<span class="comment">//页表项填写</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pageout:\t@@@___0x%x___@@@  ins a page \n"</span>, va);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写时复制导致的缺页中断"><a href="#写时复制导致的缺页中断" class="headerlink" title="写时复制导致的缺页中断"></a>写时复制导致的缺页中断</h3><h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><p>父子进程共享物理内存是有前提条件的 : <strong>共享的物理内存不会被任一进程修改</strong>,当父子进程中有修改共享内存内存（一般是数据段,<strong>标志是用<code>COW</code>保护</strong>）的行为发生时,就会触发一个缺页异常,内核捕获这种缺页中断后,再为发生内存修改的进程相应的地址分配物理页面.</p>
<h4 id="处理流程-1"><a href="#处理流程-1" class="headerlink" title="处理流程"></a>处理流程</h4><ol>
<li><strong>硬件工作</strong> : <code>CPU</code>根据虚拟地址查页表时发现物理地址被<code>COW</code>位保护,触发异常,记录缺页异常类型,跳转到异常分发代码</li>
<li><strong>软件工作</strong> : <ol>
<li>异常分发代码判断为缺页异常,跳转到写时复制缺页异常处理代码</li>
<li><strong>在微内核的设计当中内核不做具体的处理,具体的缺页重填代码在用户态实现</strong></li>
<li>用户态分配物理页,建立映射机制</li>
<li>异常中断返回,重新访问该地址,程序继续运行</li>
</ol>
</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="缺页异常处理-内核中"><a href="#缺页异常处理-内核中" class="headerlink" title="缺页异常处理(内核中)"></a>缺页异常处理(内核中)</h5><ol>
<li><p><strong>缺页异常的处理被分发到<code>handle_mod</code>函数处理</strong>(具体的跳转流程详见异常类型注册表与异常分发程序)</p>
<p>这个<code>handle_mod</code>函数藏得很深,使用汇编宏定义来定义</p>
<p>在这个函数中实际上<strong>保存现场关闭中断</strong>之后跳转到实际处理函数<code>page_fault_handler</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/genex.S</span></span><br><span class="line"><span class="comment">//定义全局的异常处理程序的宏定义</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * exception为异常的类型(tlb/mod),函数名为handle_\exception(对应异常类型注册表中的handle_tlb,handle_mod)</span></span><br><span class="line"><span class="comment"> * handler为实际处理该异常的函数,即在该程序内部要跳转到的程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">.macro	BUILD_HANDLER exception handler clear</span><br><span class="line">	.align	<span class="number">5</span></span><br><span class="line">	NESTED(handle_\exception, TF_SIZE, sp)  </span><br><span class="line">	nop</span><br><span class="line">	SAVE_ALL				</span><br><span class="line">	__build_clear_\clear</span><br><span class="line">	.<span class="built_in">set</span>	at</span><br><span class="line">	move	a0, sp</span><br><span class="line">	jal	\handler</span><br><span class="line">	nop</span><br><span class="line">	j	ret_from_exception</span><br><span class="line">	nop</span><br><span class="line">	END(handle_\exception)</span><br><span class="line">.endm</span><br><span class="line">BUILD_HANDLER reserved do_reserved cli	<span class="comment">//定义全局函数handle_resereverd</span></span><br><span class="line">BUILD_HANDLER mod	page_fault_handler cli	<span class="comment">//定义全局函数hanle_mod,在函数中跳转到page_fault_handler中去</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>page_fault_handler</code>函数 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/trap.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">page_fault_handler</span><span class="params">(struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"><span class="comment">//tf参数时在调用放在$a0中,即当前的栈指针,当中保存着运行现场,为一个struct Trapframe结构体大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_int va;</span><br><span class="line">    u_int *tos, d;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">PgTrapFrame</span>;</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">curenv</span>;</span></span><br><span class="line">	bcopy(tf, &amp;PgTrapFrame,<span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">    <span class="comment">//之后这个判断语句主要是为了支持异常处理的重入</span></span><br><span class="line">	<span class="keyword">if</span>(tf-&gt;regs[<span class="number">29</span>] &gt;= (curenv-&gt;env_xstacktop - BY2PG) &amp;&amp; tf-&gt;regs[<span class="number">29</span>] &lt;= (curenv-&gt;env_xstacktop - <span class="number">1</span>))</span><br><span class="line">	&#123;	<span class="comment">//在处理缺页异常时又出现异常</span></span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] = tf-&gt;regs[<span class="number">29</span>] - <span class="keyword">sizeof</span>(struct  Trapframe);</span><br><span class="line">		bcopy(&amp;PgTrapFrame, tf-&gt;regs[<span class="number">29</span>], <span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	<span class="comment">//正常运行中第一次触发缺页异常</span></span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] = curenv-&gt;env_xstacktop - <span class="keyword">sizeof</span>(struct  Trapframe);</span><br><span class="line">		bcopy(&amp;PgTrapFrame, curenv-&gt;env_xstacktop - <span class="keyword">sizeof</span>(struct  Trapframe), <span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//设置重新开始运行的代码为处理缺页异常的</span></span><br><span class="line">	tf-&gt;cp0_epc = curenv-&gt;env_pgfault_handler;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>有关缺页异常处理的重入机制</strong></p>
<p>主要表现在<strong>栈顶指针的设置</strong>上</p>
<ol>
<li><p>正常的程序运行中出现缺页异常对应程序中<code>else</code>情况</p>
<p>此时<strong><code>tf</code>中保存的栈顶指针(即<code>tf-&gt;regs[29]</code>)应该是在<code>USTACKTOP</code>之下,即<code>normal user stack</code>区域</strong></p>
<p>在该情况下要进入缺页异常处理应该<strong>设置栈顶指针为异常处理栈指针</strong>,即<code>tf-&gt;regs[29] = curenv-&gt;env_xstacktop - sizeof(struct  Trapframe)</code></p>
</li>
<li><p>在缺页异常处过程中触发缺页异常对应程序中<code>if</code>情况</p>
<p>此时<strong><code>tf</code>中保存的栈顶指针(即<code>tf-&gt;regs[29]</code>)应该是在<code>UXSTACKTOP</code>之下,即<code>user exception stack</code>区域</strong></p>
<p>在该情况下要进入缺页异常处理应该<strong>将异常处理栈的栈指针下移即可</strong>,即<code>tf-&gt;regs[29] = tf-&gt;regs[29] - sizeof(struct  Trapframe)</code></p>
</li>
</ol>
</li>
<li><p><strong>很奇怪的一点就是这个异常处理函数处理分配异常处理栈区保存现场之外什么也没有做,真正的缺重填在哪?安装微内核设计的原则应该在用户态,但是又是怎么跳转到那里的呢?</strong></p>
<p>关键就在于<strong><code>tf-&gt;cp0_epc = curenv-&gt;env_pgfault_handler</code>, 每个进程控制块中有一项<code>env_pgfault_handler</code>该项中保存的就是请求异常处理程序的入口,通过将其设置为<code>epc</code>实现在异常处理完成恢复现场时设置重新开始运行的地方就是处理缺页异常的代码</strong></p>
</li>
</ul>
</li>
</ol>
<h5 id="缺页异常处理程序注册-用户中"><a href="#缺页异常处理程序注册-用户中" class="headerlink" title="缺页异常处理程序注册(用户中)"></a>缺页异常处理程序注册(用户中)</h5><p>由上文知我们需要 :</p>
<ul>
<li><strong>一段所有进程公用的缺页异常处理代码</strong></li>
<li>在进程建立时<strong>进行缺页异常处理程序入口的注册,即将函数入口地址赋值给<code>env-&gt;env_pgfault_handler</code></strong></li>
</ul>
<p><strong>所以<code>env_pgfault_handler</code>才是真正的处理函数</strong></p>
<p>具体流程如下 :</p>
<ol>
<li><p>在<code>fork</code>中创建子进程时调用<code>set_pgfault_handler(pgfault)</code>注册异常处理程序</p>
</li>
<li><p><code>set_pgfault_handler()</code> :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/pgfault.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_pgfault_handler</span><span class="params">(<span class="keyword">void</span> (*fn)(u_int va, u_int err))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;	</span><br><span class="line">	<span class="keyword">if</span> (__pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_alloc(<span class="number">0</span>, UXSTACKTOP - BY2PG, PTE_V|PTE_R)&lt;<span class="number">0</span> || syscall_set_pgfault_handler(<span class="number">0</span>, __asm_pgfault_handler, UXSTACKTOP)&lt;<span class="number">0</span>)</span><br><span class="line"> <span class="comment">//为异常处理分配所需的栈并且完成异常处理注册</span></span><br><span class="line">		&#123;</span><br><span class="line">			writef(<span class="string">"cannot set pgfault handler\n"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	__pgfault_handler = fn;	<span class="comment">//fn即传入的函数指针指向pgfault()函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述函数将<code>__pgfault_handler</code>的值设为<code>pafault()</code>(<strong>真正深藏不露的缺页异常处理函数</strong>)的入口地址 :</p>
<p><strong>该函数将<code>COW</code>保护的物理页复制一份并在当前进程建立映射,这要父子进程的修改就互不相干了</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/fork.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pgfault</span><span class="params">(u_int va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int temp = UTOP - <span class="number">2</span> * BY2PG;	<span class="comment">//临时使用的一个虚拟地址(使用invaild区域作为临时使用)</span></span><br><span class="line">	va = ROUNDDOWN(va,BY2PG);	<span class="comment">//要复制的目标对应的虚拟地址</span></span><br><span class="line">	u_int perm = (*vpt)[VPN(va)]&amp; <span class="number">0xfff</span>;</span><br><span class="line">	<span class="keyword">if</span>(perm &amp; PTE_COW)&#123;</span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_alloc(<span class="number">0</span>,temp,perm &amp;(~PTE_COW))&lt;<span class="number">0</span>)&#123; <span class="comment">//为临时虚拟地址temp分配一个物理页</span></span><br><span class="line">			user_panic(<span class="string">"syscall_mem_alloc error.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		user_bcopy((<span class="keyword">void</span> *)va,(<span class="keyword">void</span> *)temp,BY2PG);<span class="comment">//将va对应物理页中数据复制到temp对应的物理页中</span></span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_map(<span class="number">0</span>,temp,<span class="number">0</span>,va,perm &amp;(~PTE_COW))&lt;<span class="number">0</span>)&#123;<span class="comment">//修改va映射的物理页为temp映射的物理页</span></span><br><span class="line">			user_panic(<span class="string">"syscall_mem_map error.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_unmap(<span class="number">0</span>,temp)&lt;<span class="number">0</span>)&#123;<span class="comment">//解除临时虚拟地址temp的映射关系</span></span><br><span class="line">			user_panic(<span class="string">"syscall_mem_unmap error.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		user_panic(<span class="string">"va page is not PTE_COW.\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述函数调用了<code>syscall_set_pgfault_handler</code>,这是一个系统调用,其对应的内核中的功能代码如下 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/syscall_all.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_set_pgfault_handler</span><span class="params">(<span class="keyword">int</span> sysno, u_int envid, u_int func, u_int xstacktop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid,&amp;env,PTE_V)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_set_pgfault_handler we can't get env by envid.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	env-&gt;env_pgfault_handler = func;	<span class="comment">//设置真正的处理缺页异常的代码</span></span><br><span class="line">	env-&gt;env_xstacktop = xstacktop;		<span class="comment">//设置异常处理栈</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由上述代码我们知道真正的异常处理函数(即<code>env_pgfault_handler</code>)应该是<strong><code>__asm_pgfault_handler</code></strong> (其实里面还是通过调用<code>pgfault</code>实现 ) :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/entry.S</span></span><br><span class="line">__asm_pgfault_handler:</span><br><span class="line">nop</span><br><span class="line">	lw	a0, TF_BADVADDR(sp)</span><br><span class="line">	lw	t1, __pgfault_handler	<span class="comment">//这个函数就是pgfault()</span></span><br><span class="line">	jalr	t1</span><br><span class="line"></span><br><span class="line">nop</span><br><span class="line"><span class="comment">//异常处理结束,恢复现场</span></span><br><span class="line">	lw	v1,TF_LO(sp)                                       </span><br><span class="line">		mtlo	v1                               </span><br><span class="line">		lw	v0,TF_HI(sp)                                         </span><br><span class="line">		lw	v1,TF_EPC(sp)                    </span><br><span class="line">		mthi	v0                               </span><br><span class="line">		mtc0	v1,CP0_EPC                                             </span><br><span class="line">		lw	$<span class="number">31</span>,TF_REG31(sp)                 </span><br><span class="line">		........</span><br><span class="line">		lw	$<span class="number">1</span>,TF_REG1(sp) </span><br><span class="line">		lw	k0,TF_EPC(sp) 	</span><br><span class="line">		jr	k0			</span><br><span class="line">		lw	sp,TF_REG29(sp)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="流程图示-1"><a href="#流程图示-1" class="headerlink" title="流程图示"></a>流程图示</h4><p><img src="/2019/05/03/OS-lab4/cow.png" alt></p>
<h2 id="fork实现"><a href="#fork实现" class="headerlink" title="fork实现"></a>fork实现</h2><h3 id="fork的功能"><a href="#fork的功能" class="headerlink" title="fork的功能"></a>fork的功能</h3><ol>
<li>以父进程为模板创建一个高度相似的子进程</li>
<li>要求父子进程中<code>fork</code>函数的返回值不同<ul>
<li>在父进程中返回子进程的<code>envid</code></li>
<li>在子进程中返回0</li>
</ul>
</li>
</ol>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/entry.S</span></span><br><span class="line">vpt:</span><br><span class="line">	.word UVPT</span><br><span class="line">vpd:</span><br><span class="line">	.word (UVPT+(UVPT&gt;&gt;<span class="number">12</span>)*<span class="number">4</span>)</span><br><span class="line"><span class="comment">//user/fork.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int newenvid;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">envs</span>;</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span><span class="comment">//将其指向当前的进程，如果子进程无法创建，则指向父进程</span></span><br><span class="line">	u_int i;</span><br><span class="line">	<span class="comment">//设置缺页中断处理</span></span><br><span class="line">	set_pgfault_handler(pgfault);	</span><br><span class="line">	<span class="keyword">if</span>((newenvid = syscall_env_alloc())==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//在syscall中直接设置子进程保存现场中的返回值为0,所以实现返回值不同</span></span><br><span class="line">        <span class="comment">//即当前是子进程运行的话直接进入该分支返回</span></span><br><span class="line">		env = &amp;envs[ENVX(syscall_getenvid())];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	我们只需要将父进程中相关的用户空间的页复制到子进程用户空间即可</span></span><br><span class="line"><span class="comment">	所谓的复制实际上只是建立映射到同一物理地址的映射而已,物理数据只有一份</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	注意创建一个进程的时候会调用env_vm_init函数，这个函数中以内核页表为模板建立UTOP以上的映射,所以我们创建子进程，复制父进程的地址空间只需要复制UTOP以下的页即可(注意这里不包括异常处理栈以及invaild区域这两页)，因为所有进程UTOP以上的页都是利用boot_pgdir作为模板复制的，不需要再次复制拷贝</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">    这里的(*vpd/t)[]的用法就相当于数组下标的用法</span></span><br><span class="line"><span class="comment">    (*vpd)[i]为第i个页目录项</span></span><br><span class="line"><span class="comment">    (*vpt)[i]为第i个页表项</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; UTOP - <span class="number">2</span> * BY2PG) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((*vpd)[VPN(i)/<span class="number">1024</span>] &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">            i += <span class="number">1024</span> * BY2PG;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (((*vpt)[VPN(i)] &amp; PTE_V) ==<span class="number">0</span> ) &#123;</span><br><span class="line">        	i += BY2PG;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        duppage(newenvid,VPN(i));</span><br><span class="line">        i += BY2PG;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//搭建异常处理栈，分配一个页，让别的进程不抢占此页</span></span><br><span class="line">	<span class="keyword">if</span>(syscall_mem_alloc(newenvid,UXSTACKTOP-BY2PG,PTE_V|PTE_R)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		user_panic(<span class="string">"failed alloc UXSTACK.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//帮助子进程注册错误处理函数</span></span><br><span class="line">	<span class="keyword">if</span>(syscall_set_pgfault_handler(newenvid,__asm_pgfault_handler,UXSTACKTOP)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		user_panic(<span class="string">"page fault handler setup failed.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//至此子进程可以进行调度运行了</span></span><br><span class="line">	syscall_set_env_status(newenvid,ENV_RUNNABLE);</span><br><span class="line">	writef(<span class="string">"OK! newenvid is:%d\n"</span>,newenvid);</span><br><span class="line">	<span class="keyword">return</span> newenvid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>duppage</code>函数 :</p>
<p>该函数作用 : </p>
<ul>
<li>建立子进程中到共享物理页的映射</li>
<li>将可写入的共享区域的页用<code>COW</code>的权限位保护起来</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/fork.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">duppage</span><span class="params">(u_int envid, u_int pn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int perm;</span><br><span class="line">	perm = (*vpt)[pn] &amp; <span class="number">0xfff</span>; <span class="comment">//取出标记位</span></span><br><span class="line">	<span class="keyword">if</span>((((perm &amp; PTE_R) !=<span class="number">0</span>) || ((perm &amp; PTE_COW)!=<span class="number">0</span>)) &amp;&amp; (perm &amp; PTE_V))&#123;</span><br><span class="line">		<span class="keyword">if</span>(perm &amp; PTE_LIBRARY)&#123;</span><br><span class="line">			perm = PTE_V | PTE_R | PTE_LIBRARY;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			perm = PTE_V | PTE_R | PTE_COW;</span><br><span class="line">		&#125;</span><br><span class="line">       	<span class="comment">//以保护权限建立子进程到共享物理页的映射</span></span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_map(<span class="number">0</span>,pn*BY2PG,envid,pn*BY2PG,perm)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			user_panic(<span class="string">"syscall_mem_map for son failed.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//在父进程中对共享物理页做权限保护</span></span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_map(<span class="number">0</span>,pn*BY2PG,<span class="number">0</span>,pn*BY2PG,perm)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			user_panic(<span class="string">"syscall_mem_map for father failed.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_map(<span class="number">0</span>,pn*BY2PG,envid,pn*BY2PG,perm)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			user_panic(<span class="string">"syscall_mem_map for son failed.1\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fork图示"><a href="#fork图示" class="headerlink" title="fork图示"></a>fork图示</h3><p><img src="/2019/05/03/OS-lab4/fork.png" alt></p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过所有进程共享的内核空间中的进程控制块结构<code>envs[]</code>来实现不同进程之间的传递数据(即通信)</p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><ol>
<li><p><code>env</code>控制块中的对应该功能的数据域</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/env.h</span></span><br><span class="line">    u_int env_ipc_value;            <span class="comment">// 进程间要传递的数据</span></span><br><span class="line">	u_int env_ipc_from;             <span class="comment">// 发送信息到该进程的源进程</span></span><br><span class="line">	u_int env_ipc_recving;          <span class="comment">// 为1表示该进程在等待接受信息状态</span></span><br><span class="line">	u_int env_ipc_dstva;		   <span class="comment">// 该进程进程间的共享物理页面映射到的虚拟地址</span></span><br><span class="line">	u_int env_ipc_perm;			   <span class="comment">// 建立映射的权限位</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接受信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/syscall_all.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_ipc_recv</span><span class="params">(<span class="keyword">int</span> sysno, u_int dstva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//检查地址有效性</span></span><br><span class="line">	<span class="keyword">if</span>(dstva&gt;=UTOP)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_ipc_recv the dstva %x need &lt; UTOP %x\n"</span>,dstva,UTOP);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	curenv-&gt;env_ipc_recving = <span class="number">1</span>;	<span class="comment">//设置该进程未等待接受信息状态</span></span><br><span class="line">	curenv-&gt;env_ipc_dstva = dstva;	<span class="comment">//设置将共享共享物理页映射到的虚拟地址</span></span><br><span class="line">	curenv-&gt;env_status = ENV_NOT_RUNNABLE;	<span class="comment">//阻塞该进程,等待接受信息之后才能继续运行</span></span><br><span class="line">	sys_yield();	<span class="comment">//调度其他进程给该进程发送信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/syscall_all.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_ipc_can_send</span><span class="params">(<span class="keyword">int</span> sysno, u_int envid, u_int value, u_int srcva, u_int perm)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 参数含义 :</span></span></span><br><span class="line"><span class="function"><span class="comment">   1. envid为要发送信息的目标进程的进程号</span></span></span><br><span class="line"><span class="function"><span class="comment">   2. value为要传递的数据信息</span></span></span><br><span class="line"><span class="function"><span class="comment">   3. srcva为要共享的物理页在该进程(发送进程)中映射到的虚拟地址</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">	Pte *ppte;</span><br><span class="line">	<span class="keyword">if</span>(srcva&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"in sys_ipc_can_send found va is 0\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(srcva&gt;=UTOP)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_ipc_can_send srcva %x need &lt;UTOP %x.\n"</span>,srcva,UTOP);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid,&amp;e,<span class="number">0</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_ipc_can_send the envid can't found the env.envid is:%d\n"</span>,envid);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(e-&gt;env_ipc_recving==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_ipc_can_send we found env_ipc_recving is 0.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((p=page_lookup(curenv-&gt;env_pgdir,srcva,<span class="number">0</span>))&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"send srcva is not exist.srcva is:%x\n"</span>,srcva);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(page_insert(e-&gt;env_pgdir,p,e-&gt;env_ipc_dstva,perm)&lt;<span class="number">0</span>)&#123; <span class="comment">//建立目标进程中共享物理页面的映射</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"dst pot failed.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	e-&gt;env_ipc_perm = perm|PTE_V|PTE_R;</span><br><span class="line">	e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">	e-&gt;env_status = ENV_RUNNABLE;	<span class="comment">//目标进程接受到信息,可以继续运行</span></span><br><span class="line">	e-&gt;env_ipc_value = value;		<span class="comment">//写入要传递的数据</span></span><br><span class="line">	e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="通信图示"><a href="#通信图示" class="headerlink" title="通信图示"></a>通信图示</h3><p><img src="/2019/05/03/OS-lab4/ipc.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/13/OS-lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/13/OS-lab3/" itemprop="url">OS-lab3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-13T08:02:53+08:00">
                2019-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="env进程结构管理"><a href="#env进程结构管理" class="headerlink" title="env进程结构管理"></a>env进程结构管理</h1><p>先给大家安利一个神器：<code>Understand</code>，有了它，妈妈再也不担心我源码看吐了</p>
<p>首先神图镇楼</p>
<p><img src="/2019/04/13/OS-lab3/mm.png" alt></p>
<h2 id="一点与lab3无关的"><a href="#一点与lab3无关的" class="headerlink" title="一点与lab3无关的"></a>一点与lab3无关的</h2><p><strong>在刚开始时，我个人一直疑惑的一个问题便是什么是OS的工作，而什么是硬件支持的工作，这个问题其实我现在还不是很清楚，下面写一点我的拙见：</strong></p>
<ol>
<li><p>关于地址：</p>
<ul>
<li>页表项的填写是要操作系统来负责的，即在代码中显式填写</li>
<li>在代码中给一个虚拟地址来访问数据是由硬件支持的，并且他可以判断在<code>ULIM</code>上硬件就直接最高位置0然后访问，如果在下面就通过页表查找访问</li>
</ul>
<p><strong>这就解释了我们许多地方的地址变化看似功能上不是内核中的事，但是我们的虚拟地址都是用内核中才满足的转换函数，其实我个人认为就是由于我们页表结构还没填好所以暂时建立一个映射而已，其作用只是一个访问的作用而已，等利用他把页表建立好它也就没用了</strong></p>
</li>
<li><p>关于中断：</p>
<ul>
<li>在时间片用完之后硬件产生时间中断，跳转PC值</li>
<li>操作系统要负责记录当前进程的上下文，并且构建将要调度执行的进程的上下文（其实还要设置一大堆CPU的状态寄存器）</li>
</ul>
</li>
<li><p>……..</p>
</li>
</ol>
<h2 id="基本常数定义"><a href="#基本常数定义" class="headerlink" title="基本常数定义"></a>基本常数定义</h2><h3 id="最大进程数目"><a href="#最大进程数目" class="headerlink" title="最大进程数目"></a>最大进程数目</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG2NENV	10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NENV		(1&lt;&lt;LOG2NENV)</span></span><br></pre></td></tr></table></figure>
<p>即最多有2^10即1024个进程</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENV_FREE	0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENV_RUNNABLE		1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENV_NOT_RUNNABLE	2</span></span><br></pre></td></tr></table></figure>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><h3 id="env进程管理块"><a href="#env进程管理块" class="headerlink" title="env进程管理块"></a>env进程管理块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span> 	   <span class="comment">// 保存进程切换前后的寄存器值（即所谓的保存上下文）</span></span><br><span class="line">	LIST_ENTRY(Env) env_link;	   <span class="comment">// 在空闲进程队列env_free_list中链接下一项的指针</span></span><br><span class="line">	u_int env_id;                  <span class="comment">// 进程id号（每个进程的唯一标识）</span></span><br><span class="line">	u_int env_parent_id;           <span class="comment">// 父进程的id号 </span></span><br><span class="line">	u_int env_status;              <span class="comment">// 进程的状态</span></span><br><span class="line">	Pde  *env_pgdir;               <span class="comment">// 进程的页目录的内核中的起始虚拟地址 </span></span><br><span class="line">	u_int env_cr3;				  <span class="comment">// 进程的页目录的起始物理地址（即cr3寄存器中存储的值）</span></span><br><span class="line">	LIST_ENTRY(Env) env_sched_link;<span class="comment">// 在调度队列env_sched_list中链接下一项的指针</span></span><br><span class="line">	u_int env_pri;				  <span class="comment">// 进程的优先级，定义为进程可用的时间片个数</span></span><br><span class="line">    <span class="comment">// 之后的lab4再补充以下结构</span></span><br><span class="line">	u_int env_ipc_value;           </span><br><span class="line">	u_int env_ipc_from;           </span><br><span class="line">	u_int env_ipc_recving;        </span><br><span class="line">	u_int env_ipc_dstva;		</span><br><span class="line">	u_int env_ipc_perm;		</span><br><span class="line">	u_int env_pgfault_handler;    </span><br><span class="line">	u_int env_xstacktop;          </span><br><span class="line">	u_int env_runs;		</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">// 数据结构展开</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span> </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> regs[<span class="number">32</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cp0_status;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> hi;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> lo;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cp0_badvaddr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cp0_cause;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cp0_epc;	<span class="comment">//中断异常时执行的指令地址</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pc;		<span class="comment">//在进程切换回来时应该开始执行的地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_ENTRY(type)						\</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>								\</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">le_next</span>;</span>	<span class="comment">/* next element */</span>			\</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">type</span> **<span class="title">le_prev</span>;</span>	<span class="comment">/* address of previous next element */</span>	\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="env-free-list"><a href="#env-free-list" class="headerlink" title="env_free_list"></a>env_free_list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env_list</span> <span class="title">env_free_list</span>;</span></span><br></pre></td></tr></table></figure>
<p>该结构的作用将<strong>待分配</strong>的空闲<code>env</code>控制块串成链表形式，该链表中的<code>env</code>控制块都是<strong><code>ENV_FREE</code>状态</strong></p>
<h3 id="env-sched-list"><a href="#env-sched-list" class="headerlink" title="env_sched_list"></a>env_sched_list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env_list</span> <span class="title">env_sched_list</span>[2];</span></span><br></pre></td></tr></table></figure>
<p>该结构的作用是将已经处于<strong>可运行状态</strong>的<code>env</code>控制块串成链表形式以便调度程序来调度运行（<strong>本质上就是分配给时间片</strong>），该链表中的<code>env</code>控制块都是<strong><code>ENV_RUNNABLE</code>状态</strong></p>
<p>具体使用详见进程调度算法</p>
<h3 id="进程的状态转移"><a href="#进程的状态转移" class="headerlink" title="进程的状态转移"></a>进程的状态转移</h3><p><img src="/2019/04/13/OS-lab3/env_status.png" alt></p>
<p>注 ： <strong>对用户而言只能调用<code>create</code>,不能使用<code>alloc</code>所以在其看来进程一旦创建便处于可执行状态了</strong></p>
<p>？？或者在<code>env_alloc</code>中设置为<code>ENV_NOT_RUNNABLE</code>,把设置<code>status = ENV_RUNNABLE</code>放在<code>create</code>层次其实更好？？</p>
<p><strong>此处有个坑(测试杀我) ： 评测函数env_check()中会调用env_alloc()，所以会创建一堆只建立了页表但是没有加载可执行文件的残疾进程，所以如果你在调度时只是简单的判断是否是<code>RUNNABLE</code>状态，则会让这些进程运行，然后就会报<code>TOO LOW</code>的错误</strong></p>
<h2 id="对进程的操作"><a href="#对进程的操作" class="headerlink" title="对进程的操作"></a>对进程的操作</h2><h3 id="初始化控制结构"><a href="#初始化控制结构" class="headerlink" title="初始化控制结构"></a>初始化控制结构</h3><h4 id="构建控制块数组"><a href="#构建控制块数组" class="headerlink" title="构建控制块数组"></a>构建控制块数组</h4><ol>
<li><p>函数实现</p>
<p><strong>该函数的流程与物理内存控制块<code>pages</code>的构建流程基本一样</strong></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pmap.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mips_vm_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// code</span></span><br><span class="line">	envs = (struct Env *)alloc(NENV * <span class="keyword">sizeof</span>(struct Env), BY2PG, <span class="number">1</span>);</span><br><span class="line">    n = ROUND(NENV * <span class="keyword">sizeof</span>(struct Env), BY2PG);</span><br><span class="line">    boot_map_segment(pgdir, UENVS, n, PADDR(envs), PTE_R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>图示分析</p>
<p><img src="/2019/04/13/OS-lab3/envs.png" alt></p>
</li>
</ol>
<h4 id="初始化控制结构-1"><a href="#初始化控制结构-1" class="headerlink" title="初始化控制结构"></a>初始化控制结构</h4><ol>
<li>函数实现</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 初始化空闲进程块链表</span></span><br><span class="line">	LIST_INIT(&amp;env_free_list);</span><br><span class="line">    <span class="comment">// 初始化待调度进程控制块链表</span></span><br><span class="line">	LIST_INIT(&amp;env_sched_list[<span class="number">0</span>]);</span><br><span class="line">	LIST_INIT(&amp;env_sched_list[<span class="number">1</span>]);</span><br><span class="line">	<span class="comment">// 初始时所有的进程控制块都是空闲的</span></span><br><span class="line">	<span class="keyword">for</span>(i=NENV<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		envs[i].env_status = ENV_FREE;</span><br><span class="line">		LIST_INSERT_HEAD(&amp;env_free_list,&amp;envs[i],env_link);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建一个进程"><a href="#创建一个进程" class="headerlink" title="创建一个进程"></a>创建一个进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_create_priority</span><span class="params">(u_char *binary, <span class="keyword">int</span> size, <span class="keyword">int</span> priority)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="comment">//分配进程控制块</span></span><br><span class="line">	<span class="keyword">if</span>(env_alloc(&amp;e,<span class="number">0</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,env can't create because alloc env failed!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//设计进程优先级，在我们的系统中即是一次可以使用的时间片个数</span></span><br><span class="line">	e-&gt;env_pri = priority；</span><br><span class="line">    <span class="comment">//加载二进制镜像</span></span><br><span class="line">	load_icode(e,binary,size);</span><br><span class="line">    <span class="comment">//将加载完之后的进程加入等待被调度的链表中</span></span><br><span class="line">	LIST_INSERT_HEAD(&amp;env_sched_link[<span class="number">0</span>], &amp;e, env_sched_link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数调用分析"><a href="#函数调用分析" class="headerlink" title="函数调用分析"></a>函数调用分析</h4><p><img src="/2019/04/13/OS-lab3/create_call.png" alt></p>
<h4 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h4><h5 id="分配进程所需资源"><a href="#分配进程所需资源" class="headerlink" title="分配进程所需资源"></a>分配进程所需资源</h5><p>即函数<code>env_alloc()</code>的作用，分配进程运行的必需资源，详细分析如下：</p>
<ol>
<li><p>函数流程 ：</p>
<ol>
<li>从进程控制块空闲链表中取出一个</li>
<li><strong>使用<code>snv_setup_vm</code>分配空间资源</strong></li>
<li>填写控制块中的各项数值</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">env_alloc</span><span class="params">(struct Env **<span class="keyword">new</span>, u_int parent_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="comment">// 从空闲进程块中分配一个控制块</span></span><br><span class="line">	<span class="keyword">if</span>((e=LIST_FIRST(&amp;env_free_list))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,alloc env failed!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 为进程分配运行必需的空间资源</span></span><br><span class="line">	env_setup_vm(e);</span><br><span class="line">    <span class="comment">// 填写控制块的项</span></span><br><span class="line">	e-&gt;env_parent_id = parent_id;</span><br><span class="line">	e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	e-&gt;env_runs = <span class="number">0</span>;</span><br><span class="line">	e-&gt;env_id = mkenvid(e);			    <span class="comment">//生成唯一的进程标识符</span></span><br><span class="line">    e-&gt;env_tf.cp0_status = <span class="number">0x10001004</span>;</span><br><span class="line">	e-&gt;env_tf.regs[<span class="number">29</span>] = USTACKTOP;		<span class="comment">//填写栈寄存器</span></span><br><span class="line">	<span class="comment">// 将使用过的控制块从空闲链表中移除</span></span><br><span class="line">	*<span class="keyword">new</span> = e;</span><br><span class="line">	LIST_REMOVE(e,env_link);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重点说明 ：</p>
<ol>
<li><p><code>env_setup_vm()</code>函数 ：</p>
<p>该函数作用是建立进程的页目录结构</p>
<p>注意点 ：</p>
<ul>
<li>对进程页目录的初始化（一部分来自拷贝了内核页目录）</li>
<li><strong>自映射机制的构建</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">env_setup_vm</span><span class="params">(struct Env *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	Pde *pgdir;</span><br><span class="line">    <span class="comment">// 给进程的页目录分配一个物理页</span></span><br><span class="line">	<span class="keyword">if</span> ((r = page_alloc(&amp;p)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		panic(<span class="string">"env_setup_vm - page_alloc error\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;pp_ref++;</span><br><span class="line">	pgdir = (Pde *)page2kva(p);<span class="comment">//将分配的物理页映射到kseg0中的一个虚拟地址方便之后填写</span></span><br><span class="line">  	<span class="comment">/* 之后的工作是对这个进程的页表中的项进行填写</span></span><br><span class="line"><span class="comment">  	 * 注意填写要区分</span></span><br><span class="line"><span class="comment">  	 * 1.没有在内核页表中完成映射的虚拟空间（UTOP向下：用户堆栈区) : 清空初始化</span></span><br><span class="line"><span class="comment">  	 * 2.已经在内核页表中映射好的虚拟空间（UTOP向上：ENVS,PAGES,USER VPT, kseg） ： 拷贝内核中对应页表项</span></span><br><span class="line"><span class="comment">  	 * 注：ENV,PAGES的映射是在mips_vm_init中通过boot_map_segment实现的</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PDX(UTOP); i++) &#123;</span><br><span class="line">		pgdir[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (i = PDX(UTOP); i &lt;= PDX(~<span class="number">0</span>); i++) &#123;</span><br><span class="line">		pgdir[i] = boot_pgdir[i];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 填写控制块信息</span></span><br><span class="line">	e-&gt;env_pgdir = pgdir;	<span class="comment">//进程页目录的起始虚拟内核地址</span></span><br><span class="line">	e-&gt;env_cr3   = PADDR(pgdir); <span class="comment">//进程页目录的起始物理地址</span></span><br><span class="line">	<span class="comment">// 之后的两条语句完成自映射机制</span></span><br><span class="line">    e-&gt;env_pgdir[PDX(VPT)]   = e-&gt;env_cr3 | PTE_V;<span class="comment">//将（进程页目录的起始物理地址）以（只读的权限）写入页目录中（内核空间的页目录起始虚拟地址VPT）对应的项</span></span><br><span class="line">    e-&gt;env_pgdir[PDX(UVPT)]  = e-&gt;env_cr3 | PTE_V | PTE_R;<span class="comment">//将（进程页目录的起始物理地址）以（读写的权限）写入页目录中（用户空间的页目录起始虚拟地址UVPT）对应的项</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>mkenvid()</code>函数</p>
<p>该函数的作用是生成唯一的进程标识符</p>
<ul>
<li><p>生成标识符 ：标识符分为两段</p>
<ul>
<li><p>使用<code>next_env_id</code>静态递增变量来<strong>保证不同进程的进程号一定不同</strong></p>
<p>占据高位段</p>
</li>
<li><p>使用<code>idx</code>即该进程控制块在<code>envs[]</code>的数组下标段来<strong>保证可以从进程号获得<code>env</code>控制块</strong></p>
<p>占据低11位段（因为只有1024项）</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function">u_int <span class="title">mkenvid</span><span class="params">(struct Env *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> u_long next_env_id = <span class="number">0</span>;</span><br><span class="line">	u_int idx = e - envs;</span><br><span class="line">    <span class="comment">//拼接两部分</span></span><br><span class="line">	<span class="keyword">return</span> (++next_env_id &lt;&lt; (<span class="number">1</span> + LOG2NENV)) | idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">envid2env</span><span class="params">(u_int envid, struct Env **penv, <span class="keyword">int</span> checkperm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="comment">//当前第一个进程还未创建其他进程</span></span><br><span class="line">	<span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">		*penv = curenv;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//依据低11位来取出index获得env结构体</span></span><br><span class="line">	e = &amp;envs[ENVX(envid)];</span><br><span class="line">    <span class="comment">//该进程未使用，</span></span><br><span class="line">    <span class="comment">//或者唯一进程标识符不同，</span></span><br><span class="line">    <span class="comment">//则取进程失败</span></span><br><span class="line">	<span class="keyword">if</span> (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid) &#123;</span><br><span class="line">		*penv = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//取出进程不是由当前进程创建的，即父子关系不对，则取出失败</span></span><br><span class="line">    <span class="keyword">if</span> (checkperm &amp;&amp; e != curenv &amp;&amp; e-&gt;env_parent_id != curenv-&gt;env_id)&#123;</span><br><span class="line">        *penv = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">	*penv = e;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>e-&gt;env_tf.cp0_status = 0x10001004;</code>语句：</p>
<p>待施工….。</p>
</li>
</ol>
</li>
</ol>
<h5 id="加载二进制映像"><a href="#加载二进制映像" class="headerlink" title="加载二进制映像"></a>加载二进制映像</h5><p>即函数<code>load_icode(struct Env *e, u_char *binary, u_int size)</code>的作用 ：</p>
<ol>
<li><p>函数流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_icode</span><span class="params">(struct Env *e, u_char *binary, u_int size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	u_long entry_point;</span><br><span class="line">	u_long r;</span><br><span class="line">    u_long perm;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span>(page_alloc(&amp;p)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,alloc page failed!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//为用户栈空间分配一页物理内存并完成从[USTACKTOP-BY2PG, USTACKTOP]到分配物理空间的二级页结构映射</span></span><br><span class="line">    <span class="comment">//即构建进程的运行栈空间</span></span><br><span class="line">	perm = PTE_V|PTE_R;</span><br><span class="line">	page_insert(e-&gt;env_pgdir,p,USTACKTOP-BY2PG,perm);</span><br><span class="line">    <span class="comment">//加载二进文件</span></span><br><span class="line">    r = load_elf(binary,size,&amp;entry_point,e,load_icode_mapper);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry.load entire image failed!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	e-&gt;env_tf.pc = entry_point;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>重点说明</p>
<ol>
<li><p><code>load_elf()</code>函数 ：</p>
<ul>
<li><p>参数含义 ：</p>
<ul>
<li><code>binary</code> ：待加载的二级制<code>ELF</code>文件的起始虚拟地址</li>
<li><code>size</code> ： <code>ELF</code>文件的字节数目</li>
<li><code>entry_point</code> ：程序的入口地址</li>
<li><code>*map</code>：函数指针，在此处即是调用<code>load_icode_mapper()</code></li>
</ul>
</li>
<li><p>函数作用 ：</p>
<p><strong>解析<code>ELF</code>文件头信息</strong>并把它加载到指定的虚拟内存区域，并建立对物理空间的二级页表映射</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel_elfloader.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">load_elf</span><span class="params">(u_char *binary, <span class="keyword">int</span> size, u_long *entry_point, <span class="keyword">void</span> *user_data,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">int</span> (*<span class="built_in">map</span>)(u_long va, <span class="keyword">u_int32_t</span> sgsize,</span></span></span><br><span class="line"><span class="function"><span class="params">						u_char *bin, <span class="keyword">u_int32_t</span> bin_size, <span class="keyword">void</span> *user_data))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//解析ELF文件头的信息（具体结构在下文）</span></span><br><span class="line">	Elf32_Ehdr *ehdr = (Elf32_Ehdr *)binary;</span><br><span class="line">	Elf32_Phdr *phdr = <span class="literal">NULL</span>;</span><br><span class="line">	u_char *ptr_ph_table = <span class="literal">NULL</span>;</span><br><span class="line">	Elf32_Half ph_entry_count;</span><br><span class="line">	Elf32_Half ph_entry_size;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="comment">//判断ELF文件是否合法</span></span><br><span class="line">	<span class="keyword">if</span> (size &lt; <span class="number">4</span> || !is_elf_format(binary)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获得segment结构头的起始地址指针</span></span><br><span class="line">	ptr_ph_table = binary + ehdr-&gt;e_phoff;</span><br><span class="line">    <span class="comment">//获得segment段的数目</span></span><br><span class="line">	ph_entry_count = ehdr-&gt;e_phnum;</span><br><span class="line">    <span class="comment">//获得一个segment结构头的大小</span></span><br><span class="line">	ph_entry_size = ehdr-&gt;e_phentsize;</span><br><span class="line">	<span class="comment">//遍历所有segment结构头</span></span><br><span class="line">	<span class="keyword">while</span> (ph_entry_count--) &#123;</span><br><span class="line">		phdr = (Elf32_Phdr *)ptr_ph_table;</span><br><span class="line">        <span class="comment">//如果该segment的类型是加载类型</span></span><br><span class="line">		<span class="keyword">if</span> (phdr-&gt;p_type == PT_LOAD) &#123;</span><br><span class="line">            <span class="comment">//将该segment段加载到其头结构指出的虚拟地址空间并建立二级页表映射</span></span><br><span class="line">			r = <span class="built_in">map</span>(phdr-&gt;p_vaddr, phdr-&gt;p_memsz,</span><br><span class="line">					binary + phdr-&gt;p_offset, phdr-&gt;p_filesz, user_data);</span><br><span class="line">			<span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> r;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//指下一个segment结构头</span></span><br><span class="line">		ptr_ph_table += ph_entry_size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 程序入口地址</span></span><br><span class="line">	*entry_point = ehdr-&gt;e_entry;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>load_icode_mapper()</code>函数 ：</p>
<ul>
<li><p>参数含义 ：</p>
<ul>
<li><code>va</code> : 该段要加载到的虚拟地址</li>
<li><code>sgsize</code> : 该段在内存中的大小</li>
<li><code>bin</code> : 该段在<code>ELF</code>文件中的内容的起始地址</li>
<li><code>bin_size</code> : 该段在文件中的大小</li>
</ul>
</li>
<li><p>函数作用 ：</p>
<p><strong>将<code>ELF</code>文件中的一个<code>segment</code>加载到指定的虚拟地址处并建立好对应的二级页表映射（主要通过<code>page_inset</code>建立），若内存中大小比在文件中大，则多余的位用0补</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_icode_mapper</span><span class="params">(u_long va, <span class="keyword">u_int32_t</span> sgsize,</span></span></span><br><span class="line"><span class="function"><span class="params">							 u_char *bin, <span class="keyword">u_int32_t</span> bin_size, <span class="keyword">void</span> *user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span> = (<span class="title">struct</span> <span class="title">Env</span> *)<span class="title">user_data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	u_long i;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">    <span class="comment">//获得va在其所在页中的偏移offset</span></span><br><span class="line">	u_long offset = va - ROUNDDOWN(va, BY2PG);</span><br><span class="line">	<span class="comment">//为二进制文件分配存储的物理页</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; bin_size; i += BY2PG) &#123;</span><br><span class="line">		<span class="keyword">if</span>(page_alloc(&amp;p)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Sorry,alloc page failed!\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;pp_ref++;</span><br><span class="line">        <span class="comment">//void bcopy(const void *src, void *dst, size_t len)</span></span><br><span class="line">        <span class="comment">//从src（虚拟源地址）复制len个字节到dst(虚拟目标地址)</span></span><br><span class="line">        <span class="comment">//下面的两个copy不好理解，具体看下图</span></span><br><span class="line">        <span class="comment">//总的来说，就是比较剩下待拷贝的数据大小与页的大小来决定拷贝的数据量，然后逐页拷贝</span></span><br><span class="line">        <span class="comment">//对第一个分配的页，可能页不从首地址开始，所以要特殊考虑</span></span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">			bcopy(bin,(<span class="keyword">char</span> *)page2kva(p)+offset,((BY2PG-offset)&lt;bin_size-i)?(BY2PG-offset):(bin_size - i));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			bcopy(bin+i-offset,(<span class="keyword">char</span> *)page2kva(p),(BY2PG&lt;bin_size-i+offset)?BY2PG:(bin_size-i+offset));</span><br><span class="line">        <span class="comment">//拷贝完之后p对应物理页中存储二进制数据</span></span><br><span class="line">        <span class="comment">//然后以读写的权限通过该进程的页表将va+i（即当前一页二进制数据应该加载到虚拟地址）映射到p对应的物理页上</span></span><br><span class="line">		r = page_insert(env-&gt;env_pgdir,p,va+i,PTE_V|PTE_R);</span><br><span class="line">		<span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Sorry,insert a page is failed!\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//当该segment在内存中的大小大于在文件中时</span></span><br><span class="line">    <span class="comment">//给多余的地址空间赋值为0（在page_alloc()中就已经清0） </span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; sgsize) &#123;</span><br><span class="line">		<span class="keyword">if</span>(page_alloc(&amp;p)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Sorry,alloc page failed!\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;pp_ref++;</span><br><span class="line">		r = page_insert(env-&gt;env_pgdir,p,va+i,PTE_V|PTE_R);</span><br><span class="line">		<span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Sorry,alloc page failed!\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">		&#125;</span><br><span class="line">		i+=BY2PG;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>图示</strong></p>
<ul>
<li><p><code>ELF</code>文件结构示意图</p>
<p><img src="/2019/04/13/OS-lab3/ELF.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ELF文件头结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	e_ident[EI_NIDENT];	<span class="comment">/* Magic number and other info */</span></span><br><span class="line">	Elf32_Half	e_type;			<span class="comment">/* Object file type */</span></span><br><span class="line">	Elf32_Half	e_machine;		<span class="comment">/* Architecture */</span></span><br><span class="line">	Elf32_Word	e_version;		<span class="comment">/* Object file version */</span></span><br><span class="line">	Elf32_Addr	e_entry;		<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">	Elf32_Off	e_phoff;		<span class="comment">/* Program header table file offset */</span></span><br><span class="line">	Elf32_Off	e_shoff;		<span class="comment">/* Section header table file offset */</span></span><br><span class="line">	Elf32_Word	e_flags;		<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">	Elf32_Half	e_ehsize;		<span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">	Elf32_Half	e_phentsize;	<span class="comment">/* Program header table entry size */</span></span><br><span class="line">	Elf32_Half	e_phnum;		<span class="comment">/* Program header table entry count */</span></span><br><span class="line">	Elf32_Half	e_shentsize;	<span class="comment">/* Section header table entry size */</span></span><br><span class="line">	Elf32_Half	e_shnum;		<span class="comment">/* Section header table entry count */</span></span><br><span class="line">	Elf32_Half	e_shstrndx;		<span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个segment结构头的结构，其管理一份segment段</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Elf32_Word	p_type;			<span class="comment">/* Segment type */</span></span><br><span class="line">	Elf32_Off	p_offset;		<span class="comment">/* Segment file offset */</span></span><br><span class="line">	Elf32_Addr	p_vaddr;		<span class="comment">/* Segment virtual address */</span></span><br><span class="line">	Elf32_Addr	p_paddr;		<span class="comment">/* Segment physical address */</span></span><br><span class="line">	Elf32_Word	p_filesz;		<span class="comment">/* Segment size in file */</span></span><br><span class="line">	Elf32_Word	p_memsz;		<span class="comment">/* Segment size in memory */</span></span><br><span class="line">	Elf32_Word	p_flags;		<span class="comment">/* Segment flags */</span></span><br><span class="line">	Elf32_Word	p_align;		<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载一个<code>segment</code>的示意图</p>
<p><img src="/2019/04/13/OS-lab3/segment1.png" alt></p>
<p><img src="/2019/04/13/OS-lab3/segment2.png" alt></p>
<p><img src="/2019/04/13/OS-lab3/segment3.png" alt></p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h3><p>主要使用<code>env_run(e)</code>方法运行线程e ：</p>
<ul>
<li>函数流程 ：<ol>
<li>从内存中取出当前线程（<code>curenv</code>）保存上下文的地方</li>
<li>将上下文信息存入当前线程（<code>curenv</code>）的控制块的<code>env_tf</code>结构中以便他切走</li>
<li>设置<code>e</code>为当前进程，并加载<code>e</code>进程的上下文信息</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMESTACK 0x82000000</span></span><br><span class="line"><span class="comment">//由当前进程切换到e进程执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_run</span><span class="params">(struct Env *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//old即为当前进程进程的上下文存储的地方</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> *<span class="title">old</span> = (<span class="title">struct</span> <span class="title">Trapframe</span> *)(<span class="title">TIMESTACK</span>-<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trapframe</span>));</span></span><br><span class="line">	<span class="keyword">if</span>(curenv)&#123;</span><br><span class="line">        <span class="comment">//将当前进程的上下文保存其进程控制块的的env_tf结构体变量中</span></span><br><span class="line">		bcopy(old,&amp;(curenv-&gt;env_tf),<span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">        <span class="comment">/* 填写存储进程再次切换回来时应该开始执行的指令地址</span></span><br><span class="line"><span class="comment">         * 我们的进程切换时由于分配时间片使用完之后导致的时钟中断</span></span><br><span class="line"><span class="comment">         * cp0_epc存储的是产生中断时的执行指令地址</span></span><br><span class="line"><span class="comment">         * 所以它就是我们进程再次切回时应该执行的指令，将其保存在env_tf。pc中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		curenv-&gt;env_tf.pc = old-&gt;cp0_epc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将当前进程切换到e</span></span><br><span class="line">	curenv = e;</span><br><span class="line">	curenv-&gt;env_runs ++;</span><br><span class="line">	<span class="comment">//（即切换页目录）加载要运行进程的页目录（env_cr3中保存了页目录的起始物理地址)</span></span><br><span class="line">	lcontext(KADDR(curenv-&gt;env_cr3));	</span><br><span class="line">    <span class="comment">//加载当前要运行的进程的上下文</span></span><br><span class="line">	env_pop_tf(&amp;(curenv-&gt;env_tf),GET_ENV_ASID(curenv-&gt;env_id));	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>分析<code>lcontext(KADDR(curenv-&gt;env_cr3))</code></p>
<p><strong>该函数的所用其实是加载要运行的进程的页目录虚拟地址到<code>mCONTEXT</code>这个全局变量中，其实也是构造进程运行环境的一部分</strong></p>
<p>让我们先追踪溯源 ：</p>
<ol>
<li><p><code>lcontext</code>的函数定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env_asm.S</span></span><br><span class="line">LEAF(lcontext)</span><br><span class="line">		.<span class="keyword">extern</span>	mCONTEXT</span><br><span class="line">		<span class="comment">//该操作即是将该进程的页目录的内核虚拟地址存入mCONTEXT中</span></span><br><span class="line">		sw		a0,mCONTEXT<span class="comment">//a0代表第一个参数，即为KADDR(curenv-&gt;cr3)</span></span><br><span class="line">		jr	ra</span><br><span class="line">		nop</span><br><span class="line">END(lcontext)</span><br></pre></td></tr></table></figure>
</li>
<li><p>出现了变量<code>mCONTEXT</code>我们继续来追踪溯源 ：</p>
<ul>
<li><p>定义处 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//start.S第45行</span></span><br><span class="line">			.globl mCONTEXT</span><br><span class="line">mCONTEXT:</span><br><span class="line">   			.word <span class="number">0</span><span class="comment">//即初值为0的一个字大小的全局变量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用处 ：我们目前只关注在这之前改变他值的操作，暂时不关心使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pmap.c第160行</span></span><br><span class="line">pgdir = alloc(BY2PG, BY2PG, <span class="number">1</span>);</span><br><span class="line">mCONTEXT = (<span class="keyword">int</span>)pgdir;<span class="comment">//mCONTEXT中保存的是内核中的页目录的起始内核虚拟地址</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><p>分析<code>env_pop_tf(&amp;(curenv-&gt;env_tf),GET_ENV_ASID(curenv-&gt;env_id));</code></p>
<p><strong>该函数的作用是构造要运行的进程的上下文环境，即从它的<code>env_tf</code>中取出上一次执行到结束时的环境，然后赋值给当前的运行环境，保证和上一次运行衔接</strong></p>
<ul>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env_asm.S第15行</span></span><br><span class="line">LEAF(env_pop_tf)</span><br><span class="line"><span class="comment">/*传入参数</span></span><br><span class="line"><span class="comment"> *$a0 : 当前进程的env-&gt;env_tf起始地址，即上下文信息</span></span><br><span class="line"><span class="comment"> *$a1 : 当前进程的唯一标识（经过一定处理）//我也不知道他为什么要处理。。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.<span class="built_in">set</span>	mips1          </span><br><span class="line">		<span class="comment">//1:	j	1b</span></span><br><span class="line">	nop    </span><br><span class="line">		move	k0,a0 </span><br><span class="line">		mtc0	a1,CP0_ENTRYHI</span><br><span class="line">		<span class="comment">//是设置中断位，从禁止中断（即之前在时钟中断进入的核心态）到允许中断即将EXL：IE从10--&gt;00（详见下图）(?????)</span></span><br><span class="line">		mfc0	t0,CP0_STATUS                    </span><br><span class="line">		ori		t0,<span class="number">0x3</span>                          </span><br><span class="line">		xori	t0,<span class="number">0x3</span>                          </span><br><span class="line">		mtc0	t0,CP0_STATUS                    </span><br><span class="line">		<span class="comment">//加载进程控制块的储存上下文信息的tf中的值到对应的寄存器中去	</span></span><br><span class="line">		lw	v1,TF_LO(k0)                                       </span><br><span class="line">		mtlo	v1                               </span><br><span class="line">		lw	v0,TF_HI(k0)                     </span><br><span class="line">		lw	v1,TF_EPC(k0)                    </span><br><span class="line">		mthi	v0                               </span><br><span class="line">		mtc0	v1,CP0_EPC  </span><br><span class="line">		lw	$<span class="number">31</span>,TF_REG31(k0)                 </span><br><span class="line">		...........                </span><br><span class="line">		lw	$<span class="number">1</span>,TF_REG1(k0)</span><br><span class="line">		lw	k1,TF_PC(k0)</span><br><span class="line">		lw	k0,TF_STATUS(k0)                 </span><br><span class="line">		nop</span><br><span class="line">        <span class="comment">//跟新CP0协处理器的状态</span></span><br><span class="line">		mtc0	k0,CP0_STATUS</span><br><span class="line">		j	k1</span><br><span class="line">		rfe</span><br><span class="line">		nop</span><br><span class="line">END(env_pop_tf)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/OS-lab3/SR.png" alt></p>
<p><img src="/2019/04/13/OS-lab3/E.png" alt></p>
</li>
<li><p>图解进程切换</p>
<p><img src="/2019/04/13/OS-lab3/save.png" alt></p>
<p><img src="/2019/04/13/OS-lab3/write.png" alt></p>
</li>
</ul>
</li>
</ul>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>我的傻瓜调度 ：</p>
<p>进程调度主要依赖于函数<code>sched_yield()</code>以及数据结构<code>env_sched_list[2]</code>（这两个链表构造出一种类似于循环链表的形式） :</p>
<ul>
<li><p>调度原理</p>
<ol>
<li><p>初始经过<code>env_create_priority()</code>创建的进程（已经加载过二进制文件随时可以调度执行）加入到<code>env_sched_list[0]</code>中去</p>
</li>
<li><p>每次符合调度条件时，将当前要调度走的进程插入另一个调度队列，然后试图从当前调度队列中拿出一项可调度的，<strong>如果没有则换另一个链表寻找</strong></p>
</li>
<li>拿到要切换到的进程后，<strong>将时间片计数值清0</strong>，然后调用<code>env_run()</code>进行切换</li>
</ol>
<p>注：在调度第一个进程时行为有所不同</p>
</li>
<li><p>调度算法实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sched.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_yield</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录当前进程已经使用的时间片数目</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//t = 0/1表示从哪个待调度队列中取进程</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	counter++;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 切换进程的条件</span></span><br><span class="line"><span class="comment">     * 1. 当前进程时NULL，这种情况只发生在运行第一个进程的时候</span></span><br><span class="line"><span class="comment">     * 2. 当前进程的时间片已经用完了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">if</span> (curenv == <span class="literal">NULL</span> || counter &gt;= curenv-&gt;env_pri)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 如果不是第一次运行进程，则要将当前进程添加到另一个待调度队列中以便下一次调度</span></span><br><span class="line">		<span class="keyword">if</span> (curenv != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LIST_INSERT_TAIL(&amp;env_sched_link[t^<span class="number">1</span>], curenv, env_sched_link);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//在当前调度队列中寻找下一个可调度来运行的进程</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span>  <span class="title">Env</span> *<span class="title">e</span> = <span class="title">LIST_FIRST</span>(&amp;<span class="title">env_sched_link</span>[<span class="title">t</span>]);</span></span><br><span class="line">            <span class="comment">//如果没找到，则换一个调度队列继续找</span></span><br><span class="line">			<span class="keyword">if</span> (e == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				t = t ^ <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//找到一个可执行的</span></span><br><span class="line">			<span class="keyword">if</span> (e-&gt;env_status == ENV_RUNNABLE)</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">//从待调度队列中移除</span></span><br><span class="line">				LIST_REMOVE(e, env_sched_link);</span><br><span class="line">                <span class="comment">//初始化已使用时间片个数</span></span><br><span class="line">				counter = <span class="number">0</span>;</span><br><span class="line">				env_run(e);<span class="comment">//在env_run()方法中会将curenv设置为e</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果不需要调度则当前进程继续执行</span></span><br><span class="line">	env_run(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图示</p>
<p>以我们指导书的两个线程为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENV_CREATE_PRIORITY(user_A, <span class="number">2</span>);</span><br><span class="line">ENV_CREATE_PRIORITY(user_B, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//调度顺序应该为BABABA</span></span><br><span class="line"><span class="comment">//其中一次B占1个时间片，一个A占2个时间片</span></span><br></pre></td></tr></table></figure>
<ol>
<li>初始进程建立好之后</li>
</ol>
<p><img src="/2019/04/13/OS-lab3/1.png" alt></p>
<ol start="2">
<li>第一次调度执行B</li>
</ol>
<p><img src="/2019/04/13/OS-lab3/2.png" alt></p>
<ol start="3">
<li>第二次调度执行A</li>
</ol>
<p><img src="/2019/04/13/OS-lab3/3.png" alt></p>
<ol start="3">
<li>第三次调度又执行B</li>
</ol>
<p><img src="/2019/04/13/OS-lab3/4.png" alt></p>
<p><img src="/2019/04/13/OS-lab3/5.png" alt></p>
</li>
</ul>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>在<code>lab3</code>中所有的进程切换都是时钟中断导致的</p>
<p>流程如下 : (异常处理详见<code>lab4</code>)</p>
<ol>
<li>硬件完成 : 产生时间中断,CPU保存信息(异常原因,<code>EPC</code>等),跳转到异常分发代码</li>
<li>软件完成 : <ol>
<li>根据<code>CAUSE</code>寄存器中的<code>ExcCode</code>判断为时钟中断,跳转到对于的处理函数<code>hand_int</code></li>
<li>处理函数进行异常的处理</li>
<li>处理完之后返回,恢复运行</li>
</ol>
</li>
</ol>
<p>异常处理函数如下 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NESTED(handle_int, TF_SIZE, sp)</span><br><span class="line">nop</span><br><span class="line">SAVE_ALL	<span class="comment">//保存现场,将寄存器的值压栈(TIMESTACK栈)</span></span><br><span class="line">CLI			<span class="comment">//异常处理中关闭时钟中断</span></span><br><span class="line">.<span class="built_in">set</span>	at</span><br><span class="line">mfc0	t0, CP0_CAUSE</span><br><span class="line">mfc0	t2, CP0_STATUS</span><br><span class="line"><span class="keyword">and</span>	t0, t2</span><br><span class="line">andi	t1, t0, STATUSF_IP4</span><br><span class="line">bnez	t1, timer_irq	<span class="comment">//timer_irq为真正的处理函数</span></span><br><span class="line">nop</span><br><span class="line">END(handle_int)</span><br><span class="line"></span><br><span class="line">timer_irq:</span><br><span class="line"><span class="number">1</span>:	j	sched_yield	<span class="comment">//异常处理即为切换进程</span></span><br><span class="line">	nop</span><br><span class="line">	j	ret_from_exception	<span class="comment">//恢复现场(其实不会恢复,因为j跳转不会记录返回地址)</span></span><br><span class="line">	<span class="comment">//真正的恢复寄存器的值应该是新调度运行的进程的,而不是老进程的,即由env_pop_tf函数完成</span></span><br><span class="line">	nop</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/12/Write-Read/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/Write-Read/" itemprop="url">Write-Read</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-12T19:09:01+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PV操作"><a href="#PV操作" class="headerlink" title="PV操作"></a>PV操作</h1><h2 id="实现Write-Read模型"><a href="#实现Write-Read模型" class="headerlink" title="实现Write-Read模型"></a>实现Write-Read模型</h2><h3 id="写优先级"><a href="#写优先级" class="headerlink" title="写优先级"></a>写优先级</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readcount = <span class="number">0</span>;	<span class="comment">//当前读者数目</span></span><br><span class="line"><span class="keyword">int</span> writecount = <span class="number">0</span>;</span><br><span class="line">semaphore rmutex = <span class="number">1</span>;	<span class="comment">//保护readcount的互斥信号量</span></span><br><span class="line">semaphore wmutex = <span class="number">1</span>;	<span class="comment">//保护writecount的互斥信号量</span></span><br><span class="line">semaphore <span class="built_in">queue</span> = <span class="number">1</span>;		<span class="comment">//读进程的等待队列</span></span><br><span class="line">semaphore w_sem = <span class="number">1</span>;		<span class="comment">//写进程的互斥信号量</span></span><br><span class="line">semaphore r_sem = <span class="number">1</span>;		<span class="comment">//读进程用来与写进程互斥的量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWait(<span class="built_in">queue</span>);</span><br><span class="line">        	semWait(r_sem);</span><br><span class="line">        		semWait(rmutex);	<span class="comment">//保证对readcount操作的原子性</span></span><br><span class="line">        			<span class="comment">//如果是第一个读者，则阻塞写进程</span></span><br><span class="line">        			<span class="keyword">if</span> (readcount == <span class="number">0</span>)	 semWait(w_sem);</span><br><span class="line">        			readcount++;</span><br><span class="line">        		semSignal(rmutex);</span><br><span class="line">        	semSignal(r_sem);</span><br><span class="line">        semSignal(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="comment">// read data code</span></span><br><span class="line">        semWait(rmutex);	<span class="comment">//保证对readcount操作的原子性</span></span><br><span class="line">        	readcount--;</span><br><span class="line">        	<span class="comment">// 读者结束优先唤醒写者</span></span><br><span class="line">        	<span class="keyword">if</span> (readcount == <span class="number">0</span>)	 semSignal(w_sem);</span><br><span class="line">        semSignal(rmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWait(wmutex);	<span class="comment">// 保证对writecount操作的原子性</span></span><br><span class="line">        	<span class="keyword">if</span> (writecount == <span class="number">0</span>)	semWait(r_sem);</span><br><span class="line">        	writecount++;</span><br><span class="line">        semSignal(wmutex);</span><br><span class="line">       	semWait(w_sem);</span><br><span class="line">        <span class="comment">// write data code</span></span><br><span class="line">        semSignal(w_sem);</span><br><span class="line">        semWait(wmutex);</span><br><span class="line">        	writecount--;</span><br><span class="line">        	<span class="comment">// 当写完事后才释放读者的使用权</span></span><br><span class="line">        	<span class="keyword">if</span> (writecount == <span class="number">0</span>)	semSignal(r_sem);</span><br><span class="line">        semSignal(wmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/09/cache结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/09/cache结构/" itemprop="url">访存结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-09T12:06:36+08:00">
                2019-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><h2 id="cache的工作原理"><a href="#cache的工作原理" class="headerlink" title="cache的工作原理"></a>cache的工作原理</h2><p>基本的<code>cache</code>一项至少包含数据信息以及标记位</p>
<p>现代体系结构中的<code>cache</code>多采用组相联,多级<code>cache</code>结构</p>
<p>为方便起见以下使用一级<code>cache</code>说明,多级就等价于将低级<code>cache</code>看做是高级<code>cache</code>的高速缓存</p>
<ol>
<li>通过地址获得在<code>cache</code>中的索引</li>
<li>由索引得到<code>cache</code>中的一组,比较该组中各项的标记是否与给出地址符合</li>
<li>比较后 :<ul>
<li>若存在符合,则<code>cache</code>命中,返回得到的物理内存中的数据值</li>
<li>若不存在符合,<strong>则产生缺失,这时需要到内存中(实际上一般是下一级<code>cache</code>)中寻找该地址对应的数据,并将该数据写到<code>cache</code>中来</strong></li>
</ul>
</li>
</ol>
<p><img src="/2019/04/09/cache结构/cache-work.png" alt></p>
<p>注 : 在<code>cache</code>使用实际中涉及缺失时的替换策略,写时的数据一致性等等工程细节问题,此处只做简单说明</p>
<ul>
<li><p>替换策略 : 随机替换,最近最少使用策略,先进先出策略</p>
<p><strong>在考虑策略时要注意硬件实现的复杂性</strong></p>
</li>
<li><p>写操作一致性 : </p>
<ul>
<li>写回法 : 暂时只向<code>cache</code>中写入,并标记是否修改,直到该块被替换出去才将值写会内存中</li>
<li>写直达 : 在每次写<code>cache</code>的同时也写入内存中</li>
</ul>
</li>
</ul>
<h2 id="cache结构种类"><a href="#cache结构种类" class="headerlink" title="cache结构种类"></a>cache结构种类</h2><h3 id="VIVT"><a href="#VIVT" class="headerlink" title="VIVT"></a>VIVT</h3><p><code>Virtual index Virtual Tag</code> : 使用虚拟地址索引域和虚拟地址的标记位,其中存储的是其对应物理内存的数据值</p>
<ul>
<li><p>优势 :</p>
<p>直接使用CPU发出的虚拟地址的索引域和标记域来查找<code>cache line</code>,而不用经过<code>MMU</code>的翻译,所以查找的速度是最快的</p>
</li>
<li><p>问题 :</p>
<ul>
<li><code>synonyms</code> : 多个不同的虚拟地址可能会被映射到同一个物理地址,即缓存别名情况<ol>
<li>例如在多进程通信时,多个虚拟地址映射到一个物理地址,导致<strong>同一个物理地址有多个高速缓存</strong>,对任何一个缓存的修改都会导致数据不一致</li>
</ol>
</li>
<li><code>homonyms</code> : 相同的虚拟地址指向不同的物理地址,<strong>这种情况下仅仅依靠<code>Virtual Index</code>无法区分这些相同的<code>cache</code>项</strong><ol>
<li>在不同的进程中可能出现该情况</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="VIPT"><a href="#VIPT" class="headerlink" title="VIPT"></a>VIPT</h3><p><code>Virtual Index Physical Tag</code>：使用虚拟地址的索引域和物理地址的标记域,其中存储在内存中物理地址的数据值,<strong>这种方法综合较优</strong></p>
<ul>
<li><p>优势 :</p>
<p><strong>可以通过一定程度的并行设计来提高访存效率</strong></p>
<ol>
<li><p><code>CPU</code>指令给出虚拟地址 :</p>
<ul>
<li><p>虚拟地址进入<code>cache</code>结构寻找对应的组</p>
</li>
<li><p>虚拟地址进入<code>TLB</code>结构查询是否有对应的物理页号生成物理地址</p>
</li>
</ul>
</li>
<li><p>得到物理地址后作为生成<code>tag</code>访问对应的缓存项</p>
</li>
<li><p>检查是否命中 :</p>
<ul>
<li>命中则返回数据</li>
<li>没有命中则根据物理地址访问内存</li>
</ul>
</li>
</ol>
</li>
<li><p>问题解决 :</p>
<ul>
<li><p>显然,由于是通过物理地址的标记位来确定是否命中的,所以不存在相同的虚拟地址指向不同物理地址的情况</p>
</li>
<li><p>对于<code>synonyms</code>问题 :</p>
<p>把握一点 : <strong>虚实地址的映射关系是通过页结构完成的,即页对齐思想</strong></p>
<p>以4KB大小为一页来分析 :</p>
<ol>
<li><strong>相互对应的虚拟和物理地址的页内偏移一定相同,即低12位一定相同</strong></li>
<li>当多个虚拟地址映射到同一个物理地址时,这些虚拟地址的低12位一定是相同的</li>
<li>只要项内偏移 + <code>cache</code>索引没有超过12位,则这些虚拟地址对应同一个<code>cache</code>组,而物理标记位一定是唯一的,所以对应同一项</li>
<li>所以不会出现缓存别名情况</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="PIPT"><a href="#PIPT" class="headerlink" title="PIPT"></a>PIPT</h3><p><code>Physical Index Physical Tag</code>：使用物理地址的索引域和物理地址的标记域</p>
<p><strong>问题在于访存太慢</strong></p>
<ol>
<li><code>CPU</code>给出虚拟地址来访问数据，<code>TLB</code>接收到这个地址之后查找是否有对应的页表项。</li>
<li>假设页表项存在，则根据物理地址在<code>cache</code>中查询；如果不存在，则<code>MMU</code>执行正常的页表查询工作之后再根据物理地址在<code>cache</code>中查询，同时更新<code>TLB</code>中的内容。</li>
<li>如果<code>cache</code>命中，则直接返回给<code>CPU</code>数据；如果没有命中则按照相应的算法进行cache<code>的替换或者装填，之后返回给</code>CPU`数据。</li>
</ol>
<p><strong>当<code>TLB</code>没用命中但是这个地址是在<code>cache</code>中时会带来巨大的性能损失</strong></p>
<p><img src="/2019/04/09/cache结构/PIPT.png" alt></p>
<h1 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h1><p><strong><code>TLB</code>本质上就是页表结构的<code>cache</code></strong></p>
<h2 id="页表的使用"><a href="#页表的使用" class="headerlink" title="页表的使用"></a>页表的使用</h2><p>实现从<code>VPN--&gt;PPN</code>的转换</p>
<p><img src="/2019/04/09/cache结构/page.png" alt></p>
<p>注 : </p>
<ul>
<li><code>V</code>是标记位,标记该页表项是否有效</li>
<li><code>AR</code>是权限位,检查访存权限</li>
</ul>
<h2 id="TLB中的信息"><a href="#TLB中的信息" class="headerlink" title="TLB中的信息"></a>TLB中的信息</h2><p><strong><code></code>TLB<code>作为一种特殊的</code>cache`结构工作</strong></p>
<ul>
<li>访问时使用的<code>index</code>是<code>VPN</code>的低位</li>
<li>判断使用命中时使用的<code>tag</code>是<code>VPN</code>的高位</li>
<li>每一项中存储的信息包括比较时使用的<code>tag</code>以及真正使用的数据<code>PPN</code>(含标记位)</li>
</ul>
<p><img src="/2019/04/09/cache结构/TLB.png" alt></p>
<h1 id="cache-TLB-工作"><a href="#cache-TLB-工作" class="headerlink" title="cache + TLB 工作"></a>cache + TLB 工作</h1><p><img src="/2019/04/09/cache结构/TLB+Cache.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/03/OS-lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/03/OS-lab2/" itemprop="url">OS-lab2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-03T21:54:25+08:00">
                2019-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="OS-lab2-memory-management"><a href="#OS-lab2-memory-management" class="headerlink" title="OS-lab2 memory management"></a>OS-lab2 memory management</h1><h2 id="基本设定"><a href="#基本设定" class="headerlink" title="基本设定"></a>基本设定</h2><ul>
<li><p>虚拟内存4G大小,分布如下:</p>
<p><img src="/2019/04/03/OS-lab2/mm.png" alt></p>
</li>
<li><p>物理内存大小为64MB</p>
</li>
<li>分页大小为一页4KB</li>
<li>页表结构为两层,页表项大小为4K,即一页页表为1K项,每一项映射4KB即一页大小空间,所以一页页表映射4MB空间</li>
<li>页表第一级为页目录,只有一页,1K项,每一项中保存一个页表的物理首地址</li>
<li>页表第二级为页表,有1K页,每页1K项,每一项中保存一个物理页的首地址</li>
<li><strong>由于自映射机制可知页目录即为某一页页表</strong></li>
<li><strong>其中<code>kseg0</code>区域的物理虚拟地址转换不需要经过页表,只需要将最高位改变即可</strong></li>
<li>规定内核映射的虚拟空间范围为<code>0x8001_0000 - 0x8040_0000</code></li>
</ul>
<h2 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol>
<li><p><code>Page</code>物理内存管理单元结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span>							</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span>	<span class="comment">// 指向链表中下一个元素</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span>	<span class="comment">// 指向链表中前一个元素中指向后一个的指针(二重指针)</span></span><br><span class="line">	&#125;pp_linhk;	</span><br><span class="line">	u_short pp_ref;	<span class="comment">// 表示该物理页被引用多少次</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>宏定义链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供了大量的宏定义链表操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_HEAD(name, type)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_HEAD_INITIALIZER(head)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_ENTRY(type)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_EMPTY(head)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_FIRST(head)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_FOREACH(var, head, field)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_INIT(head)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_NEXT(elm, field)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_INSERT_AFTER(listelm, elm, field)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_INSERT_BEFORE(listelm, elm, field)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_INSERT_HEAD(head, elm, field)</span></span><br></pre></td></tr></table></figure>
<p><strong>该链表设计的巧妙之处在于二重指针<code>*le_prev</code>,该指针指向前一个元素数据域中指向下一个的那个指针,该设计的作用是在删除一个链表节点时只需要有指向该节点的指针即可,即要删除<code>A</code>指向的节点,只需令<code>*(A-&gt;pp_link.le_prev) = A-&gt;pp_link.le_next</code>即可</strong></p>
</li>
</ol>
<h3 id="地址操作"><a href="#地址操作" class="headerlink" title="地址操作"></a>地址操作</h3><ol>
<li><p>在<code>kseg0</code>中的地址操作只需要改变最高位即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在kseg0区域内</span></span><br><span class="line"><span class="comment">// 虚存中的区域起始地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ULIM 0x80000000</span></span><br><span class="line"><span class="comment">// 由虚拟地址得到物理地址 : -0x8000_0000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PADDR(kva)						\</span></span><br><span class="line">(&#123;								\</span><br><span class="line">	u_long a = (u_long) (kva);				\</span><br><span class="line">	<span class="keyword">if</span> (a &lt; ULIM)					\</span><br><span class="line">		panic(<span class="string">"PADDR called with invalid kva %08lx"</span>, a);\</span><br><span class="line">	a - ULIM;						\</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 有物理地址得到虚拟地址 : +0x8000_0000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KADDR(pa)						\</span></span><br><span class="line">(&#123;								\</span><br><span class="line">	u_long ppn = PPN(pa);					\</span><br><span class="line">	<span class="keyword">if</span> (ppn &gt;= npage)					\</span><br><span class="line">		panic(<span class="string">"KADDR called with invalid pa %08lx"</span>, (u_long)pa);\</span><br><span class="line">	(pa) + ULIM;					\</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在用户空间中需要使用二级页表结构来实现地址转换</p>
<ul>
<li><p>由<strong>硬件完成</strong>的地址映射机制</p>
<p><img src="/2019/04/03/OS-lab2/page.png" alt></p>
</li>
<li><p>在程序中要进行的是在最开始初始化页表,即建立内存管理时<strong>对页表项的填写</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由虚拟地址得到页目录项的索引</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDX(va)		((((u_long)(va))&gt;&gt;22) &amp; 0x03FF)</span></span><br><span class="line"><span class="comment">// 由虚拟地址得到页表项的索引</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTX(va)		((((u_long)(va))&gt;&gt;12) &amp; 0x03FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意 :</span></span><br><span class="line"><span class="comment">所有的虚拟地址都通过u_long类型的指针表示,因为u_long类型占4B空间,刚好时页表或页目录一项的大小,这样首地址加索引便是指向某一项的指针(类似于数组,利用了一页空间的连续性)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>有关对齐</strong></p>
<ul>
<li><p>在页表中每一项按字(4B)对齐</p>
</li>
<li><p><strong>在分配物理内存时按页(4KB)分配对齐</strong></p>
</li>
<li><p><strong>地址对齐函数</strong> :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BY2PG		4096	<span class="comment">// 4KB</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROUND(a, n)	(((((u_long)(a))+(n)-1)) &amp; ~((n)-1))</span></span><br><span class="line"><span class="comment">// 将address按4KB对齐</span></span><br><span class="line">address = ROUND(address, BY2PG);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><h3 id="从物理虚拟内存角度"><a href="#从物理虚拟内存角度" class="headerlink" title="从物理虚拟内存角度"></a>从物理虚拟内存角度</h3><ul>
<li>对物理内存的管理依赖于<code>Page</code>结构体数组<code>pages[]</code>,以及由数组中的某些项链接构成的可使用空闲物理页<code>page_free_list</code></li>
<li><p>对虚拟内存的管理依赖</p>
<ul>
<li><code>kseg0</code>中虚实地址直接转换</li>
<li><code>kuseg</code>中利用二级页表进行虚实地址转换</li>
</ul>
</li>
<li><strong>在程序中直接访问的一定是虚拟地址,但是可能写入的数据是物理地址 : 例如填写页表项</strong></li>
</ul>
<h3 id="从构建阶段角度"><a href="#从构建阶段角度" class="headerlink" title="从构建阶段角度"></a>从构建阶段角度</h3><ul>
<li>在物理内存被页式管理之前,使用<code>alloc</code>函数来分配固定大小的物理内存</li>
<li>在物理内存被页式管理之后,从<code>page_free_list</code>中取空闲的物理页分配</li>
</ul>
<h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><h3 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h3><p>内核在虚拟地址空间的<code>kseg0</code>中的<code>0x8001_0000 - 0x8040_0000</code>中</p>
<p>映射到物理空间是<code>0x0001_0000 - 0x0040_0000</code>区域</p>
<h3 id="初始化内存管理"><a href="#初始化内存管理" class="headerlink" title="初始化内存管理"></a>初始化内存管理</h3><p>从<code>mips_init</code>函数入手,总流程如下图</p>
<p> <img src="/2019/04/03/OS-lab2/summary.png" alt></p>
<p><strong>其他都好理解,难点在于<code>boot_map_segment</code>函数</strong></p>
<p>该函数的作用是建立将分配好物理内存的<code>pages[]</code>通过建立页表,填写页表项,填写页目录项映射到虚拟空间中的<code>kuseg</code>区间中</p>
<p><code>boot_map_segment(pdgir, UPAGES, n, PADDR(pages), PTE_R)</code></p>
<ul>
<li><p>参数说明 :</p>
<ul>
<li><code>pgdir(*u_long)</code> : 之前建立的页目录的起始虚地址</li>
<li><code>UPAGES(u_long)</code> : 虚拟空间用户空间中的<code>PAGES</code>段起始地址</li>
<li><code>n(u_long)</code> : <code>pages[]</code>占用的空间页数</li>
<li><code>PADDR(pages)</code> : <code>pages[]</code>占用的物理空间的起始地址</li>
</ul>
</li>
<li><p>具体流程 :</p>
<ol>
<li>对虚拟空间中的每一页调用<code>boot_pgdir_walk(pgdir, va , 1)</code><ol>
<li>由<code>pgdir + PDX(va)</code>得到<code>va</code>对应的页目录项地址</li>
<li>取出页目录项值 : 必为无效值<ol>
<li>从物理内存中使用<code>alloc</code>分配一页并映射到<code>kseg0</code>空间作为该项对应一页页表,返回该页虚拟起始地址<code>pgtable</code></li>
<li>将该页物理地址<code>KADDR(pgtable)</code>填入页目录项中</li>
</ol>
</li>
<li>由<code>pgtable + PTX(va)</code>得到该建立的页表中<code>va</code>对应的页表项地址</li>
</ol>
</li>
<li>将该页对应的物理地址填入页表项中</li>
</ol>
</li>
</ul>
<h3 id="图解流程"><a href="#图解流程" class="headerlink" title="图解流程"></a>图解流程</h3><h4 id="加载内核-1"><a href="#加载内核-1" class="headerlink" title="加载内核"></a>加载内核</h4><p><img src="/2019/04/03/OS-lab2/2.png" alt></p>
<h4 id="创建页目录"><a href="#创建页目录" class="headerlink" title="创建页目录"></a>创建页目录</h4><p><img src="/2019/04/03/OS-lab2/3.png" alt></p>
<h4 id="创建物理块并建立它的二级页表映射"><a href="#创建物理块并建立它的二级页表映射" class="headerlink" title="创建物理块并建立它的二级页表映射"></a>创建物理块并建立它的二级页表映射</h4><p><img src="/2019/04/03/OS-lab2/4.png" alt></p>
<h4 id="页结构内存管理"><a href="#页结构内存管理" class="headerlink" title="页结构内存管理"></a>页结构内存管理</h4><p><img src="/2019/04/03/OS-lab2/6.png" alt></p>
<h2 id="初始化之后的内存操作"><a href="#初始化之后的内存操作" class="headerlink" title="初始化之后的内存操作"></a>初始化之后的内存操作</h2><p><strong>在初始化之后所有的内存操作都要基于页结构来完成,不能再使用<code>alloc</code>函数直接分配</strong></p>
<h3 id="基本工具-1"><a href="#基本工具-1" class="headerlink" title="基本工具"></a>基本工具</h3><p><strong>利用了物理内存控制块对应物理内存的连续性以及页对齐的特性</strong></p>
<ul>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由该页的控制块获得其在pages[]中的下标</span></span><br><span class="line">page2ppn(struct Page *pp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pp - pages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>由物理页的控制块指针获得其物理地址</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSHIFT		12</span></span><br><span class="line">page2pa(struct Page *pp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得下标之后即代表是第几个物理页,一页4KB,所以左移12位即可得到物理地址</span></span><br><span class="line">	<span class="keyword">return</span> page2ppn(pp)&lt;&lt;PGSHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>由物理地址得到指向其控制块的指针</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 物理地址右移12位得到该物理页对应控制块在pages[]中的下标</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PPN(va)		(((u_long)(va))&gt;&gt;12)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct Page *<span class="title">pa2page</span><span class="params">(u_long pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (PPN(pa) &gt;= npage)</span><br><span class="line">		panic(<span class="string">"pa2page called with invalid pa: %x"</span>, pa);</span><br><span class="line">    <span class="comment">// 返回控制块指针</span></span><br><span class="line">	<span class="keyword">return</span> &amp;pages[PPN(pa)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><ul>
<li><p><code>int page_alloc(struct Page **pp)</code> :</p>
<ul>
<li>函数功能 : 在<code>page_free_list</code>中找到一个空闲页清空之后让<code>*pp</code>指向该节点</li>
<li>分配成功返回0.否则返回<code>-E_NO_MEM</code></li>
</ul>
</li>
<li><p><code>void page_free(struct Page *pp)</code> :</p>
<ul>
<li>函数功能 : 如果控制块<code>pp</code>代表的物理地址的引用<code>pp_ref</code>为0的话则将该控制块加入空闲页链表<code>page_free_list</code></li>
</ul>
</li>
<li><p><strong>重要的基本函数</strong> :</p>
<p><code>int pgdir_walk(Pde *pgdir, u_long va, int create, Pte **ppte)</code> :</p>
<ul>
<li><p>函数功能 : 查找<code>va</code>对应的页表项的指针赋值给<code>*ppte</code>,若没有则新分配一页页表,并将分配的页表的物理地址填入页目录的对应项,将页表项的指针赋值给<code>*ppte</code></p>
</li>
<li><p>参数定义 :</p>
<ul>
<li><code>pgdir</code>为页目录起始虚地址</li>
<li><code>va</code>为要访问的虚地址</li>
<li><code>create = 1</code>时若缺失则建立映射</li>
<li><code>*ppte</code> : 指向<code>va</code>对应的页表项</li>
</ul>
</li>
<li><p>函数流程 :</p>
<ol>
<li><p>查找页目录项 :</p>
<p><code>Pde *pgdir_entryp = pgdir+PDX(va);</code></p>
</li>
<li><p>获得页目录项内容(<code>*pgdir_entryp</code>),即页表(<code>kseg0</code>中)的起始物理地址,并转换为虚拟地址</p>
<p><code>pgtable = KADDR(PTE_ADDR(*pgdir_entryp));</code></p>
</li>
<li><p>检查页目录项内容是否有效</p>
<ol>
<li>若无效且<code>creat == 1</code> : 从空闲链表<code>page_free_list</code>中拿出一页内存(<code>ppage</code>)作为页表并映射到<code>kseg0</code>,<ol>
<li>使用<code>page_alloc(&amp;ppage)</code>分配</li>
<li>使用<code>ppage_pa = page2pa(page)</code>得到页表起始物理地址</li>
<li>使用<code>pgtable = KADDR(ppage_pa)</code>得到页表起始虚拟地址</li>
<li><strong>使用<code>*pgdir_entryp = page2pa(ppage)|PTE_V;</code>将<code>ppage_pa</code>填入页目录项中</strong></li>
</ol>
</li>
<li>若有效则无操作</li>
</ol>
</li>
<li><p>使用<code>*ppte = pgtable + PTX(va);</code>将<code>*ppte</code>指向<code>va</code>对应的页表项</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p><code>int page_insert(Pde *pgdir, struct Page *pp, u_long va, u_int perm)</code></p>
<ul>
<li><p>函数功能 : <strong>以<code>perm</code>的权限建立<code>va</code>到<code>pp</code>的二级页表映射</strong></p>
<p>检查<code>va</code>对应的页表项的值 : </p>
<p><code>pgdir_walk(pgdir, va, 0, &amp;pgtable_entry)</code></p>
<ul>
<li><p>若页表项存在 : </p>
<ul>
<li><p>若对应<code>pp</code> : 增加<code>perm</code>权限 <code>*pgtable_entry = (page2pa(pp) | PERM)</code></p>
</li>
<li><p>若不对应<code>pp</code> : 则从该页表中删除<code>va</code>对应的映射关系</p>
<p><code>page_remove(pgdir, va)</code></p>
</li>
</ul>
</li>
<li><p>若页表项不存在或不对应<code>pp</code></p>
<ol>
<li><p>申请一页新的页表并写入页目录中</p>
<p><code>pgdir_walk(pgdir, va, 1, &amp;pgtable_entry)</code></p>
</li>
<li><p>页表中对应项页权限位写入<code>pp</code>对应的物理地址,即建立<code>va</code>到<code>pp</code>的二级页表映射</p>
<p><code>*pgtable_entry = (page2pa(pp) | PERM)</code></p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>struct Page *page_lookup(Pde *pgdir, u_long va, Pte **ppte)</code></p>
<ul>
<li>函数功能 :<ul>
<li>返回<code>va</code>虚拟地址对应的页控制块的指针</li>
<li><code>*ppte</code>赋值指向<code>va</code>对应的页表项</li>
</ul>
</li>
</ul>
</li>
<li><p><code>void page_remove(Pde *pgdir, u_long va)</code></p>
<ul>
<li>函数功能 : <ol>
<li>删除<code>va</code>对应的页表项中的映射关系(即置0),对应物理块的引用<code>pp_ref</code>减一</li>
<li>如果删除后引用次数为0.则释放该页<code>page_free(ppage)</code></li>
</ol>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/Java正则表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/28/Java正则表达式/" itemprop="url">Java-Regular-expression</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-28T20:54:56+08:00">
                2019-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Regular-expression"><a href="#Regular-expression" class="headerlink" title="Regular expression"></a>Regular expression</h1><h2 id="通用规则"><a href="#通用规则" class="headerlink" title="通用规则"></a>通用规则</h2><h3 id="基本匹配"><a href="#基本匹配" class="headerlink" title="基本匹配"></a>基本匹配</h3><p>单纯的进行字符的逐个匹配(<strong>这里的字符不能在正则规则中有特殊含义,否则要进行转义才能匹配)</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如the匹配theme中的the</span><br></pre></td></tr></table></figure>
<h3 id="元字符匹配"><a href="#元字符匹配" class="headerlink" title="元字符匹配"></a>元字符匹配</h3><p>元字符具有特殊的含义</p>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th>特殊含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\</code></td>
<td>转义字符(详见下)</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td>从开始行进行匹配,当正则表达式以<code>^</code>开头时表示匹配成功对象必须从字符串开头开始</td>
</tr>
<tr>
<td style="text-align:center"><code>$</code></td>
<td>从末尾进行匹配,当正则表达式以<code>$</code>结尾时表示匹配成功对象必须以字符串结尾结束</td>
</tr>
<tr>
<td style="text-align:center"><code>.</code></td>
<td>匹配任意单个字符(除了换行符)</td>
</tr>
<tr>
<td style="text-align:center"><code>[]</code></td>
<td>匹配中括号列表中的任意一个字符 <code>[a-z]表示范围内的任何一个字符</code></td>
</tr>
<tr>
<td style="text-align:center"><code>[^ ]</code></td>
<td>匹配除了括号中字符之外的任何一个字符</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td>匹配0次或者大于0的任意次前一个字符(<strong>或者前一个子正则表达式</strong>)</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td>匹配1次或者大于1的任意词前一个字符(<strong>或者前一个子正则表达式</strong>)</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td>匹配0次或者1次前一个字符(<strong>或者前一个子正则表达式</strong>)</td>
</tr>
<tr>
<td style="text-align:center"><code>{n,m}</code></td>
<td>匹配num(<code>n&lt;=num&lt;=m)</code>次前一个字符(<strong>或者前一个子正则表达式</strong>)<em>n缺省时为0,m缺省时为无穷大</em></td>
</tr>
<tr>
<td style="text-align:center"><code>(xyz)</code></td>
<td>匹配<code>()</code>中的表达式(<strong>用小括号来构造局部的子正则表达式</strong>)</td>
</tr>
<tr>
<td style="text-align:center">`</td>
<td>`</td>
<td>正则表达式的或逻辑,任意匹配一个即可(<strong>注意在前面的子正则表达式优先匹配</strong>)</td>
</tr>
</tbody>
</table>
<p>注 : </p>
<ul>
<li><p>在Java中<code>\\</code>其转义作用</p>
<ol>
<li><p>使用<code>\\</code>表示某些特殊字符的含义[简写字符集]<em>(当这些字母单独出现时表示匹配自己对应的字母</em>)</p>
<ul>
<li><p><code>\\d</code>匹配数字字符<code>0 - 9</code>    <code>\\D</code>匹配非数字字符</p>
</li>
<li><p><code>\\n</code>匹配换行符</p>
</li>
<li><p><code>\\s</code>匹配任何空白字符           <code>\\S</code>匹配任何非空白符</p>
<p>…….</p>
</li>
</ul>
</li>
<li><p>使用<code>\\</code>可以使某些具有特殊含义的字符匹配自己本身对应的字符*<em>(</em>当他们单独出现时在正则表达式中有特殊的含义*)</p>
<ul>
<li>特殊字符有<code>[]  ()  {}  .   *   +   ?    ^   $   \   |</code>等</li>
<li>例如要匹配字符串<code>()</code>,Java正则表达式就要为<code>\\(\\)</code></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>使用<code>^</code>[reg_exp] <code>$</code>形式的正则表达式必须匹配整个字符串才算匹配成功</strong></p>
<p>Java中的<code>String.match(reg, str)</code>方法默认会在reg加上<code>^</code>与<code>$</code>所以可以不写</p>
</li>
</ul>
<h3 id="前后关联约束"><a href="#前后关联约束" class="headerlink" title="前后关联约束"></a>前后关联约束</h3><ol>
<li><p>前置约束-存在  <code>?=....</code></p>
<p><code>Reg(?=ConstraintReg)</code> : 表示匹配Reg表达式但是其后必须存在ConstraintReg表达式的匹配项</p>
<p><code>[tT]he(?=\sfat) =&gt;</code><strong><code>The</code></strong> <code>fat car sat on the mat</code></p>
</li>
<li><p>前置约束-排除 <code>?!....</code></p>
<p><code>Reg(?!ConstrainReg)</code> :  表示匹配Reg表达式但是其后必须不存在ConstraintReg表达式的匹配项</p>
<p><code>[tT]he(?=\sfat) =&gt;</code> <code>The fat car sat on</code><strong><code>the</code></strong> <code>mat</code></p>
</li>
<li><p>后置约束-存在<code>?&lt;=....</code></p>
<p><code>(?&lt;=ConstraintReg)Reg</code>: 表示匹配Reg表达式之前必须匹配ConstraintReg表达式</p>
</li>
<li><p>后置约束-排除<code>?&lt;!....</code></p>
<p><code>(?&lt;!ConstraintReg)Reg</code>: 表示匹配Reg表达式之前必须不匹配ConstraintReg表达式</p>
</li>
</ol>
<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><ul>
<li>标记<code>i</code>忽略大小写</li>
<li>标记<code>g</code>进行全局搜索,返回所用成功匹配的串</li>
<li>标记<code>?</code>表示非贪心匹配,对前面紧接的多种可能的规则匹配最短的可能(默认为贪心的  : 匹配所有可能中最长的)</li>
</ul>
<h2 id="Java相关类"><a href="#Java相关类" class="headerlink" title="Java相关类"></a>Java相关类</h2><p><strong>Pattern 与 Matcher类</strong></p>
<h3 id="标准使用"><a href="#标准使用" class="headerlink" title="标准使用"></a>标准使用</h3><p>在<code>str</code>中寻找<code>reg</code>正则表达式的匹配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Matcher matcher = pattern.matcher(str);</span><br><span class="line"><span class="keyword">while</span>(matcher.find()) &#123;</span><br><span class="line">    String hit = matcher.group();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p>在<code>compile(reg)</code>中<code>reg</code>必须在最外侧用一个<code>()</code>包括,表示一个单独的捕获组</p>
<p><strong>matcher从开始到结尾扫描字符串,每次返回一次的匹配结果</strong></p>
</li>
<li><p><code>matcher</code>提供<code>start()与end()</code>方法返回每次匹配的位置</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/cmd-command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/28/cmd-command/" itemprop="url">cmd command</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-28T20:54:56+08:00">
                2019-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/command/" itemprop="url" rel="index">
                    <span itemprop="name">command</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常用cmd命令"><a href="#常用cmd命令" class="headerlink" title="常用cmd命令"></a>常用cmd命令</h1><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><ul>
<li><p>进入首层盘 </p>
<p><code>D:</code></p>
</li>
<li><p>进入其他文件夹</p>
<p><code>cd [foldername]</code></p>
</li>
<li><p>返回上一层</p>
<p><code>cd ..</code></p>
</li>
<li><p>查看目录文件</p>
<p><code>dir</code></p>
</li>
</ul>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ul>
<li><p>创建目录</p>
<p><code>md [foldername]</code></p>
</li>
<li><p>删除目录</p>
<p><code>rd [foldername]</code></p>
</li>
<li><p>复制文件</p>
<p><code>copy sourcePath destinationPath</code></p>
</li>
<li><p>移动文件(剪切+粘贴)</p>
<p><code>move sourcePath destinationPath</code></p>
</li>
<li><p>删除文件(不能文件夹)</p>
<p><code>del filename</code></p>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>清除屏幕</p>
<p><code>cls</code></p>
</li>
<li><p>查看本机ip</p>
<p><code>ipconfig</code></p>
</li>
</ul>
<h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><ul>
<li><p><code>help</code>命令查看所有<code>dos</code>命令</p>
</li>
<li><p>在任何一个命令后<code>+ /?</code>查看其他属性(包括用法和参数)</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/idea-debug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/28/idea-debug/" itemprop="url">idea-debug</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-28T20:54:56+08:00">
                2019-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/debug/" itemprop="url" rel="index">
                    <span itemprop="name">debug</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用idea进行debug"><a href="#使用idea进行debug" class="headerlink" title="使用idea进行debug"></a>使用idea进行debug</h1><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><ol>
<li>甲壳虫标记以Debug模式启动服务。</li>
<li>断点：在左边行号栏单击左键.</li>
<li>Debug窗口：访问请求到达第一个断点后，会自动激活Debug窗口。</li>
<li>调试按钮：一共有8个按钮，调试的主要功能就对应着这几个按钮，鼠标悬停在按钮上可以查看对应的快捷键。在菜单栏Run里可以找到同样的对应的功能</li>
<li>服务按钮：可以在这里关闭/启动服务，设置断点等。</li>
<li>方法调用栈：这里显示了该线程调试所经过的所有方法，勾选右上角的[Show All Frames]按钮，就不会显示其它类库的方法了，否则这里会有一大堆的方法。</li>
<li>Variables：在变量区可以查看当前断点之前的当前方法内的变量。</li>
<li>Watches：查看变量，可以将Variables区中的变量拖到Watches中查看 </li>
</ol>
<p><img src="/2019/02/28/idea-debug/856154-20170905221418147-1205043020.png" alt></p>
<h3 id="基本按钮"><a href="#基本按钮" class="headerlink" title="基本按钮"></a>基本按钮</h3><p><img src="/2019/02/28/idea-debug/856154-20170905134837851-1615718043.png" alt></p>
<p>从左到右:</p>
<ol>
<li>快速回到代码当前所在执行行</li>
<li>逐步执行(不进入方法)</li>
<li>步入: 进入当前行方法,多是自定义方法</li>
<li>强制步入: 可以进入任何方法(可用此来查看官方库代码)</li>
<li>步出 :从步入的方法中返回(<strong>进入的方法还是会执行完,只是没有显示过程</strong>)</li>
<li><strong>回退断点</strong></li>
<li>运行到光标处:会将代码运行到光标定位的那一行</li>
<li><strong>计算表达式</strong></li>
</ol>
<h3 id="变量查看"><a href="#变量查看" class="headerlink" title="变量查看"></a>变量查看</h3><ul>
<li>参数所在行后面显示</li>
<li>光标悬停所在参数显示值</li>
<li>Variables中有方法的所有变量</li>
</ul>
<h2 id="技巧类"><a href="#技巧类" class="headerlink" title="技巧类"></a>技巧类</h2><h3 id="计算表达式"><a href="#计算表达式" class="headerlink" title="计算表达式"></a>计算表达式</h3><ol>
<li>选中某个表达式再<code>Alt + F8</code>，弹出计算表达式的窗口<strong>表达式的计算可以是参数值,变量值,方法的返回值等</strong></li>
<li>在计算表达式的面板中,<strong>可以改变变量的值看不同的情况</strong></li>
</ol>
<h3 id="智能进入"><a href="#智能进入" class="headerlink" title="智能进入"></a>智能进入</h3><p>当一行中同时有多个方法时,智能步入可以选择某个方法进入(<em>默认按顺序</em>)</p>
<p><img src="/2019/02/28/idea-debug/856154-20170905163730929-1374653206.png" alt></p>
<p>使用<code>shift +F7</code>可以选择当前行的进入方法</p>
<h3 id="设置断点条件"><a href="#设置断点条件" class="headerlink" title="设置断点条件"></a>设置断点条件</h3><p>当在遍历数组时,只有当满足一定的条件才在断点处停止</p>
<p><img src="/2019/02/28/idea-debug/856154-20170905165253944-1162138475.png" alt></p>
<p>在断点上右键直接设置当前断点的条件</p>
<h2 id="多线程调试"><a href="#多线程调试" class="headerlink" title="多线程调试"></a>多线程调试</h2><p>待施工…..</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/28/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-28T18:04:45+08:00">
                2019-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">fjh</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fjh</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
