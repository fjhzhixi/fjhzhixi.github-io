<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="OS,">










<meta name="description" content="lab5做了什么 基于磁盘的硬件构成实现通过I/O接口驱动来与磁盘外设进行交互(主要是屏蔽丑陋的硬件,提供统一的读写接口) 基于I/O交互以及磁盘的空间搭建文件系统结构(本质上就是用数据结构管理磁盘的空间) 基于文件系统来向用户提供操作的接口(以系统调用的形式)  具体实现外部存储设备驱动这部分很依赖于底层硬件的构成标准 磁盘寻址的原理这部分我们OS实现不用考虑权当复习理论课了 地址表达一个扇区大">
<meta name="keywords" content="OS">
<meta property="og:type" content="article">
<meta property="og:title" content="OS-lab5">
<meta property="og:url" content="http://yoursite.com/2019/05/21/OS-lab5/index.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:description" content="lab5做了什么 基于磁盘的硬件构成实现通过I/O接口驱动来与磁盘外设进行交互(主要是屏蔽丑陋的硬件,提供统一的读写接口) 基于I/O交互以及磁盘的空间搭建文件系统结构(本质上就是用数据结构管理磁盘的空间) 基于文件系统来向用户提供操作的接口(以系统调用的形式)  具体实现外部存储设备驱动这部分很依赖于底层硬件的构成标准 磁盘寻址的原理这部分我们OS实现不用考虑权当复习理论课了 地址表达一个扇区大">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/05/21/OS-lab5/disk.png">
<meta property="og:image" content="http://yoursite.com/2019/05/21/OS-lab5/IDE-regs.png">
<meta property="og:image" content="http://yoursite.com/2019/05/21/OS-lab5/w-r.png">
<meta property="og:image" content="http://yoursite.com/2019/05/21/OS-lab5/dis_mm.png">
<meta property="og:image" content="http://yoursite.com/2019/05/21/OS-lab5/data_point.png">
<meta property="og:image" content="http://yoursite.com/2019/05/21/OS-lab5/gen_file.png">
<meta property="og:image" content="http://yoursite.com/2019/05/21/OS-lab5/main_call.png">
<meta property="og:image" content="http://yoursite.com/2019/05/21/OS-lab5/file_struct.png">
<meta property="og:image" content="http://yoursite.com/2019/05/21/OS-lab5/fd_struct.png">
<meta property="og:image" content="http://yoursite.com/2019/05/21/OS-lab5/struct.png">
<meta property="og:image" content="http://yoursite.com/2019/05/21/OS-lab5/ipc.png">
<meta property="og:image" content="http://yoursite.com/2019/05/21/OS-lab5/open.png">
<meta property="og:updated_time" content="2019-05-21T15:36:27.504Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OS-lab5">
<meta name="twitter:description" content="lab5做了什么 基于磁盘的硬件构成实现通过I/O接口驱动来与磁盘外设进行交互(主要是屏蔽丑陋的硬件,提供统一的读写接口) 基于I/O交互以及磁盘的空间搭建文件系统结构(本质上就是用数据结构管理磁盘的空间) 基于文件系统来向用户提供操作的接口(以系统调用的形式)  具体实现外部存储设备驱动这部分很依赖于底层硬件的构成标准 磁盘寻址的原理这部分我们OS实现不用考虑权当复习理论课了 地址表达一个扇区大">
<meta name="twitter:image" content="http://yoursite.com/2019/05/21/OS-lab5/disk.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/21/OS-lab5/">





  <title>OS-lab5 | Matrix</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Matrix</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">just do it !</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/21/OS-lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OS-lab5</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-21T23:33:16+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="lab5做了什么"><a href="#lab5做了什么" class="headerlink" title="lab5做了什么"></a>lab5做了什么</h1><ol>
<li>基于磁盘的硬件构成实现通过<code>I/O</code>接口<strong>驱动</strong>来与磁盘外设进行交互(主要是<strong>屏蔽丑陋的硬件,提供统一的读写接口</strong>)</li>
<li>基于<code>I/O</code>交互以及磁盘的空间搭建文件系统结构(本质上就是用<strong>数据结构</strong>管理磁盘的空间)</li>
<li>基于文件系统来向用户提供操作的接口(以<strong>系统调用</strong>的形式)</li>
</ol>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="外部存储设备驱动"><a href="#外部存储设备驱动" class="headerlink" title="外部存储设备驱动"></a>外部存储设备驱动</h2><p>这部分很依赖于底层硬件的构成标准</p>
<h3 id="磁盘寻址的原理"><a href="#磁盘寻址的原理" class="headerlink" title="磁盘寻址的原理"></a>磁盘寻址的原理</h3><p><del>这部分我们OS实现不用考虑权当复习理论课了</del></p>
<h4 id="地址表达"><a href="#地址表达" class="headerlink" title="地址表达"></a>地址表达</h4><p>一个扇区大小(<strong>有效数据大小为一块即512字节</strong>)为最小的数据交换单元</p>
<ul>
<li><p>物理磁盘使用柱面,磁道,扇区构成<strong>物理地址</strong>来定位一个块, 即</p>
<p><strong>某一磁盘寻址依赖于</strong> : (括号中均为常量)</p>
<ol>
<li>柱面号<code>C_index</code>(一共有<code>C_num</code>个柱面)</li>
<li>磁头号<code>H_index</code>(一共有<code>H_num</code>层磁头)</li>
<li>扇区号<code>S_index</code>(一个磁道有<code>S_num</code>个扇区)</li>
</ol>
<p><img src="/2019/05/21/OS-lab5/disk.png" alt></p>
</li>
<li><p>而<strong>逻辑地址</strong>则将所有扇区抽象成连续的块结构<strong>通过偏移获取</strong></p>
<p><strong>抽象规则为 : <code>offset = C_index * H_num + H_index * S_num + S_index</code></strong></p>
</li>
</ul>
<h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><ol>
<li>OS发出的请求 : 盘号<code>diskno</code> + 偏移<code>offset</code></li>
<li>由盘号定位到某一磁盘接受之后寻址 : <ul>
<li><strong>由逻辑地址向物理地址转换 : </strong><ol>
<li><code>C_index = offset / (H_num * S_num)</code></li>
<li><code>H_index = (offset % (H_num * S_num)) / S_num</code></li>
<li><code>S_index = (offset % (H_num * S_num)) % S_num</code></li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="OS与外设交互的机制"><a href="#OS与外设交互的机制" class="headerlink" title="OS与外设交互的机制"></a>OS与外设交互的机制</h3><p><strong>通过读写设备上的寄存器来进行数据通信</strong> :</p>
<ol>
<li>外设寄存器也称为 I/O 端口，我们使用 I/O 端口来访问 I/O 设备</li>
<li>外设寄存器通常包括控制寄存器、状态寄存器和数据寄存器</li>
<li><strong>这些硬件 I/O 寄存器被映射到指定的物理内存空间(理论上你可以选择映射到任何内核虚拟空间,但由于无缓存我们选择映射到<code>kseg1</code>),即当我们访问这段物理地址时,<code>CPU</code>就会知道其对应的实际物理空间对应的不是物理内存,而是外设中的外设寄存器,例如在读数据时外设将数据写入其内部的存储空间,而我们从<code>kseg1</code>中直接按虚拟地址读取就可以了</strong></li>
</ol>
<p><strong>故我们读写某一固定的物理内存(固定值取决于外设种类对应的规定)就相当于读写外设的寄存器这样我们就能控制其行为</strong></p>
<h3 id="IDE磁盘在硬件层次的规定"><a href="#IDE磁盘在硬件层次的规定" class="headerlink" title="IDE磁盘在硬件层次的规定"></a>IDE磁盘在硬件层次的规定</h3><ul>
<li><p>其映射到的物理内存区域是<code>[0x13000000, 0x13004200)</code></p>
</li>
<li><p>在CPU访问时使用的只能是虚拟地址,所以我们要把这块区域<strong>映射到内核空间的<code>kseg1</code>中(因为这片空间是内核中的,映射固定(加偏移即可),并且数据不会被缓存</strong>,<code>kesg</code>的起始地址为<code>0xA0000000</code>,<strong>所以磁盘外设寄存器对应的虚拟地址为<code>[0xB3000000, 0xB3004200)</code></strong></p>
<p>注意这个映射到的虚拟地址是我们选择的,基于<strong>内核空间所有用户进程都可以访问以及这片虚拟内存不存在缓存</strong></p>
<p><strong>注意在此处涉及内核虚拟地址向物理地址的转换(由硬件实现),其规则如下(<del>我猜的</del>) : </strong></p>
<ul>
<li>对<code>kseg0</code>中的内核虚拟地址通过最高位清0 : 所以我们在之前通过加<code>0x8000_0000</code>实现物理地址映射到<code>kseg0</code></li>
<li><strong>对<code>kseg1</code>中的内核虚拟地址通过最高3位清0 : 所以<code>[0xB3000000, 0xB3004200)</code>即对应物理地址<code>[0x13000000, 0x13004200)</code></strong></li>
</ul>
</li>
<li><p>磁盘各个外设寄存器的意义 : </p>
<p><img src="/2019/05/21/OS-lab5/IDE-regs.png" alt></p>
<p>注意实际上我们只有一块磁盘,所以<code>IDE ID</code>恒为0</p>
</li>
<li><p>所以我们的对磁盘的<code>I/O</code>操作就如下图</p>
<p><img src="/2019/05/21/OS-lab5/w-r.png" alt></p>
</li>
</ul>
<p><strong>注意此处有一点我没有想通的机制 : 就是我们认为从磁盘中读取数据和向磁盘写入数据都是瞬间完成的,没有延时,所以没有实现<code>CPU</code>轮询状态位或者磁盘通知<code>CPU</code>中断类似的机制,我猜时因为我们的外设磁盘是仿真模拟的,所以讲问题简化了</strong></p>
<h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><ol>
<li>实现<strong>用户态对外设寄存器(表现为一段物理地址内存)进行读写的系统调用</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/syscall_all.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_write_dev</span><span class="params">(<span class="keyword">int</span> sysno, u_int va, u_int dev, u_int len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((dev &gt;= <span class="number">0x10000000</span> &amp;&amp; (dev + len - <span class="number">1</span>) &lt; <span class="number">0x10000020</span>) ||</span><br><span class="line">        (dev &gt;= <span class="number">0x13000000</span> &amp;&amp; (dev + len - <span class="number">1</span>) &lt; <span class="number">0x13004200</span>) ||</span><br><span class="line">        (dev &gt;= <span class="number">0x15000000</span> &amp;&amp; (dev + len - <span class="number">1</span>) &lt; <span class="number">0x15000200</span>)) &#123;</span><br><span class="line">        u_long dev_va = dev + <span class="number">0xa0000000</span>;<span class="comment">//将设备物理地址映射到内核kseg1空间</span></span><br><span class="line">        bcopy(va, dev_va, len);<span class="comment">//将va对应的虚拟内存地址之后长len字节的数据写入设备物理地址dev</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_write_dev</span><span class="params">(<span class="keyword">int</span> sysno, u_int va, u_int dev, u_int len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((dev &gt;= <span class="number">0x10000000</span> &amp;&amp; (dev + len - <span class="number">1</span>) &lt; <span class="number">0x10000020</span>) ||</span><br><span class="line">        (dev &gt;= <span class="number">0x13000000</span> &amp;&amp; (dev + len - <span class="number">1</span>) &lt; <span class="number">0x13004200</span>) ||</span><br><span class="line">        (dev &gt;= <span class="number">0x15000000</span> &amp;&amp; (dev + len - <span class="number">1</span>) &lt; <span class="number">0x15000200</span>)) &#123;</span><br><span class="line">        u_long dev_va = dev + <span class="number">0xa0000000</span>;<span class="comment">//将设备物理地址映射到内核kseg1空间</span></span><br><span class="line">        bcopy(dev_va, va, len);<span class="comment">//从设备物理地址dev中读出长len字节的数据写入va对应的虚拟地址中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>实现<strong>用户态</strong>下的磁盘驱动,<strong>对磁盘设备的空间的访问要基于之前实现的用户态系统调用</strong>(因为设备映射的是内核虚拟空间,用户态不能直接访问内核虚拟地址,所以要通过系统调用)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/ide.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ide_read</span><span class="params">(u_int diskno, u_int secno, <span class="keyword">void</span> *dst, u_int nsecs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0x200表示512字节,这是一个扇区的大小</span></span><br><span class="line">	<span class="keyword">int</span> offset_begin = secno * <span class="number">0x200</span>;<span class="comment">//初始扇区地址偏移</span></span><br><span class="line">	<span class="keyword">int</span> offset_end = offset_begin + nsecs * <span class="number">0x200</span>;<span class="comment">//最后一个扇区地址偏移</span></span><br><span class="line">	<span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(offset_begin + offset &lt; offset_end)</span><br><span class="line">	&#123;</span><br><span class="line">         syscall_write_dev(&amp;diskno, <span class="number">0x13000010</span>, <span class="number">4</span>);<span class="comment">//写入磁盘号,理论上恒为0(因为只有一个磁盘)</span></span><br><span class="line">         <span class="keyword">int</span> va = offset_begin + offset;</span><br><span class="line">         syscall_write_dev(&amp;va, <span class="number">0x13000000</span>, <span class="number">4</span>);<span class="comment">//写入偏移量决定操作的磁盘空间位置</span></span><br><span class="line">         <span class="keyword">char</span> operate = <span class="number">0</span>;</span><br><span class="line">         syscall_write_dev(&amp;operate, <span class="number">0x13000020</span>, <span class="number">1</span>);<span class="comment">//写入操作数为0表示读</span></span><br><span class="line">         syscall_read_dev(&amp;va, <span class="number">0x13000030</span>, <span class="number">4</span>);<span class="comment">//读取状态值</span></span><br><span class="line">		<span class="keyword">if</span> (va != <span class="number">0</span>)<span class="comment">//读操作成功,此时数据已经存到了磁盘外设寄存器中</span></span><br><span class="line">		&#123;<span class="comment">//对于读操作先启动磁盘将数据从由offset决定的扇区读出写入磁盘buffer再从buffer中读出到目标用户地址dst中</span></span><br><span class="line">			syscall_read_dev(dst + offset, <span class="number">0x13004000</span>, <span class="number">0x200</span>);</span><br><span class="line">			offset += <span class="number">0x200</span>;		</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			user_panic(<span class="string">"disk I/O error"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ide_write</span><span class="params">(u_int diskno, u_int secno, <span class="keyword">void</span> *src, u_int nsecs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i<span class="comment">//0x200表示512字节,这是一个扇区的大小</span></span><br><span class="line">	<span class="keyword">int</span> offset_begin = secno * <span class="number">0x200</span>;<span class="comment">//初始扇区地址偏移</span></span><br><span class="line">	<span class="keyword">int</span> offset_end = offset_begin + nsecs * <span class="number">0x200</span>;<span class="comment">//最后一个扇区地址偏移</span></span><br><span class="line">	<span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(offset_begin + offset &lt; offset_end)</span><br><span class="line">	&#123;</span><br><span class="line">         syscall_write_dev(&amp;diskno, <span class="number">0x13000010</span>, <span class="number">4</span>);<span class="comment">//写入磁盘号,理论上恒为0(因为只有一个磁盘)</span></span><br><span class="line">         <span class="keyword">int</span> va = offset_begin + offset;</span><br><span class="line">         syscall_write_dev(&amp;va, <span class="number">0x13000000</span>, <span class="number">4</span>);<span class="comment">//写入偏移量决定操作的磁盘空间位置</span></span><br><span class="line">         <span class="comment">//对于写操作先将要写入的数据写到磁盘外设寄存器中的buffer中,在向磁盘写入操作位磁盘自身从buffer中读取数据写入由offset决定的扇区中</span></span><br><span class="line">         syscall_write_dev(src + offset, <span class="number">0x13004000</span>, <span class="number">0x200</span>);</span><br><span class="line">         <span class="keyword">char</span> operate = <span class="number">1</span>;</span><br><span class="line">         syscall_write_dev(&amp;operate, <span class="number">0x13000020</span>, <span class="number">1</span>);<span class="comment">//写入操作数为1表示写</span></span><br><span class="line">         syscall_read_dev(&amp;va, <span class="number">0x13000030</span>, <span class="number">4</span>);<span class="comment">//读取状态值</span></span><br><span class="line">		<span class="keyword">if</span> (va != <span class="number">0</span>) &#123;<span class="comment">//写操作成功</span></span><br><span class="line">			offset += <span class="number">0x200</span>;		</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			user_panic(<span class="string">"disk I/O error"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统实现<strong>对磁盘的空间以文件的形式组织管理</strong></p>
<p><img src="/2019/05/21/OS-lab5/dis_mm.png" alt></p>
<h3 id="磁盘在物理和逻辑层次上的表示"><a href="#磁盘在物理和逻辑层次上的表示" class="headerlink" title="磁盘在物理和逻辑层次上的表示"></a>磁盘在物理和逻辑层次上的表示</h3><p>我们将磁盘的空间抽象成了文件的形式,在物理层次和逻辑层次磁盘空间有不同的划分 :</p>
<ul>
<li><p>物理上 : <strong>以扇区划分,大小为<code>512B</code></strong></p>
<ol>
<li><strong>扇区是块设备传输数据的基本单元</strong>,也就是说它是块设备中最小的寻址单位</li>
<li>体现 : 在磁盘驱动实现中每次偏移加<code>0x200</code></li>
</ol>
</li>
<li><p>逻辑上 : <strong>以数据块划分,大小为<code>4KB</code></strong></p>
<ol>
<li><strong>块是内核对文件系统的一种抽象</strong>,也就是说<code>OS</code>执行的所有磁盘操作都是以块为基本单位的.</li>
<li>体现 : 文件控制块中的数据指针每个指向<code>4KB</code>大小的空间</li>
</ol>
</li>
<li><p><strong>关系</strong> :</p>
<p><strong>扇区是硬件设备传输数据的最小单位,而块是操作系统传输数据的最小单位。一个块通常对应一个或多个相邻的扇区</strong></p>
</li>
</ul>
<h3 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h3><ol>
<li><p>超级块结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/fs.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">	u_int s_magic;		<span class="comment">//魔数用来校验是否合法</span></span><br><span class="line">	u_int s_nblocks;	<span class="comment">//保存该磁盘中的数据块个数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span>	<span class="comment">//文件结构的根目录</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="位图结构"><a href="#位图结构" class="headerlink" title="位图结构"></a>位图结构</h3><p>在该实验中我们使用<code>u_int *bitmap</code>(在<code>fs.c</code>中定义)来实现位图结构</p>
<p><strong>位图结构用来标记某一数据块是否被使用过,一位代表一个数据块, 为1表示空闲,为0表示不可被使用</strong></p>
<ol>
<li><p>初始化 : </p>
<p>所有的存在的块对应的标记位为1,<strong>注意最后一个块标记位之后的位标记为0</strong></p>
</li>
<li><p>释放块,即将对应的标记位标记位1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fs.c</span></span><br><span class="line">u_int *bitmap; <span class="comment">//使用一个int型的数组来实现bitmap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_block</span><span class="params">(u_int blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (blockno==<span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">//0号块是启动引导扇区不允许释放</span></span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	 1. bitmap是int型数组,一个元素占据32位,所以(块号/32)得到表示的整数在数组中的下标</span></span><br><span class="line"><span class="comment">    	 2. (blockno % 32)得到对应的在该整数中的偏移</span></span><br><span class="line"><span class="comment">    	 3. 按位或上 1&lt;&lt;(blockno % 32) [100...00] 即可将对应位设置为1</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        bitmap[blockno/<span class="number">32</span>] = bitmap[blockno/<span class="number">32</span>] | (<span class="number">1</span>&lt;&lt;(blockno%<span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h3><ol>
<li><p>结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/fs.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNAMELEN	128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDIRECT		10</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">	u_char f_name[MAXNAMELEN];	<span class="comment">//文件名</span></span><br><span class="line">	u_int f_size;			   <span class="comment">//文件包含的数据块的字节大小</span></span><br><span class="line">	u_int f_type;			   <span class="comment">//文件的类型</span></span><br><span class="line">	u_int f_direct[NDIRECT];    <span class="comment">//10个直接的数据指针,指向磁盘中组成文件的数据块</span></span><br><span class="line">	u_int f_indirect;		   <span class="comment">//当文件内容过大时使用间接数据指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span>		</span><br><span class="line">	u_char f_pad[<span class="number">256</span>-MAXNAMELEN<span class="number">-4</span><span class="number">-4</span>-NDIRECT*<span class="number">4</span><span class="number">-4</span><span class="number">-4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>直接指针 : 一共有10个,每个指向一个<code>4KB</code>的数据块,所以<strong>只通过直接数据指针最大表示<code>40KB</code>大小的文件</strong></p>
</li>
<li><p>间接指针 : 当文件大小超过<code>40KB</code>时使用 : <strong>其为一个指向(存储(指向(存储文件内容的磁盘块)的指针)的数据块)的指针)</strong>,间接指针指向的还是有个块,但是其<strong>特殊之处在于该块中存储的不是文件的数据内容,而是指向存储文件数据内容的块的指针们</strong></p>
<p>为方便起见在该<strong>特殊的数据块中我们前10个指针缺省,这些由直接指针实现功能</strong></p>
</li>
</ul>
<p><img src="/2019/05/21/OS-lab5/data_point.png" alt></p>
</li>
</ol>
<p><strong>注意</strong> :</p>
<ol>
<li>在我们的体系中, <strong>目录也是文件,是一种特殊的文件而已,特殊之处在于 : </strong><ul>
<li><strong>一般文件的控制块指针指向的数据块存储的是文件自身的数据</strong></li>
<li><strong>目录文件的控制块指针指向的数据块存储的是其目录下包含的文件(或者文件目录)的控制块</strong></li>
</ul>
</li>
<li>我们是用<strong>数组的形式将数据块组织起来的</strong>,所以在文件控制块中我们所谓的指向<strong>数据块的指针其实就是保存该数据块的数组下标即可</strong>(之后统一用指针表达比较形象)</li>
</ol>
<h3 id="如何构建一个文件"><a href="#如何构建一个文件" class="headerlink" title="如何构建一个文件"></a>如何构建一个文件</h3><p>该功能的实现是在<code>fsformat.c</code>中实现,其作用是<strong>基于数个已经存在的源文件将其组织成磁盘上的文件的形式,最后生成<code>fs.img</code>磁盘文件</strong></p>
<h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><ol>
<li>初始化磁盘结构 : <ul>
<li>第一个磁盘块为<code>boot</code>启动块</li>
<li>第二个磁盘块为记录数据块使用情况的位图<code>map</code>块</li>
<li>第三个磁盘块为保存<code>super</code>块</li>
</ul>
</li>
<li>对每个源文件 : <ul>
<li>填写文件控制块</li>
<li>拷贝数据块并建立链接指针</li>
</ul>
</li>
<li>初始位图,标记已经使用的数据块</li>
<li>将构造好的磁盘结构生成文件<code>fs.img</code>文件</li>
</ol>
<p><strong>图示</strong> :</p>
<p><img src="/2019/05/21/OS-lab5/gen_file.png" alt></p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fsformat.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Super</span> <span class="title">Super</span>;</span> <span class="comment">//超级块结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">File</span>;</span>   <span class="comment">//文件控制块结构</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BY2BLK		BY2PG<span class="comment">//4096,即一个块的字节(Byte)数,一个块4KB大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT2BLK		(BY2BLK*8)<span class="comment">//一个块中的位数(Bit)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBLOCK 1024 <span class="comment">// 一个磁盘中的数据块的数目</span></span></span><br><span class="line"><span class="keyword">uint32_t</span> nbitblock; <span class="comment">// bitmap位图结构占据的数据块个数</span></span><br><span class="line"><span class="keyword">uint32_t</span> nextbno;   <span class="comment">// 始终指向当前第一个可用的数据块结构</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> <span class="title">super</span>;</span><span class="comment">//超级块结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;<span class="comment">//块存储的都是数据,但是数据的含义不同</span></span><br><span class="line">    BLOCK_FREE  = <span class="number">0</span>,<span class="comment">//空闲块</span></span><br><span class="line">    BLOCK_BOOT  = <span class="number">1</span>,<span class="comment">//根目录块</span></span><br><span class="line">    BLOCK_BMAP  = <span class="number">2</span>,<span class="comment">//位图结构块</span></span><br><span class="line">    BLOCK_SUPER = <span class="number">3</span>,<span class="comment">//超级块</span></span><br><span class="line">    BLOCK_DATA  = <span class="number">4</span>,<span class="comment">//存储文件数据块</span></span><br><span class="line">    BLOCK_FILE  = <span class="number">5</span>,<span class="comment">//存储文件控制块的块</span></span><br><span class="line">    BLOCK_INDEX = <span class="number">6</span>,<span class="comment">//存储文件控制块中的间接数据指针的块</span></span><br><span class="line">&#125;;<span class="comment">//表示数据块的类型</span></span><br><span class="line"><span class="comment">//与所有数据块对应的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> data[BY2BLK];<span class="comment">//字节数组</span></span><br><span class="line">    <span class="keyword">uint32_t</span> type;</span><br><span class="line">&#125; disk[NBLOCK];<span class="comment">//该数组结构代表一个磁盘中所有可用的数据块</span></span><br></pre></td></tr></table></figure>
<p><strong>注意 : 一个<code>block</code>中存储的数据有多种含义</strong></p>
<h4 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h4><p>函数调用图示 :</p>
<h5 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h5><ol>
<li><p><code>next_block(int type)</code> : 获得<strong>当前可用的第一个数据块下标返回,并设定该块的使用类型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next_block</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    disk[nextbno].type = type;</span><br><span class="line">    <span class="keyword">return</span> nextbno++;<span class="comment">//先return再+++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>save_block_link(struct File *f, int nblk, int bno)</code> : <strong>将第<code>bno</code>个数据块链接到<code>f</code>文件的第<code>nblk</code>个指针</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_block_link</span><span class="params">(struct File *f, <span class="keyword">int</span> nblk, <span class="keyword">int</span> bno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(nblk &lt; NINDIRECT);</span><br><span class="line">    <span class="keyword">if</span>(nblk &lt; NDIRECT) &#123;<span class="comment">//当可以用直接指针表示时</span></span><br><span class="line">        f-&gt;f_direct[nblk] = bno;<span class="comment">//建立映射</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(f-&gt;f_indirect == <span class="number">0</span>) &#123;<span class="comment">//当第一次用间接指针表示时</span></span><br><span class="line">            f-&gt;f_indirect = next_block(BLOCK_INDEX);<span class="comment">//为间接指针分配一个数据块用来存储指向数据块的指针,实际上就是给f_indirect赋值一个空闲块的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*通过disk[f-&gt;f_indirect].data获得存储指针的数据块的数据数组</span></span><br><span class="line"><span class="comment">         *注意此处的强制类型转换不可以少,因为data[]自身是字节数组,但是一个bno占一个字大小</span></span><br><span class="line"><span class="comment">         *所以要(uint32_t *)之后再通过[nblk]索引</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ((<span class="keyword">uint32_t</span> *)(disk[f-&gt;f_indirect].data))[nblk] = bno;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明 : </p>
<ul>
<li><code>#define NINDIRECT  (BY2BLK/4)</code> : <code>NINDIRECT</code>值为1024,即一个文件<strong>最多外接1024个数据块</strong>,这是因为一个文件控制块只有一个间接指针,指向一个<code>4KB</code>大小的存储指针的块,而一个指针<code>4B</code>大小,所以最多存储1024个指向数据块的指针</li>
<li><code>#define NDIRECT 10</code> : 表示一个文件控制块有10个直接指针</li>
</ul>
</li>
<li><p><code>make_link_block(struct File *dirf, int nblk)</code> : <strong>该函数是对目录文件的操作(第一个参数)</strong></p>
<p>为该目录文件控制块的<code>nblk</code>指针<strong>分配一块存储目录下属文件的控制块的块</strong>,增加目录文件的大小并返回分配的块的下标</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_link_block</span><span class="params">(struct File *dirf, <span class="keyword">int</span> nblk)</span> </span>&#123;</span><br><span class="line">    save_block_link(dirf, nblk, nextbno);</span><br><span class="line">    dirf-&gt;f_size += BY2BLK;</span><br><span class="line">    <span class="keyword">return</span> next_block(BLOCK_FILE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>create_file(struct File *dirf)</code> : <strong>该函数是对目录文件的操作(第一个参数)</strong></p>
<p><strong>在目录文件<code>dirf</code>中找到一个可以写入(所属文件的控制块)的空闲数据块地址,返回该地址[当不存在空闲数据区域时新分配数据块用来保存文件控制块]</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct File *<span class="title">create_file</span><span class="params">(struct File *dirf)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dirblk</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i, bno, found;</span><br><span class="line">    <span class="keyword">int</span> nblk = dirf-&gt;f_size / BY2BLK;<span class="comment">//获得当前目录文件有效的数据指针个数</span></span><br><span class="line">    <span class="keyword">if</span>(nblk == <span class="number">0</span>) &#123;<span class="comment">//该目录文件没有数据块,使用make_link_block分配,此时nblk = 0</span></span><br><span class="line">        <span class="keyword">return</span> (struct File *)(disk[make_link_block(dirf, <span class="number">0</span>)].data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nblk &lt;= NDIRECT) &#123;<span class="comment">//还在使用直接数据块指针阶段</span></span><br><span class="line">        bno = dirf-&gt;f_direct[nblk<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//使用间接数据块指针</span></span><br><span class="line">        bno = ((<span class="keyword">uint32_t</span> *)(disk[dirf-&gt;f_indirect].data))[nblk<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//至此获得当前文件最后一个数据块的下标,</span></span><br><span class="line">    <span class="comment">/*之后按文件控制块的大小遍历该数据块</span></span><br><span class="line"><span class="comment">     *检查文件名是否为空来确定是否是空闲文件控制块</span></span><br><span class="line"><span class="comment">     *返回找到的第一个空闲文件控制块的指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    dirblk = (struct File *)(disk[bno].data);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; FILE2BLK; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dirblk[i].f_name[<span class="number">0</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">            <span class="comment">// found spare file link.</span></span><br><span class="line">            <span class="keyword">return</span> &amp;dirblk[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*当最后一个数据块没有空闲文件控制块时</span></span><br><span class="line"><span class="comment">     *给目录文件使用make_link_block新分配一个</span></span><br><span class="line"><span class="comment">     *返回新数据块的首地址(以文件控制块指针的形式)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> (struct File *)(disk[make_link_block(dirf, nblk)].data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意 : 有如下的关系</strong> :</p>
<ul>
<li><strong><code>f_size = nblk * BY2BLK</code> : <code>nblk</code>为该(目录)文件有效的数据块指针的个数</strong></li>
</ul>
</li>
</ol>
<h5 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h5><p><img src="/2019/05/21/OS-lab5/main_call.png" alt></p>
<ol>
<li><p><code>main</code>函数 : 运行生成磁盘镜像文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*参数的含义</span></span><br><span class="line"><span class="comment">     *第一个参数为文件名本身argv[0]</span></span><br><span class="line"><span class="comment">     *第二个参数是产生的磁盘镜像的目标文件路径argv[1]</span></span><br><span class="line"><span class="comment">     *之后的参数是基于的源文件argv[2]...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    init_disk();	<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">"-r"</span>) == <span class="number">0</span> &amp;&amp; argc != <span class="number">4</span>) &#123;<span class="comment">//参数错误</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\Usage: fsformat gxemul/fs.img files...\n\fsformat gxemul/fs.img -r DIR\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">"-r"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">            write_directory(&amp;super.s_root, argv[i]);<span class="comment">//不要求实现</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">            write_file(&amp;super.s_root, argv[i]);<span class="comment">//逐个读取源文件以磁盘文件的形式组织起来</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flush_bitmap();<span class="comment">//改变位图控制块</span></span><br><span class="line">    finish_fs(argv[<span class="number">1</span>]);<span class="comment">//生成目标文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>init_disk()</code> : 初始化磁盘结构</p>
<ul>
<li>第一个块初始化为<code>boot</code></li>
<li>第二个块初始化为<code>super</code></li>
<li>之后若干个需要大小的块初始化为<code>bitmap</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_disk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, r, diff;</span><br><span class="line">    <span class="comment">//第一个块为boot结构</span></span><br><span class="line">    disk[<span class="number">0</span>].type = BLOCK_BOOT;</span><br><span class="line">    <span class="comment">//建立bitmap结构</span></span><br><span class="line">    <span class="comment">//NBLOCK为块的数目,所以应该分配NBLOCK个bit大小来存储bitmap结构</span></span><br><span class="line">    <span class="comment">//(+ BIT2BLK - 1)的操作是因为当填不满某一块时也要分配给bitmap(剩余一部分)</span></span><br><span class="line">    nbitblock = (NBLOCK + BIT2BLK - <span class="number">1</span>) / BIT2BLK;</span><br><span class="line">    nextbno = <span class="number">2</span> + nbitblock;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nbitblock; ++i) &#123;</span><br><span class="line">        disk[<span class="number">2</span>+i].type = BLOCK_BMAP;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//标记可用的位(前3个块在最后标记为不可用)</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nbitblock; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(disk[<span class="number">2</span>+i].data, <span class="number">0xff</span>, NBLOCK/<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当多余的无效的位都标记为0表示不可用</span></span><br><span class="line">    <span class="keyword">if</span>(NBLOCK != nbitblock * BY2BLK) &#123;</span><br><span class="line">        diff = NBLOCK % BY2BLK / <span class="number">8</span>;</span><br><span class="line">        <span class="built_in">memset</span>(disk[<span class="number">2</span>+(nbitblock<span class="number">-1</span>)].data+diff, <span class="number">0x00</span>, BY2BLK - diff);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化super块中的数据</span></span><br><span class="line">    disk[<span class="number">1</span>].type = BLOCK_SUPER;</span><br><span class="line">    super.s_magic = FS_MAGIC;</span><br><span class="line">    super.s_nblocks = NBLOCK;</span><br><span class="line">    super.s_root.f_type = FTYPE_DIR;</span><br><span class="line">    <span class="built_in">strcpy</span>(super.s_root.f_name, <span class="string">"/"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>write_file(struct File *dirf, const char *path)</code> : <strong>将<code>path</code>指定的文件写入<code>dirf</code>文件目录之下</strong></p>
<ol>
<li>为文件新建一个控制块并加入到<code>dirf</code>目录文件中(<code>create_file</code>实现)</li>
<li>填写新建的文件控制块的各个数据域</li>
<li>将文件中的内容拷贝到数据块中并<strong>建立到新建文件控制块的链接</strong> (<code>save_block_link</code>实现)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_file</span><span class="params">(struct File *dirf, <span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iblk = <span class="number">0</span>, r = <span class="number">0</span>, n = <span class="keyword">sizeof</span>(disk[<span class="number">0</span>].data);</span><br><span class="line">    <span class="keyword">uint8_t</span> buffer[n+<span class="number">1</span>], *dist;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">target</span> = <span class="title">create_file</span>(<span class="title">dirf</span>);</span><span class="comment">//将target文件控制块加入dirf目录文件中</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(path, O_RDONLY);<span class="comment">//该处的open是在fcntl.h标准头文件中包含的C标准函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fname = <span class="built_in">strrchr</span>(path, <span class="string">'/'</span>);<span class="comment">//获得最后一个/的位置</span></span><br><span class="line">    <span class="keyword">if</span>(fname)</span><br><span class="line">        fname++;<span class="comment">//找到了之后该位置之后的字符串就是文件名</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fname = path;<span class="comment">//没找到则该path就是顶层,本身就是文件名</span></span><br><span class="line">    <span class="built_in">strcpy</span>(target-&gt;f_name, fname);<span class="comment">//向文件控制块写入文件名</span></span><br><span class="line">    target-&gt;f_size = lseek(fd, <span class="number">0</span>, SEEK_END);<span class="comment">//将文件指针移动到文件末尾,获得文件的大小</span></span><br><span class="line">    target-&gt;f_type = FTYPE_REG;<span class="comment">//该文件类型为常规类型</span></span><br><span class="line">    <span class="comment">//开始遍历path得到的文件将其中的内容写入文件控制块指向的数据块中</span></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);<span class="comment">//将参数移动到文件的头部(偏移为0)</span></span><br><span class="line">    <span class="keyword">while</span>((r = read(fd, disk[nextbno].data, n)) &gt; <span class="number">0</span>) &#123;<span class="comment">//将fd文件中读出的数据写入到disk[nextbno].data中,一次写入一个data块大小(n字节)</span></span><br><span class="line">        save_block_link(target, iblk++, next_block(BLOCK_DATA));<span class="comment">//建立数据块到所属文件控制块的映射</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>flush_bitmap</code> : 将使用过的数据块在位图管理结构<code>bitmap</code>中标记为已使用的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_bitmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//nextbo为使用过的数据块个数</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nextbno; ++i) &#123;</span><br><span class="line">        ((<span class="keyword">uint32_t</span> *)disk[<span class="number">2</span>+i/BIT2BLK].data)[(i%BIT2BLK)/<span class="number">32</span>] &amp;= ~(<span class="number">1</span>&lt;&lt;(i%<span class="number">32</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>finish_fs(char *name)</code> : <strong>根据之前组织好的内存中的数据生成磁盘镜像文件</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish_fs</span><span class="params">(<span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, i, k, n, r;</span><br><span class="line">    <span class="keyword">uint32_t</span> *p;</span><br><span class="line">    <span class="built_in">memcpy</span>(disk[<span class="number">1</span>].data, &amp;super, <span class="keyword">sizeof</span>(super));<span class="comment">//将super放入磁盘第一个数据块</span></span><br><span class="line">    fd = open(name, O_RDWR|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i) &#123;</span><br><span class="line">        reverse_block(disk+i);</span><br><span class="line">        write(fd, disk[i].data, BY2BLK);<span class="comment">//将数据块内容写入文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>最后的文件结构为 :</p>
<p><img src="/2019/05/21/OS-lab5/file_struct.png" alt></p>
<h3 id="块缓存机制"><a href="#块缓存机制" class="headerlink" title="块缓存机制"></a>块缓存机制</h3><p><strong>我们使用磁盘中的数据是通过将其加载到内存中的位置实现的,也就是说我们大部分操作还是对内存中数据进行的</strong></p>
<ol>
<li><p>映射机制</p>
<p>将<code>DISKMA1P</code>到<code>DISKMAP+DISKMAX</code>这一段虚存地址空间 <code>(0x10000000-0xcﬀﬀﬀ)</code>作为缓冲区,当磁盘读入内存时,分配相应的物理页来保存数据,映射关系直接是<strong>地址从低到高,数据块索引从小到大的线性映射</strong></p>
<p><strong>注意 : 在我们的体系中磁盘上的一个数据块大小与内存中的一页相同,都是<code>4KB</code></strong></p>
</li>
<li><p>功能函数 : </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fs.c</span></span><br><span class="line"><span class="comment">//根据数据块索引得到在内存中映射的虚拟地址</span></span><br><span class="line"><span class="function">u_int <span class="title">diskaddr</span><span class="params">(u_int blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( super &amp;&amp; blockno &gt; (super-&gt;s_nblocks)) &#123;</span><br><span class="line">                user_panic(<span class="string">"diskaddr failed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DISKMAP+blockno*BY2BLK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*判断该虚拟页是否有物理页与之对应</span></span><br><span class="line"><span class="comment"> *有返回1,没有返回0</span></span><br><span class="line"><span class="comment"> *通过判断页目录与页表的对应项是否有效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">u_int <span class="title">va_is_mapped</span><span class="params">(u_int va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((*vpd)[PDX(va)] &amp; (PTE_V)) &amp;&amp; ((*vpt)[VPN(va)] &amp; (PTE_V)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*判断该索引的数据块是否在内存中有有效的虚拟页对应</span></span><br><span class="line"><span class="comment"> *如果有返回va值,没有返回0</span></span><br><span class="line"><span class="comment"> *通过判断其映射的虚拟地址是否与物理页与之对应</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">u_int <span class="title">block_is_mapped</span><span class="params">(u_int blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u_int va = diskaddr(blockno);</span><br><span class="line">        <span class="keyword">if</span> (va_is_mapped(va)) &#123;</span><br><span class="line">                <span class="keyword">return</span> va;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*检查该虚拟地址对应的数据是否改变过</span></span><br><span class="line"><span class="comment"> *改变过返回1,否则返回0</span></span><br><span class="line"><span class="comment"> *通过检查对应页表项的dirty位来实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">u_int <span class="title">va_is_dirty</span><span class="params">(u_int va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (* vpt)[VPN(va)] &amp; PTE_D;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*判断当前块是否有效</span></span><br><span class="line"><span class="comment"> *有效则返回1,无效则返回0</span></span><br><span class="line"><span class="comment"> *根据位图结构中对应位的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">block_is_free(u_int blockno)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (super == <span class="number">0</span> || blockno &gt;= super-&gt;s_nblocks) &#123;<span class="comment">//块号超过范围</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bitmap[blockno / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">/*检查该块是否修改过</span></span><br><span class="line"><span class="comment"> *修改过返回1,否则返回0</span></span><br><span class="line"><span class="comment"> *通过检查块映射虚拟地址的dirty位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">u_int <span class="title">block_is_dirty</span><span class="params">(u_int blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u_int va = diskaddr(blockno);</span><br><span class="line">        <span class="keyword">return</span> va_is_mapped(va) &amp;&amp; va_is_dirty(va);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从磁盘中读取blockno代表的数据块到其规定的虚拟地址缓存中,并将blk的值设置为该虚拟地址的值,若是第一次加载则设置isnew为1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_block</span><span class="params">(u_int blockno, <span class="keyword">void</span> **blk, u_int *isnew)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u_int va;</span><br><span class="line">        <span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks) &#123;</span><br><span class="line">                user_panic(<span class="string">"reading non-existent block %08x\n"</span>, blockno);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//检查该块是否在位图结构中对应的位有效</span></span><br><span class="line">        <span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno)) &#123;</span><br><span class="line">                user_panic(<span class="string">"reading free block %08x\n"</span>, blockno);</span><br><span class="line">        &#125;</span><br><span class="line">        va = diskaddr(blockno);</span><br><span class="line">		<span class="comment">/*检查该块是否在虚拟内存中有有效的映射缓冲块</span></span><br><span class="line"><span class="comment">		 *如果已有映射说明磁盘中的数据已经读到了缓冲块中,只需设置isnew标记位为0即可</span></span><br><span class="line"><span class="comment">		 *如果没有映射则新分配一个物理页用来作为该块在虚拟内存中的缓冲块,并从磁盘中读取数据填入,并且设置isnew标记位1</span></span><br><span class="line"><span class="comment">		 *设置blk为作为缓存块的虚拟地址</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="keyword">if</span> (block_is_mapped(blockno)) &#123; <span class="comment">//the block is in memory</span></span><br><span class="line">                <span class="keyword">if</span> (isnew) &#123;</span><br><span class="line">                        *isnew = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                        <span class="comment">//the block is not in memory</span></span><br><span class="line">                <span class="keyword">if</span> (isnew) &#123;</span><br><span class="line">                        *isnew = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                syscall_mem_alloc(<span class="number">0</span>, va, PTE_V | PTE_R);</span><br><span class="line">                ide_read(<span class="number">0</span>, blockno * SECT2BLK, (<span class="keyword">void</span> *)va, SECT2BLK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (blk) &#123;</span><br><span class="line">                *blk = (<span class="keyword">void</span> *)va;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将第blockno块在内存中的虚拟缓存中的数据写回磁盘中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_block</span><span class="params">(u_int blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u_int va;</span><br><span class="line">        <span class="comment">//检测当前块是否存储有效的虚拟内存缓存块</span></span><br><span class="line">        <span class="keyword">if</span> (!block_is_mapped(blockno)) &#123;</span><br><span class="line">                user_panic(<span class="string">"write unmapped block %08x"</span>, blockno);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//向磁盘中写入内存中缓存区的信息</span></span><br><span class="line">        va = diskaddr(blockno);</span><br><span class="line">        ide_write(<span class="number">0</span>, blockno * SECT2BLK, (<span class="keyword">void</span> *)va, SECT2BLK);</span><br><span class="line">    	<span class="comment">//为缓存区的映射增加标记位表示修改过</span></span><br><span class="line">        syscall_mem_map(<span class="number">0</span>, va, <span class="number">0</span>, va, (PTE_V | PTE_R | PTE_LIBRARY));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*对第blockno索引的数据块在虚拟内存中建立缓存页</span></span><br><span class="line"><span class="comment"> *如果本来就存在缓存,则返回0,否则新建一页缓存,返回映射的虚拟地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">map_block</span><span class="params">(u_int blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u_int va;</span><br><span class="line">        <span class="keyword">if</span> (va = block_is_mapped(blockno)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	va = disdiskaddr(blockno);</span><br><span class="line">        <span class="keyword">return</span> syscall_mem_alloc(<span class="number">0</span>,va,PTE_V|PTE_R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*解除第blockno索引的数据块与内存中缓存块的映射(起始就是将对应虚拟内存解除与物理页的映射)</span></span><br><span class="line"><span class="comment"> *如果该虚拟内存缓存块是dirty(即被修改过的),则要先写回磁盘中去再解除映射</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unmap_block</span><span class="params">(u_int blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        u_int va;</span><br><span class="line">        <span class="keyword">if</span> (va=block_is_mapped(blockno)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!block_is_free(blockno) &amp;&amp; block_is_dirty(blockno)) &#123;</span><br><span class="line">                        write_block(blockno);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (syscall_mem_unmap(<span class="number">0</span>,va))</span><br><span class="line">                        writef(<span class="string">"unmap_block failed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        user_assert(!block_is_mapped(blockno));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放blockno索引代表的块(实际上只做了将其在位图中对应位置的位置为1表示可用)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_block</span><span class="params">(u_int blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      	<span class="comment">//第一个是boot块不允许释放</span></span><br><span class="line">        <span class="keyword">if</span> (blockno==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将对应标记位置为1</span></span><br><span class="line">        bitmap[blockno/<span class="number">32</span>] |= (<span class="number">1</span>&lt;&lt;(blockno%<span class="number">32</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在位图标记中寻找第一个空闲可用的块返回其索引值(在其使用前要将原数据写回)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_block_num</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> blockno;</span><br><span class="line">        <span class="keyword">for</span> (blockno = <span class="number">3</span>; blockno &lt; super-&gt;s_nblocks; blockno++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bitmap[blockno / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>))) &#123; </span><br><span class="line">                        bitmap[blockno / <span class="number">32</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>));</span><br><span class="line">        <span class="comment">//注意 : 我们在free_block中只是改变了bitmap中的标记位而已,所以真正要使用这个块之前要将其数据写回到磁盘中去(使用write_block来写回)</span></span><br><span class="line">                        write_block(blockno / BIT2BLK);<span class="comment">//我认为这是将要新分配的那一块写回磁盘,即不用除以BIT2BLK但是我不敢改艹</span></span><br><span class="line">                        <span class="keyword">return</span> blockno;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*分配一个可用的数据块返回其索引值,可用的含义如下:</span></span><br><span class="line"><span class="comment"> 1.在位图中标记位为1</span></span><br><span class="line"><span class="comment"> 2.已经将之间的数据写回磁盘中</span></span><br><span class="line"><span class="comment"> 3.在虚拟内存中建立了缓存块映射</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_block</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r, bno;</span><br><span class="line">        <span class="comment">//找到一个空闲的块并将值写回磁盘</span></span><br><span class="line">        <span class="keyword">if</span> ((r = alloc_block_num()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        bno = r;</span><br><span class="line">    	<span class="comment">//建立虚拟内存中的缓存</span></span><br><span class="line">        <span class="keyword">if</span> ((r = map_block(bno)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                free_block(bno);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> :</p>
<ul>
<li><p>有关有效位</p>
<ol>
<li><code>PTE_D</code> : </li>
<li><code>PTE_LIBRARY</code> : </li>
</ol>
</li>
<li><p>有关映射</p>
<ol>
<li><strong>磁盘块的索引与虚拟地址中的缓存块地址</strong>二者的映射关系是<strong>确定</strong>的,即按索引从小到大,地址按页小到大来静态映射的</li>
<li><strong>我们所说的<code>map</code>和<code>unmap</code>实质上是建立索引对应的虚拟页映射到一个有效的物理页</strong>,即保证虚拟缓存块是有效的</li>
</ol>
</li>
<li><p><strong>有关块的释放与获取</strong></p>
<ol>
<li><p>我们在释放块时只是<strong>做了将其在<code>bitmap</code>结构中的对应标记位设置为1</strong>的简单操作</p>
</li>
<li><p>当要获取一块时,我们要:</p>
<ol>
<li>在<code>bitmap</code>中找到一个标记为1(可用)的块</li>
<li><strong>将其对应的缓存内容写回磁盘中</strong></li>
<li>在虚拟内存中建立缓存块</li>
</ol>
<p><strong>至此该数据块才真正可以被分配使用</strong></p>
</li>
</ol>
<p><strong>即我们采用的是写回机制而不是写直达,也就是说当释放的块再次被使用时才将其写会磁盘中保存改动</strong></p>
</li>
</ul>
</li>
</ol>
<h3 id="对文件系统的操作"><a href="#对文件系统的操作" class="headerlink" title="对文件系统的操作"></a>对文件系统的操作</h3><p>注意区分对<strong>一般文件和对目录文件</strong>二者操作的不同</p>
<p>二者的数据结构组织相同,但是<strong>数据的含义</strong>不同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fs.c</span></span><br><span class="line"><span class="comment">//读取超级块内容到缓存区中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_super</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="keyword">void</span> *blk;</span><br><span class="line">        <span class="keyword">if</span> ((r = read_block(<span class="number">1</span>, &amp;blk, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                user_panic(<span class="string">"cannot read superblock: %e"</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        super = blk;</span><br><span class="line">        <span class="keyword">if</span> (super-&gt;s_magic != FS_MAGIC) &#123;</span><br><span class="line">                user_panic(<span class="string">"bad file system magic number %x %x"</span>, super-&gt;s_magic, FS_MAGIC);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (super-&gt;s_nblocks &gt; DISKMAX / BY2BLK) &#123;</span><br><span class="line">                user_panic(<span class="string">"file system is too large"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        writef(<span class="string">"superblock is good\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取位图结构bitmap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_bitmap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u_int i;</span><br><span class="line">        <span class="keyword">void</span> *blk = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//nbitmap代表的是位图结构bitmap占用的数据块的个数(至少为1个)</span></span><br><span class="line">        nbitmap = super-&gt;s_nblocks / BIT2BLK + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//将bitmap读入到虚拟内存缓存中</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitmap; i++) &#123;</span><br><span class="line">                read_block(i + <span class="number">2</span>, blk, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bitmap = (u_int *)diskaddr(<span class="number">2</span>);</span><br><span class="line"> <span class="comment">//检查bitmap中前两个块(boot和super)和bitmap占用的块必定是已被使用的   	</span></span><br><span class="line">        user_assert(!block_is_free(<span class="number">0</span>));</span><br><span class="line">        user_assert(!block_is_free(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitmap; i++) &#123;</span><br><span class="line">                user_assert(!block_is_free(i + <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        writef(<span class="string">"read_bitmap is good\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fs_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        read_super();</span><br><span class="line">        check_write_block();</span><br><span class="line">        read_bitmap();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在文件控制块f中查询第fileno个指针指向的数据块的索引值,ppdiskbno指向保存该索引值的地址</span></span><br><span class="line"><span class="comment">//alloc为1代表在间接指针无效时允许新分配一页</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_block_walk</span><span class="params">(struct File *f, u_int filebno, u_int **ppdiskbno, u_int alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        u_int *ptr;</span><br><span class="line">        <span class="keyword">void</span> *blk;</span><br><span class="line"><span class="comment">//指针值在直接指针范围内直接通过直接指针获得</span></span><br><span class="line">        <span class="keyword">if</span> (filebno &lt; NDIRECT) &#123;</span><br><span class="line">                ptr = &amp;f-&gt;f_direct[filebno];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (filebno &lt; NINDIRECT) &#123;</span><br><span class="line">        <span class="comment">//当指针值需要使用间接指针时</span></span><br><span class="line">                <span class="keyword">if</span> (f-&gt;f_indirect == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;<span class="comment">//不允许alloc</span></span><br><span class="line">                                <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>) &#123;<span class="comment">//允许alloc则分配一块存储间接指针</span></span><br><span class="line">                                <span class="keyword">return</span> r;</span><br><span class="line">                        &#125;</span><br><span class="line">                        f-&gt;f_indirect = r;</span><br><span class="line">                &#125;</span><br><span class="line">			<span class="comment">//blk保存(保存间接指针的虚拟页)的起始地址</span></span><br><span class="line">                <span class="keyword">if</span> ((r = read_block(f-&gt;f_indirect, &amp;blk, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//则ptr指向(保存fileno指针指向的数据块索引)的地址</span></span><br><span class="line">            <span class="comment">//即*ptr即为fileno指向的数据块的索引值</span></span><br><span class="line">                ptr = (u_int *)blk + filebno;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        *ppdiskbno = ptr;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在f文件控制块中查找第fileno个指针指向的数据块对应的索引值赋值给diskbno(即建立文件控制块域与数据块关系)</span></span><br><span class="line"><span class="comment">//当alloc为1时若查找出来的索引无效,允许新分配一块</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_map_block</span><span class="params">(struct File *f, u_int filebno, u_int *diskbno, u_int alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        u_int *ptr;</span><br><span class="line"><span class="comment">//在f文件控制块中找对应的数据索引</span></span><br><span class="line">        <span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ptr, alloc)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//*ptr保存索引值</span></span><br><span class="line"><span class="comment">//如果索引无效</span></span><br><span class="line">        <span class="keyword">if</span> (*ptr == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">                &#125;</span><br><span class="line">			<span class="comment">//如果允许分配则新分配一页,并写入控制块结构对应位置</span></span><br><span class="line">                <span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//填入新分配的块的索引</span></span><br><span class="line">                *ptr = r;</span><br><span class="line">        &#125;</span><br><span class="line">        *diskbno = *ptr;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放文件控制块f的第filebno个指针指向的数据块</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_clear_block</span><span class="params">(struct File *f, u_int filebno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        u_int *ptr;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ptr, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*ptr) &#123;</span><br><span class="line">                free_block(*ptr);</span><br><span class="line">                *ptr = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得文件控制块f中第filebno个指针指向的数据块中的数据加载到虚拟内存中,并令blk指向该虚拟地址</span></span><br><span class="line"><span class="comment">//当filebno超过索引范围之后,则新分配一个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_get_block</span><span class="params">(struct File *f, u_int filebno, <span class="keyword">void</span> **blk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        u_int diskbno;</span><br><span class="line">        u_int isnew;</span><br><span class="line">    <span class="comment">//找到数据块的索引</span></span><br><span class="line">        <span class="keyword">if</span> ((r = file_map_block(f, filebno, &amp;diskbno, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//加载该数据块到虚拟内存blk中</span></span><br><span class="line">        <span class="keyword">if</span> ((r = read_block(diskbno, blk, &amp;isnew)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//???</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_dirty</span><span class="params">(struct File *f, u_int offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="keyword">void</span> *blk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((r = file_get_block(f, offset / BY2BLK, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">volatile</span> <span class="keyword">char</span> *)blk = *(<span class="keyword">volatile</span> <span class="keyword">char</span> *)blk;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得目录文件dir之下名为name的文件,如果有则将该文件的文件控制块赋值给file(注意此时dir问name文件的直接父目录)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir_lookup</span><span class="params">(struct File *dir, <span class="keyword">char</span> *name, struct File **file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        u_int i, j, nblock;</span><br><span class="line">        <span class="keyword">void</span> *blk;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="comment">//nblock为该目录文件之下的数据块个数</span></span><br><span class="line">        nblock = ROUND(dir-&gt;f_size,BY2BLK)/BY2BLK;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line">                <span class="comment">//获得一个保存文件控制块的数据块</span></span><br><span class="line">                <span class="keyword">if</span> (r=file_get_block(dir,i,&amp;blk))</span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                f = (struct File*)blk;</span><br><span class="line">                <span class="comment">//遍历该块中的每一个文件控制块,比较文件名</span></span><br><span class="line">                <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;FILE2BLK;j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(f[j].f_name,name)==<span class="number">0</span>) &#123;</span><br><span class="line">                                f[j].f_dir = dir;</span><br><span class="line">                                *file = &amp;f[j];</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在目录文件dir之下寻找一个空闲的文件控制块,并将其赋值给file</span></span><br><span class="line"><span class="comment">//如果没有空闲的控制块,则新分配一个数据块用来存储文件控制块</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir_alloc_file</span><span class="params">(struct File *dir, struct File **file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        u_int nblock, i , j;</span><br><span class="line">        <span class="keyword">void</span> *blk;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">        nblock = dir-&gt;f_size / BY2BLK;</span><br><span class="line">    <span class="comment">//遍历每一个块</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((r = file_get_block(dir, i, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                &#125;</span><br><span class="line">                f = blk;</span><br><span class="line">            <span class="comment">//遍历块中的每一个文件控制块</span></span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; FILE2BLK; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (f[j].f_name[<span class="number">0</span>] == <span class="string">'\0'</span>) &#123; </span><br><span class="line">                                *file = &amp;f[j];</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//当没找到之后新分配一个数据块</span></span><br><span class="line">        dir-&gt;f_size += BY2BLK;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_get_block(dir, i, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        f = blk;</span><br><span class="line">        *file = &amp;f[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//去除路径中的空格</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">skip_slash</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (*p == <span class="string">'/'</span>) &#123;</span><br><span class="line">                p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//难道我们不支持文件目录的嵌套吗???</span></span><br><span class="line"><span class="comment">//返回0代表找到了给文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">walk_path</span><span class="params">(<span class="keyword">char</span> *path, struct File **pdir, struct File **pfile, <span class="keyword">char</span> *lastelem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> *p;</span><br><span class="line">        <span class="keyword">char</span> name[MAXNAMELEN];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span>, *<span class="title">file</span>;</span></span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// start at the root.</span></span><br><span class="line">        path = skip_slash(path);</span><br><span class="line">        file = &amp;super-&gt;s_root;</span><br><span class="line">        dir = <span class="number">0</span>;</span><br><span class="line">        name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pdir) &#123;</span><br><span class="line">                *pdir = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *pfile = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find the target file by name recursively.</span></span><br><span class="line">        <span class="keyword">while</span> (*path != <span class="string">'\0'</span>) &#123;</span><br><span class="line">                dir = file;</span><br><span class="line">                p = path;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (*path != <span class="string">'/'</span> &amp;&amp; *path != <span class="string">'\0'</span>) &#123;</span><br><span class="line">                        path++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (path - p &gt;= MAXNAMELEN) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                user_bcopy(p, name, path - p);</span><br><span class="line">                name[path - p] = <span class="string">'\0'</span>;</span><br><span class="line">                path = skip_slash(path);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dir-&gt;f_type != FTYPE_DIR) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((r = dir_lookup(dir, name, &amp;file)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (r == -E_NOT_FOUND &amp;&amp; *path == <span class="string">'\0'</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (pdir) &#123;</span><br><span class="line">                                        *pdir = dir;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (lastelem) &#123;</span><br><span class="line">                                        <span class="built_in">strcpy</span>(lastelem, name);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                *pfile = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pdir) &#123;</span><br><span class="line">                *pdir = dir;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *pfile = file;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据path找到其代表的文件控制块并赋值给file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_open</span><span class="params">(<span class="keyword">char</span> *path, struct File **file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> walk_path(path, <span class="number">0</span>, file, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据path在目录下创建文件,并将新建的文件控制块赋值给file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_create</span><span class="params">(<span class="keyword">char</span> *path, struct File **file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> name[MAXNAMELEN];</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span>, *<span class="title">f</span>;</span></span><br><span class="line">        <span class="keyword">if</span> ((r = walk_path(path, &amp;dir, &amp;f, name)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -E_FILE_EXISTS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r != -E_NOT_FOUND || dir == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dir_alloc_file(dir, &amp;f) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)f-&gt;f_name, name);</span><br><span class="line">        *file = f;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将文件控制块f代表的文件的大小截取为newsize(要求newsize &lt; oldsize)(不安全的方法,只能被file_set_size使用)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">file_truncate</span><span class="params">(struct File *f, u_int newsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u_int bno, old_nblocks, new_nblocks;</span><br><span class="line">        old_nblocks = f-&gt;f_size / BY2BLK + <span class="number">1</span>;</span><br><span class="line">        new_nblocks = newsize / BY2BLK + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newsize == <span class="number">0</span>) &#123;</span><br><span class="line">                new_nblocks = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (new_nblocks &lt;= NDIRECT) &#123;<span class="comment">//当只需要直接指针时</span></span><br><span class="line">                f-&gt;f_indirect = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//当新的大小比原大小大时,将多余的块释放</span></span><br><span class="line">                <span class="keyword">for</span> (bno = new_nblocks; bno &lt; old_nblocks; bno++) &#123;</span><br><span class="line">                        file_clear_block(f, bno);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (bno = new_nblocks; bno &lt; old_nblocks; bno++) &#123;</span><br><span class="line">                        file_clear_block(f, bno);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f-&gt;f_size = newsize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将文件的大小改变为newsize</span></span><br><span class="line"><span class="comment"> *如果newsize &lt; oldsize则截断(使用file_truncate),设置f_size为new_size</span></span><br><span class="line"><span class="comment"> *如果newsize &gt; oldsize则直接设置f_size为new_size即可</span></span><br><span class="line"><span class="comment"> *将???</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_set_size</span><span class="params">(struct File *f, u_int newsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f-&gt;f_size &gt; newsize) &#123;</span><br><span class="line">                file_truncate(f, newsize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f-&gt;f_size = newsize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f-&gt;f_dir) &#123;</span><br><span class="line">                file_flush(f-&gt;f_dir);<span class="comment">//??????</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将文件控制块f中所有指针指向的数据块中的dirty的写回磁盘中(即同步磁盘与内存缓存中的数据)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">file_flush</span><span class="params">(struct File *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u_int nblocks;</span><br><span class="line">        u_int bno;</span><br><span class="line">        u_int diskno;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">        nblocks = f-&gt;f_size / BY2BLK + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (bno = <span class="number">0</span>; bno &lt; nblocks; bno++) &#123;</span><br><span class="line">            <span class="comment">//获得当前文件第bno个指针对应的索引,当不存在时不新建映射</span></span><br><span class="line">                <span class="keyword">if</span> ((r = file_map_block(f, bno, &amp;diskno, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//如果由索引获得的数据块是dirty的,则将其刷新回磁盘上</span></span><br><span class="line">                <span class="keyword">if</span> (block_is_dirty(diskno)) &#123;</span><br><span class="line">                        write_block(diskno);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该操作是保证数据同步性,即将内存中dirty的快缓存写回到磁盘中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fs_sync</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; super-&gt;s_nblocks; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (block_is_dirty(i)) &#123;</span><br><span class="line">                        write_block(i);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件的操作其实就是把文件内容从内存缓存写回磁盘中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">file_close</span><span class="params">(struct File *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        file_flush(f);</span><br><span class="line">        <span class="keyword">if</span> (f-&gt;f_dir) &#123;</span><br><span class="line">                file_flush(f-&gt;f_dir);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_remove</span><span class="params">(<span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">        <span class="keyword">if</span> ((r = walk_path(path, <span class="number">0</span>, &amp;f, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        file_truncate(f, <span class="number">0</span>);</span><br><span class="line">        f-&gt;f_name[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        file_flush(f);</span><br><span class="line">        <span class="keyword">if</span> (f-&gt;f_dir) &#123;</span><br><span class="line">                file_flush(f-&gt;f_dir);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>好像 :</p>
<p>我们所谓的对文件或者目录文件的操作都是针对于在内存缓存区的,而磁盘上的文件结构或者内容不会发生改变,所以我们在每一次对映射关系的修改之前都会有个写回磁盘的操作???</p>
<h2 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h2><p>在我们实现文件系统之后,我们需要给用户提供<strong>使用的接口(就是一些标准化的操文件系统的函数)</strong></p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>我们引入一个新的数据结构,即<strong>文件描述符</strong>,该描述符描述<strong>一个打开的文件在操作过程中状态</strong></p>
<ol>
<li><p>定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/fd.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	u_int fd_dev_id;</span><br><span class="line">	u_int fd_offset;</span><br><span class="line">	u_int fd_omode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其在内存中的构成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/fd.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXFD 32 <span class="comment">//最多同时存在32个文件描述符结构</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEBASE 0x60000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FDTABLE (FILEBASE-PDMAP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INDEX2FD(i)	(FDTABLE+(i)*BY2PG)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INDEX2DATA(i)	(FILEBASE+(i)*PDMAP)</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/21/OS-lab5/fd_struct.png" alt></p>
<p><strong>注意 : 我们一个<code>Fd</code>结构体占据一页的大小</strong></p>
</li>
<li><p>操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/fd.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">devtab</span>[] =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	&amp;devfile,</span><br><span class="line">	&amp;devcons,</span><br><span class="line">	&amp;devpipe,</span><br><span class="line">	<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> dev_id;</span><br><span class="line">	<span class="keyword">char</span> *dev_name;</span><br><span class="line">	<span class="keyword">int</span> (*dev_read)(struct Fd*, <span class="keyword">void</span>*, u_int, u_int);</span><br><span class="line">	<span class="keyword">int</span> (*dev_write)(struct Fd*, <span class="keyword">const</span> <span class="keyword">void</span>*, u_int, u_int);</span><br><span class="line">	<span class="keyword">int</span> (*dev_close)(struct Fd*);</span><br><span class="line">	<span class="keyword">int</span> (*dev_stat)(struct Fd*, struct Stat*);</span><br><span class="line">	<span class="keyword">int</span> (*dev_seek)(struct Fd*, u_int);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">.dev_id=	<span class="string">'f'</span>,</span><br><span class="line">.dev_name=	<span class="string">"file"</span>,</span><br><span class="line">.dev_read=	file_read,</span><br><span class="line">.dev_write=	file_write,</span><br><span class="line">.dev_close=	file_close,</span><br><span class="line">.dev_stat=	file_stat,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devcons</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">.dev_id=	<span class="string">'c'</span>,</span><br><span class="line">.dev_name=	<span class="string">"cons"</span>,</span><br><span class="line">.dev_read=	cons_read,</span><br><span class="line">.dev_write=	cons_write,</span><br><span class="line">.dev_close=	cons_close,</span><br><span class="line">.dev_stat=	cons_stat,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devpipe</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">.dev_id=	<span class="string">'p'</span>,</span><br><span class="line">.dev_name=	<span class="string">"pipe"</span>,</span><br><span class="line">.dev_read=	piperead,</span><br><span class="line">.dev_write=	pipewrite,</span><br><span class="line">.dev_close=	pipeclose,</span><br><span class="line">.dev_stat=	pipestat,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//上面的层次结构颇有面向对象的风格</span></span><br><span class="line"><span class="comment">//即使用父类Dev.继承众多子类devfile,devcons,devpipe</span></span><br><span class="line"><span class="comment">//使用函数指针的形式来实现子类同样的功能下根据自身进行各自不同的行为</span></span><br><span class="line"><span class="comment">//-------------------------------------------------//</span></span><br><span class="line"><span class="comment">//在devtab[]中寻找id为dev_id的设备,,并使用dev指向他</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dev_lookup</span><span class="params">(<span class="keyword">int</span> dev_id, struct Dev **dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; devtab[i]; i++)</span><br><span class="line">		<span class="keyword">if</span> (devtab[i]-&gt;dev_id == dev_id) &#123;</span><br><span class="line">			*dev = devtab[i];</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	writef(<span class="string">"[%08x] unknown device type %d\n"</span>, env-&gt;env_id, dev_id);</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按顺序寻找第一个还未被使用的储存Fd的页,使fd指向该页首地址</span></span><br><span class="line"><span class="comment">//依据于该地址对应的页目录或者页表项是否有效来判断该地址是够被使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fd_alloc</span><span class="params">(struct Fd **fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(fdno = <span class="number">0</span>;fdno &lt; MAXFD - <span class="number">1</span>;fdno++)</span><br><span class="line">	&#123;</span><br><span class="line">		va = INDEX2FD(fdno);</span><br><span class="line">		<span class="keyword">if</span>(((* vpd)[va/PDMAP] &amp; PTE_V)==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*fd = va;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(((* vpt)[va/BY2PG] &amp; PTE_V)==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*fd = va;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件描述符fd,实际上就是取消其所在页的映射而已</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fd_close</span><span class="params">(struct Fd *fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	syscall_mem_unmap(<span class="number">0</span>, (u_int)fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找第fdnum个文件描述符,使得fd指向该页起始地址</span></span><br><span class="line"><span class="comment">//寻找成功则返回0,不成功返回错误值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fd_lookup</span><span class="params">(<span class="keyword">int</span> fdnum, struct Fd **fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int va;</span><br><span class="line">	<span class="keyword">if</span>(fdnum &gt;=MAXFD)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	va = INDEX2FD(fdnum);</span><br><span class="line">	<span class="keyword">if</span>(((* vpt)[va/BY2PG] &amp; PTE_V)!=<span class="number">0</span>)	</span><br><span class="line">	&#123;</span><br><span class="line">		*fd = va;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据文件描述符指针获得其对应的数据块</span></span><br><span class="line"><span class="function">u_int <span class="title">fd2data</span><span class="params">(struct Fd *fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> INDEX2DATA(fd2num(fd));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过文件描述符fd获得其在描述符数组结构中的index(利用每个描述符占据一页并且连续存储</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fd2num</span><span class="params">(struct Fd *fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((u_int)fd - FDTABLE)/BY2PG;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过文件描述符在数组中的下标fd获得其在数组结构中的页起始地址</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num2fd</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fd*BY2PG+FDTABLE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*关闭第fdnum个文件描述符以及其对应的文件</span></span><br><span class="line"><span class="comment"> 1. 通过fdnum作为描述符数组下标找到描述符所在页并释放它</span></span><br><span class="line"><span class="comment"> 2. 通过描述符中的dev_id来在devtab[]中寻找对于对应的设备对象并关闭它</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fdnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">	||  (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	r = (*dev-&gt;dev_close)(fd);</span><br><span class="line">	fd_close(fd);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭所有文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_all</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;MAXFD; i++)</span><br><span class="line">		close(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将第oldfdum个文件描述符以及其数据域中的数据对应的物理页向第newfdnum个文件描述符建立映射</span></span><br><span class="line"><span class="comment"> *即oldfd与newfd共享oldfdnum中的数据</span></span><br><span class="line"><span class="comment"> 1. 关闭newfd,使其变为一个还未使用的文件描述符块</span></span><br><span class="line"><span class="comment"> 2. 建立newfd的数据域到oldfd的数据域物理页的映射</span></span><br><span class="line"><span class="comment"> 3. 建立newfd文件描述符页到oldfd文件描述符物理页的映射</span></span><br><span class="line"><span class="comment"> *注意映射要么全部建立成功,要么一个都不建立</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfdnum, <span class="keyword">int</span> newfdnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, r;</span><br><span class="line">	u_int ova, nva, pte;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">oldfd</span>, *<span class="title">newfd</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(oldfdnum, &amp;oldfd)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	close(newfdnum);</span><br><span class="line"></span><br><span class="line">	newfd = (struct Fd*)INDEX2FD(newfdnum);</span><br><span class="line">	ova = fd2data(oldfd);</span><br><span class="line">	nva = fd2data(newfd);</span><br><span class="line">	<span class="comment">//建立数据域的共享</span></span><br><span class="line">	<span class="keyword">if</span> ((* vpd)[PDX(ova)]) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;PDMAP; i+=BY2PG) &#123;</span><br><span class="line">			pte = (* vpt)[VPN(ova+i)];</span><br><span class="line">			<span class="keyword">if</span>(pte&amp;PTE_V) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, ova+i, <span class="number">0</span>, nva+i, pte&amp;(PTE_V|PTE_R|PTE_LIBRARY))) &lt; <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">goto</span> err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//建立文件描述符页的共享</span></span><br><span class="line">	<span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, (u_int)oldfd, <span class="number">0</span>, (u_int)newfd, ((*vpt)[VPN(oldfd)])&amp;(PTE_V|PTE_R|PTE_LIBRARY))) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newfdnum;</span><br><span class="line"><span class="comment">//当在建立映射的任何时候出错时均跳转到err代码处 : 取消之间所有建立的映射</span></span><br><span class="line">err:</span><br><span class="line">	syscall_mem_unmap(<span class="number">0</span>, (u_int)newfd);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;PDMAP; i+=BY2PG)</span><br><span class="line">		syscall_mem_unmap(<span class="number">0</span>, nva+i);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处n的含义好像不是读取的字节数???excuse me &gt;&gt; fuck</span></span><br><span class="line"><span class="comment">/*从第fdnum个文件描述符对应的文件中读出n个字节数据写入buf中,流程如下 :</span></span><br><span class="line"><span class="comment"> 1. 根据fdnum获得文件描述符指针fd</span></span><br><span class="line"><span class="comment"> 2. 根据文件描述符域中的dev_id在devtab[]中获得设备指针dev</span></span><br><span class="line"><span class="comment"> 3. 根据设备指针域中的读函数指针dev_read进行读取</span></span><br><span class="line"><span class="comment"> 4. 在读取完成后设置文件偏移量</span></span><br><span class="line"><span class="comment"> *当返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fdnum, <span class="keyword">void</span> *buf, u_int n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">	||  (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_WRONLY) &#123;</span><br><span class="line">		writef(<span class="string">"[%08x] read %d -- bad mode\n"</span>, env-&gt;env_id, fdnum); </span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	r = (*dev-&gt;dev_read)(fd, buf, n, fd-&gt;fd_offset);</span><br><span class="line">	<span class="keyword">if</span> (r &gt;= <span class="number">0</span>)</span><br><span class="line">		fd-&gt;fd_offset += r;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分多次读入,整体效果与read函数一致</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> fdnum, <span class="keyword">void</span> *buf, u_int n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m, tot;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (tot=<span class="number">0</span>; tot&lt;n; tot+=m) &#123;</span><br><span class="line">		m = read(fdnum, (<span class="keyword">char</span>*)buf+tot, n-tot);</span><br><span class="line">		<span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> m;</span><br><span class="line">		<span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//与read函数基本一致</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fdnum, <span class="keyword">const</span> <span class="keyword">void</span> *buf, u_int n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">	||  (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_RDONLY) &#123;</span><br><span class="line">		writef(<span class="string">"[%08x] write %d -- bad mode\n"</span>, env-&gt;env_id, fdnum);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"write %d %p %d via dev %s\n"</span>,</span><br><span class="line">		fdnum, buf, n, dev-&gt;dev_name);</span><br><span class="line">	r = (*dev-&gt;dev_write)(fd, buf, n, fd-&gt;fd_offset);</span><br><span class="line">	<span class="keyword">if</span> (r &gt; <span class="number">0</span>)</span><br><span class="line">		fd-&gt;fd_offset += r;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置第fdnum个文件描述符中的文件偏移为offset</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> fdnum, u_int offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	fd-&gt;fd_offset = offset;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> st_name[MAXNAMELEN];</span><br><span class="line">	u_int st_size;</span><br><span class="line">	u_int st_isdir;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">st_dev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//初始化第fdnum个文件描述符对应的dev中的dev_stat</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fdnum, struct Stat *stat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">	||  (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	stat-&gt;st_name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	stat-&gt;st_size = <span class="number">0</span>;</span><br><span class="line">	stat-&gt;st_isdir = <span class="number">0</span>;</span><br><span class="line">	stat-&gt;st_dev = dev;</span><br><span class="line">	<span class="keyword">return</span> (*dev-&gt;dev_stat)(fd, stat);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct Stat *stat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd, r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">	r = fstat(fd, stat);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="IPC机制的使用"><a href="#IPC机制的使用" class="headerlink" title="IPC机制的使用"></a>IPC机制的使用</h3><p><strong>我们的操作系统中的文件系统服务通过 <code>IPC</code>的形式供其他进程调用,进行文件读写操作.具体来说,在内核开始运行时,就启动了文件系统服务进程 <code>ENV_CREATE(fs_serv)</code>,用户进程需要进行文件操作时,使用<code>ipc_send/ipc_recv</code> 与 <code>fs_serv</code> 进行互,完成操作</strong></p>
<p>所以基本流程为<code>file.c</code>中的函数准备好<strong>实现功能的数据</strong>,调用<code>fsipc.c</code>中的<strong>通讯函数</strong>传递<strong>包装后的数据</strong>给<code>fs_serv</code>进程,该进程根据<strong>标准形式数据</strong>进行操作,操作完成之后又通过<code>ipc</code>机制通知操作成功或者失败</p>
<p><strong>在文件操作中通信主要靠的是映射到同一地址,即用户进程告诉文件服务进程我的文件描述符等数据结构都应该要在虚拟地址<code>dstva</code>指向的页,然后文件服务进程找到一个物理页把这些都填好,然后在二者之间建立映射关系</strong></p>
<h4 id="传递的指令形式"><a href="#传递的指令形式" class="headerlink" title="传递的指令形式"></a>传递的指令形式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/fs.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSREQ_OPEN	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSREQ_MAP	2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSREQ_SET_SIZE	3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSREQ_CLOSE	4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSREQ_DIRTY	5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSREQ_REMOVE	6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSREQ_SYNC	7</span></span><br><span class="line"><span class="comment">//各种文件操作通信的标准请求结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> req_path[MAXPATHLEN];</span><br><span class="line">	u_int req_omode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_map</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> req_fileid;</span><br><span class="line">	u_int req_offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_set_size</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> req_fileid;</span><br><span class="line">	u_int req_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_close</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> req_fileid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_dirty</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> req_fileid;</span><br><span class="line">	u_int req_offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_remove</span> &#123;</span></span><br><span class="line">	u_char req_path[MAXPATHLEN];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h4><p><strong>之后对用户进程的请求只需要包装(根据数据填写对应的域即可)成标准的请求结构然后发送给文件服务进程即可</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/fsipc.c</span></span><br><span class="line"><span class="keyword">extern</span> u_char fsipcbuf[BY2PG];		<span class="comment">//在entry中定义为一页大小</span></span><br><span class="line"><span class="comment">/*最基本的通信函数</span></span><br><span class="line"><span class="comment"> *type为操作的类型</span></span><br><span class="line"><span class="comment"> *fsreq为实现操作需要的相关数据保存的地址位置</span></span><br><span class="line"><span class="comment"> *dstva为该进程接受文件服务进程返回信息的保存位置</span></span><br><span class="line"><span class="comment"> 文件服务进程控制块在第2个</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fsipc</span><span class="params">(u_int type, <span class="keyword">void</span> *fsreq, u_int dstva, u_int *perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int whom;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	ipc_send(envs[<span class="number">1</span>].env_id, type, (u_int)fsreq, PTE_V|PTE_R);</span><br><span class="line">	r =  ipc_recv(&amp;whom, dstva, perm);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将打开文件请求包转成标准请求Fsreq_open发送给文件服务系统</span></span><br><span class="line"><span class="comment">//以omode的权限打开path下的文件并使fd指向打开文件的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsipc_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, u_int omode, struct Fd *fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int perm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> *<span class="title">req</span>;</span></span><br><span class="line">	req = (struct Fsreq_open*)fsipcbuf;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN)</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">	<span class="built_in">strcpy</span>(req-&gt;req_path, path);</span><br><span class="line">	req-&gt;req_omode = omode;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_OPEN, req, (u_int)fd, &amp;perm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将映射地址请求包转成标准请求Fsreq_map发送给文件服务系统</span></span><br><span class="line"><span class="comment">//将fileid代表的文件的offset字节所在的数据块(一页大小)映射到dstva的虚拟地址</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsipc_map</span><span class="params">(u_int fileid, u_int offset, u_int dstva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	u_int perm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_map</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">	req = (struct Fsreq_map*)fsipcbuf;</span><br><span class="line">	req-&gt;req_fileid = fileid;</span><br><span class="line">	req-&gt;req_offset = offset;</span><br><span class="line">	<span class="keyword">if</span> ((r=fsipc(FSREQ_MAP, req, dstva, &amp;perm)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((perm&amp;~(PTE_R|PTE_LIBRARY)) != (PTE_V))</span><br><span class="line">		user_panic(<span class="string">"fsipc_map: unexpected permissions %08x for dstva %08x"</span>, perm, dstva);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将改变文件大小请求包转成标准请求Fsreq_set_size发送给文件服务系统</span></span><br><span class="line"><span class="comment">//将fileid代表的文件的大小设置为size</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsipc_set_size</span><span class="params">(u_int fileid, u_int size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_set_size</span> *<span class="title">req</span>;</span></span><br><span class="line">	req = (struct Fsreq_set_size*)fsipcbuf;</span><br><span class="line">	req-&gt;req_fileid = fileid;</span><br><span class="line">	req-&gt;req_size = size;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_SET_SIZE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将关闭文件请求包转成标准请求Fsreq_close发送给文件服务系统</span></span><br><span class="line"><span class="comment">//将fileid代表的文件关闭</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsipc_close</span><span class="params">(u_int fileid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_close</span> *<span class="title">req</span>;</span></span><br><span class="line">	req = (struct Fsreq_close*)fsipcbuf;</span><br><span class="line">	req-&gt;req_fileid = fileid;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_CLOSE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将设置dirty请求包转成标准请求Fsreq_dirty发送给文件服务系统</span></span><br><span class="line"><span class="comment">//将fileid代表的文件数据offset字节偏移所在的数据块标记为dirty的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsipc_dirty</span><span class="params">(u_int fileid, u_int offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_dirty</span> *<span class="title">req</span>;</span></span><br><span class="line">	req = (struct Fsreq_dirty*)fsipcbuf;</span><br><span class="line">	req-&gt;req_fileid = fileid;</span><br><span class="line">	req-&gt;req_offset = offset;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_DIRTY, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将删除文件请求包转成标准请求Fsreq_remove发送给文件服务系统</span></span><br><span class="line"><span class="comment">//将path找到的文件从其目录中删除掉</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsipc_remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_remove</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">	req = (struct Fsreq_remove*)fsipcbuf;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN)</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">	<span class="built_in">strcpy</span>(req-&gt;req_path, path);</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_REMOVE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将同步文件请求发送给文件服务系统</span></span><br><span class="line"><span class="comment">//将fsipcbuf中代表的文件从内存中的缓存区写会磁盘中(即同步数据)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsipc_sync</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_SYNC, fsipcbuf, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意 : 在上述操作中使用了众多的指针类型的强制转换,我对此的理解是</strong> :</p>
<ol>
<li>任何一个结构体指针都只是指向一片<strong>连续的内存区域</strong>而已</li>
<li><strong>结构体的定义形式决定了使用该指针时会如何划分这一块连续的内存区域,以及划分之后的每一块区域代表的含义</strong></li>
<li>所以我们<strong>可以向一片连续的内存区域按顺序填入我们结构体的数据,就可以使用该类型指针来解读它</strong></li>
</ol>
<h4 id="文件服务进程"><a href="#文件服务进程" class="headerlink" title="文件服务进程"></a>文件服务进程</h4><p>文件服务进程等待其他进程<strong>通过<code>IPC</code>机制发送文件操作请求</strong>然后响应,在文件服务进程中可以<strong>使用<code>fs.c</code>中对文件的各种操作函数</strong>(<del>既然是个假的操作系统,我们为什么不让用户进程直接使用<code>fs.c</code>中函数呢</del>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/serv.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span>	</span><br><span class="line">	u_int o_fileid;		</span><br><span class="line">	<span class="keyword">int</span> o_mode;		</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">o_ff</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时打开的最多文件个数,注意是同时打开,不代表fileid的范围就在这中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXOPEN	1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEVA 0x60000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize to force into data section</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> <span class="title">opentab</span>[<span class="title">MAXOPEN</span>] = &#123;</span> &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Virtual address at which to receive page mappings containing client requests.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REQVA	0x0ffff000</span></span><br><span class="line"><span class="comment">//初始化数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	u_int va;</span><br><span class="line">	va = FILEVA;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;MAXOPEN; i++) &#123;</span><br><span class="line">		opentab[i].o_fileid = i;</span><br><span class="line">		opentab[i].o_ff = (struct Filefd*)va;</span><br><span class="line">		va += BY2PG;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//user/pageref.c</span></span><br><span class="line"><span class="comment">//返回虚拟地址映射到的物理地址的历史上被引用次数</span></span><br><span class="line"><span class="comment">//当没有有效映射时返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pageref</span><span class="params">(<span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int pte;</span><br><span class="line">	<span class="keyword">if</span> (!((* vpd)[PDX(v)]&amp;PTE_V))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	pte = (* vpt)[VPN(v)];</span><br><span class="line">	<span class="keyword">if</span> (!(pte&amp;PTE_V))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> pages[PPN(pte)].pp_ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_alloc</span><span class="params">(struct Open **o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, r;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXOPEN; i++) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (pageref(opentab[i].o_ff)) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">if</span> ((r = syscall_mem_alloc(<span class="number">0</span>, (u_int)opentab[i].o_ff, PTE_V|PTE_R|PTE_LIBRARY)) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> r;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">             <span class="comment">/*这个case1非常骚</span></span><br><span class="line"><span class="comment">              *当ref = 1时说明该文件之前被打开过一次,所以此时是第二次打开</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">			opentab[i].o_fileid += MAXOPEN;<span class="comment">//第二次打开fileid + MAXOPEN,这样既可以保证fileid在每次打开文件的唯一性,又可以通过取模方便的由fileid获得index = fileid % MAXOPEN</span></span><br><span class="line">			*o = &amp;opentab[i];</span><br><span class="line">			user_bzero((<span class="keyword">void</span>*)opentab[i].o_ff, BY2PG);</span><br><span class="line">			<span class="keyword">return</span> (*o)-&gt;o_fileid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据fileid这一唯一标识获得open结构体赋值给po</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_lookup</span><span class="params">(u_int envid, u_int fileid, struct Open **po)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">o</span>;</span></span><br><span class="line">	o = &amp;opentab[fileid%MAXOPEN];</span><br><span class="line">	<span class="keyword">if</span> (pageref(o-&gt;o_ff) == <span class="number">1</span> || o-&gt;o_fileid != fileid)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	*po = o;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">//接下来便是各种文件服务进程的服务函数</span></span><br><span class="line"><span class="comment">//打开文件服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_open</span><span class="params">(u_int envid, struct Fsreq_open *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	writef(<span class="string">"serve_open %08x %x 0x%x\n"</span>, envid, (<span class="keyword">int</span>)rq-&gt;req_path, rq-&gt;req_omode);</span><br><span class="line">	u_char path[MAXPATHLEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ff</span>;</span></span><br><span class="line">	<span class="keyword">int</span> fileid;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">o</span>;</span></span><br><span class="line">	user_bcopy(rq-&gt;req_path, path, MAXPATHLEN);</span><br><span class="line">	path[MAXPATHLEN<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> ((r = open_alloc(&amp;o)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		writef(<span class="string">"open_alloc failed: %d"</span>, r);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	fileid = r;</span><br><span class="line">	<span class="keyword">if</span> ((r = file_open(path, &amp;f)) &lt; <span class="number">0</span>) &#123;<span class="comment">//使用fs.c中的file_open打开path文件并使f指向其文件控制块</span></span><br><span class="line">		writef(<span class="string">"file_open failed: %e"</span>, r);</span><br><span class="line">		<span class="keyword">if</span> (r==-E_NOT_FOUND) writef(<span class="string">"E_NOT_FOUND\n"</span>);</span><br><span class="line">		<span class="keyword">if</span> (r==-E_BAD_PATH) writef(<span class="string">"E_BAD_PATH\n"</span>);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	o-&gt;o_file = f;</span><br><span class="line">	ff = (struct Filefd*)o-&gt;o_ff;</span><br><span class="line">	ff-&gt;f_file = *f;</span><br><span class="line">	ff-&gt;f_fileid = o-&gt;o_fileid;</span><br><span class="line">	o-&gt;o_mode = rq-&gt;req_omode;</span><br><span class="line">	ff-&gt;f_fd.fd_omode = o-&gt;o_mode;</span><br><span class="line">	ff-&gt;f_fd.fd_dev_id = devfile.dev_id;</span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"sending success, page %08x\n"</span>, (u_int)o-&gt;o_ff);</span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, (u_int)o-&gt;o_ff, PTE_V|PTE_R|PTE_LIBRARY);<span class="comment">//o_ff结构体与请求进程传入的fd结构体映射到了同一物理页,ipc_send建立了fd到o_ff的物理页的映射关系</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">out:user_panic(<span class="string">"*********************path:%s"</span>,path);</span><br><span class="line">	ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//映射地址服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_map</span><span class="params">(u_int envid, struct Fsreq_map *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"serve_map %08x %08x %08x\n"</span>, envid, rq-&gt;req_fileid, rq-&gt;req_offset);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">	u_int filebno;</span><br><span class="line">	<span class="keyword">void</span> *blk;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">    <span class="comment">//根据fileid这一唯一标识找到对应的open结构体</span></span><br><span class="line">	<span class="keyword">if</span>((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen))&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ipc_send(envid,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//根据文件内偏移获得所在的数据块下标</span></span><br><span class="line">	filebno = rq-&gt;req_offset/BY2BLK;</span><br><span class="line">    <span class="comment">//根据文件控制块+数据块下标获得该数据块映射到的虚拟页起始地址blk</span></span><br><span class="line">	<span class="keyword">if</span>((r = file_get_block(pOpen-&gt;o_file, filebno, &amp;blk))&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ipc_send(envid,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//使用IPC机制来使得用户进程设定的dstva映射到blk的物理页,即用户指定的虚拟地址与blk共享一个数据块,实现用户进程获得数据块</span></span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, blk, PTE_V|PTE_R|PTE_LIBRARY);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置文件大小服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_set_size</span><span class="params">(u_int envid, struct Fsreq_set_size *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"serve_set_size %08x %08x %08x\n"</span>, envid, rq-&gt;req_fileid, rq-&gt;req_size);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="keyword">if</span>((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen))&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                ipc_send(envid,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>((r = file_set_size(pOpen-&gt;o_file, rq-&gt;req_size))&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ipc_send(envid,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_close</span><span class="params">(u_int envid, struct Fsreq_close *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"serve_close %08x %08x\n"</span>, envid, rq-&gt;req_fileid);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="keyword">if</span>((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen))&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                ipc_send(envid,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//使用fs.c中的底层函数关闭文件控制块</span></span><br><span class="line">	file_close(pOpen-&gt;o_file);</span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span>;		</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除文件服务函数	</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_remove</span><span class="params">(u_int envid, struct Fsreq_remove *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"serve_map %08x %s\n"</span>, envid, rq-&gt;req_path);</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">	u_char path[MAXPATHLEN];</span><br><span class="line">        user_bcopy(rq-&gt;req_path, path, MAXPATHLEN);</span><br><span class="line">        path[MAXPATHLEN<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>((r = file_remove(path))&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                ipc_send(envid,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;	</span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//标记dirty位服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_dirty</span><span class="params">(u_int envid, struct Fsreq_dirty *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"serve_dirty %08x %08x %08x\n"</span>, envid, rq-&gt;req_fileid, rq-&gt;req_offset)</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="keyword">if</span>((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen))&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                ipc_send(envid,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="keyword">if</span>((r = file_dirty(pOpen-&gt;o_file, rq-&gt;req_offset))&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ipc_send(envid,r,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_sync</span><span class="params">(u_int envid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fs_sync();</span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据操作码选择操作的总的服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int req, whom, perm;</span><br><span class="line">	<span class="keyword">for</span>(;;) &#123;</span><br><span class="line">		perm = <span class="number">0</span>;</span><br><span class="line">		req = ipc_recv(&amp;whom, REQVA, &amp;perm);</span><br><span class="line">		<span class="keyword">if</span> (!(perm &amp; PTE_V)) &#123;</span><br><span class="line">			writef(<span class="string">"Invalid request from %08x: no argument page\n"</span>,</span><br><span class="line">				whom);</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">// just leave it hanging...</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> (req) &#123;</span><br><span class="line">		<span class="keyword">case</span> FSREQ_OPEN:</span><br><span class="line">			serve_open(whom, (struct Fsreq_open*)REQVA);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FSREQ_MAP:</span><br><span class="line">			serve_map(whom, (struct Fsreq_map*)REQVA);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FSREQ_SET_SIZE:</span><br><span class="line">			serve_set_size(whom, (struct Fsreq_set_size*)REQVA);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FSREQ_CLOSE:</span><br><span class="line">			serve_close(whom, (struct Fsreq_close*)REQVA);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FSREQ_DIRTY:</span><br><span class="line">			serve_dirty(whom, (struct Fsreq_dirty*)REQVA);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FSREQ_REMOVE:</span><br><span class="line">			serve_remove(whom, (struct Fsreq_remove*)REQVA);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FSREQ_SYNC:</span><br><span class="line">			serve_sync(whom);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			writef(<span class="string">"Invalid request code %d from %08x\n"</span>, whom, req);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		syscall_mem_unmap(<span class="number">0</span>, REQVA);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进程运行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">umain</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	user_assert(<span class="keyword">sizeof</span>(struct File)==<span class="number">256</span>);</span><br><span class="line">	writef(<span class="string">"FS is running\n"</span>);</span><br><span class="line">	writef(<span class="string">"FS can do I/O\n"</span>);</span><br><span class="line">	serve_init();</span><br><span class="line">	fs_init();</span><br><span class="line">	fs_test();	</span><br><span class="line">	serve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用户态下调用传递函数"><a href="#用户态下调用传递函数" class="headerlink" title="用户态下调用传递函数"></a>用户态下调用传递函数</h4><p>在用户态下<strong>准备传递的数据调用传递函数</strong>即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/fd.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span></span><br><span class="line">	u_int f_fileid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//user/file.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">.dev_id=	<span class="string">'f'</span>,</span><br><span class="line">.dev_name=	<span class="string">"file"</span>,</span><br><span class="line">.dev_read=	file_read,</span><br><span class="line">.dev_write=	file_write,</span><br><span class="line">.dev_close=	file_close,</span><br><span class="line">.dev_stat=	file_stat,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//真正的在用户态下打开文件的操作,基于IPC机制向文件进程发送打开文件请求</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">	u_int size,fileid;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	u_int va;</span><br><span class="line">	u_int i;</span><br><span class="line">	<span class="keyword">if</span>((r = fd_alloc(&amp;fd))&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//突然觉得这个r =  然后return r的写法很像java的异常抛出机制,可以把错误代码一层层向上传递</span></span><br><span class="line">		writef(<span class="string">"Without free fd left\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//向文件进程发送打开文件请求</span></span><br><span class="line">	<span class="keyword">if</span>((r = fsipc_open(path, mode, fd))&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		writef(<span class="string">"cannont open file %s\n"</span>,path);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	va = fd2data(fd);	</span><br><span class="line">	ffd = (struct Filefd*)fd;</span><br><span class="line">	size = ffd-&gt;f_file.f_size;</span><br><span class="line">	fileid = ffd-&gt;f_fileid;</span><br><span class="line">	<span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> fd2num(fd);</span><br><span class="line">	<span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; size; i+=BY2PG)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">/*使用map进程来在用户进程获得文件数据块</span></span><br><span class="line"><span class="comment">         *va为Fd_data的储存起始位置,为每一个文件分配4MB</span></span><br><span class="line"><span class="comment">         *size为文件大小</span></span><br><span class="line"><span class="comment">         *文件数据块所在位置通过fileid唯一确定的Open结构体中的文件控制块中的数据块指针来确定</span></span><br><span class="line"><span class="comment">         *fsipc_map将fileid打开文件偏移为i所在的数据块映射到以va+i为起始地址的虚拟页上</span></span><br><span class="line"><span class="comment">         *所以Fd_data在当文件打开时中存储的就是文件中的数据内容</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		<span class="keyword">if</span>((r = fsipc_map(fileid, i, va+i))&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			writef(<span class="string">"cannot map the file.\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fd2num(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_close</span><span class="params">(struct Fd *fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">	u_int va,size,fileid;</span><br><span class="line">	u_int i;</span><br><span class="line"></span><br><span class="line">	ffd = (struct Filefd*)fd;</span><br><span class="line">	fileid = ffd-&gt;f_fileid;</span><br><span class="line">	size = ffd-&gt;f_file.f_size;</span><br><span class="line">	va = fd2data(fd);      </span><br><span class="line">	<span class="comment">//将文件所有的数据块标记为dirty的,因为在fs中关闭文件控制块会判断数据块是否为dirty的,如果是则写回</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i += BY2PG)</span><br><span class="line">	&#123;</span><br><span class="line">			fsipc_dirty(fileid, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//使用IPC机制关闭文件描述符</span></span><br><span class="line">	<span class="keyword">if</span>((r = fsipc_close(fileid))&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		writef(<span class="string">"cannot close the file\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//去掉映射</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i +=BY2PG)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((r = syscall_mem_unmap(<span class="number">0</span>, va+i))&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			writef(<span class="string">"cannont unmap the file.\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	fd_close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从fd代表的文件中从offset位置读取n字节写入buf中</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">file_read</span><span class="params">(struct Fd *fd, <span class="keyword">void</span> *buf, u_int n, u_int offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line">	f = (struct Filefd*)fd;</span><br><span class="line">	<span class="comment">//最多读到文件的末尾</span></span><br><span class="line">	size = f-&gt;f_file.f_size;</span><br><span class="line">	<span class="keyword">if</span> (offset &gt; size)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (offset+n &gt; size)</span><br><span class="line">		n = size - offset;</span><br><span class="line">    <span class="comment">//读取的操作实际上是找到该段数据在Fd_data中的位置然后复制过来</span></span><br><span class="line">	user_bcopy((<span class="keyword">char</span>*)fd2data(fd)+offset, buf, n);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_map</span><span class="params">(<span class="keyword">int</span> fdnum, u_int offset, <span class="keyword">void</span> **blk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	u_int va;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span> (fd-&gt;fd_dev_id != devfile.dev_id)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	va = fd2data(fd) + offset;</span><br><span class="line">	<span class="keyword">if</span> (offset &gt;= MAXFILESIZE)</span><br><span class="line">		<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">	<span class="keyword">if</span> (!((* vpd)[PDX(va)]&amp;PTE_V) || !((* vpt)[VPN(va)]&amp;PTE_V))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br><span class="line">	*blk = (<span class="keyword">void</span>*)va;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向fd代表的文件中offset位置处写入从buf中拿到的n字节</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">file_write</span><span class="params">(struct Fd *fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, u_int n, u_int offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	u_int tot;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">	f = (struct Filefd*)fd;</span><br><span class="line">	tot = offset + n;</span><br><span class="line">	<span class="keyword">if</span> (tot &gt; MAXFILESIZE)</span><br><span class="line">		<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">	<span class="keyword">if</span> (tot &gt; f-&gt;f_file.f_size) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = ftruncate(fd2num(fd), tot)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	user_bcopy(buf, (<span class="keyword">char</span>*)fd2data(fd)+offset, n);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">file_stat</span><span class="params">(struct Fd *fd, struct Stat *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">	f = (struct Filefd*)fd;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(st-&gt;st_name, f-&gt;f_file.f_name);</span><br><span class="line">	st-&gt;st_size = f-&gt;f_file.f_size;</span><br><span class="line">	st-&gt;st_isdir = f-&gt;f_file.f_type==FTYPE_DIR;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//截取fdnum索引的fd代表的文件到size大小(size应该小于oldsize)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fdnum, u_int size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line">	u_int oldsize, va, fileid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &gt; MAXFILESIZE)</span><br><span class="line">		<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span> (fd-&gt;fd_dev_id != devfile.dev_id)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">	f = (struct Filefd*)fd;</span><br><span class="line">	fileid = f-&gt;f_fileid;</span><br><span class="line">	oldsize = f-&gt;f_file.f_size;</span><br><span class="line">	<span class="keyword">if</span> ((r = fsipc_set_size(fileid, size)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">	va = fd2data(fd);</span><br><span class="line">	<span class="keyword">for</span> (i = ROUND(oldsize, BY2PG); i &lt; ROUND(size, BY2PG); i += BY2PG) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = fsipc_map(fileid, i, va+i)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			fsipc_set_size(fileid, oldsize);</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = ROUND(size, BY2PG); i &lt; ROUND(oldsize, BY2PG); i+=BY2PG)</span><br><span class="line">		<span class="keyword">if</span> ((r = syscall_mem_unmap(<span class="number">0</span>, va+i)) &lt; <span class="number">0</span>)</span><br><span class="line">			user_panic(<span class="string">"ftruncate: syscall_mem_unmap %08x: %e"</span>, va+i, r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fsipc_remove(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步文件内容,将文件写入磁盘中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fsipc_sync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注 :</p>
<ol>
<li><p><strong>在我们的设计中文件系统是作为磁盘外设看待的,所以上述机制可以自然地推广到其他外设上,例如我们已经实现了的有<code>console</code>与<code>pipe</code></strong></p>
</li>
<li><p><strong>在文件操作中我们使用了大量的结构体,这些结构体有以下的关系</strong> :</p>
<p>这种结构体相互包含的结构颇有面向对象父类与子类的意思</p>
<p><img src="/2019/05/21/OS-lab5/struct.png" alt></p>
<p><strong>它们的使用时机是</strong> :</p>
<ul>
<li><code>File</code>是文件控制块,是在<strong>磁盘文件内容本身中保存在某一块中的(从<code>super</code>可以知道在哪一块),其内容由文件系统的结构决定</strong>,所以该数据结构是我们从磁盘中直接<strong>加载到内存指定位置(映射关系是简单的线性的,详见快缓存机制)使用的,不需要自己建立</strong></li>
<li><code>Fd</code>是文件描述符,<strong>在打开一个文件时建立它的描述符</strong>,在分配时给每个<code>Fd</code><strong>分配一页的空间</strong>,<strong>每一个<code>Fd</code>对应一个<code>4MB</code>大小的<code>Fd_data</code>,对应关系是在各自的顺序结构中下标<code>index</code>相同</strong>,由图中可以看出<code>Fd</code>数据结构指针可以<strong>强制转换为<code>Filefd</code>指针</strong> :<ol>
<li><code>dev_id</code> : 外设唯一编号</li>
<li><code>fd_offset</code> : 对一个打开的文件读取到的偏移量</li>
<li><code>fd_omode</code> : 打开文件的方式</li>
</ol>
</li>
<li><code>Filefd</code>是对<strong>打开文件的进一步描述</strong>,其中<strong><code>fileid</code>是每次打开某一文件的唯一标识</strong>,其都是从<code>Fd</code>转换而来的,存储空间就是为<code>Fd</code>分配那一页</li>
<li><code>open</code>结构体是<strong>在进程服务进程<code>serv.c</code>中使用的</strong>,通过用户进程通信传递的打开文件唯一标识<code>fileid</code>来找到对应的<code>Fildefd</code>结构体,<strong>然后我们就知道了用户进程要求的文件信息应该填在哪里,<code>serve</code>进程根据<code>path</code>找到文件并装载进内存,然后将<code>File</code>文件控制块填入<code>Fildfd</code>中的域,将<code>File</code>指向的数据块填入(建立映射)<code>Fd</code>对应的<code>Fd_data</code>的<code>4MB</code>大小空间</strong></li>
</ul>
</li>
<li><p><strong>进程通信机制</strong> :</p>
<p><img src="/2019/05/21/OS-lab5/ipc.png" alt></p>
</li>
<li><p><strong>最重要的<code>open</code>操作</strong></p>
<p><img src="/2019/05/21/OS-lab5/open.png" alt></p>
</li>
</ol>
<h1 id="一点想法"><a href="#一点想法" class="headerlink" title="一点想法"></a>一点想法</h1><p>我对<code>OS</code>这门课理性的看待之后,我认为有以下几点 :</p>
<ol>
<li>对于一个普通的学生而言,花费很多时间获得的知识最多只能是<strong>看懂这个架构是怎么运行的</strong>,但是对<code>OS</code>设计的<strong>为什么这么做</strong>很难有正确的理解</li>
<li>测试手段太过薄弱,不仅是没有调试的手段,来测试发现<code>bug</code>的手段都十分简陋</li>
<li>指导书真的远远不够(指导作用),我不是说所有的东西都要给出答案,只是要有一点更详细的说明</li>
</ol>
<p><code>lab5-2</code>课上本地无误线上测试玄学,至今不知道哪里错了,哎,我也不说什么不后悔的屁话,伤心肯定是有的,毕竟作为一个普通学生,我自认为在这门课上花的时间也不少,至少和<code>OO</code>可以<del>五五开</del>,但是现在估计结局不会怎么好,怎么说呢,还是太菜,不过真心每次在这种时候都有转系的冲动,自己是不是真的没有能力吃这碗饭</p>
<p><code>I tried, I failed, I died, that&#39;s all, nothing more</code></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/OS/" rel="tag"># OS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/03/OS-lab4/" rel="next" title="OS-lab4">
                <i class="fa fa-chevron-left"></i> OS-lab4
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/02/mysql安装/" rel="prev" title="mysql安装">
                mysql安装 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">fjh</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#lab5做了什么"><span class="nav-number">1.</span> <span class="nav-text">lab5做了什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#具体实现"><span class="nav-number">2.</span> <span class="nav-text">具体实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#外部存储设备驱动"><span class="nav-number">2.1.</span> <span class="nav-text">外部存储设备驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘寻址的原理"><span class="nav-number">2.1.1.</span> <span class="nav-text">磁盘寻址的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#地址表达"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">地址表达</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#地址转换"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">地址转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OS与外设交互的机制"><span class="nav-number">2.1.2.</span> <span class="nav-text">OS与外设交互的机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDE磁盘在硬件层次的规定"><span class="nav-number">2.1.3.</span> <span class="nav-text">IDE磁盘在硬件层次的规定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#具体实现-1"><span class="nav-number">2.1.4.</span> <span class="nav-text">具体实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统"><span class="nav-number">2.2.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘在物理和逻辑层次上的表示"><span class="nav-number">2.2.1.</span> <span class="nav-text">磁盘在物理和逻辑层次上的表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#超级块"><span class="nav-number">2.2.2.</span> <span class="nav-text">超级块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位图结构"><span class="nav-number">2.2.3.</span> <span class="nav-text">位图结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件控制块"><span class="nav-number">2.2.4.</span> <span class="nav-text">文件控制块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何构建一个文件"><span class="nav-number">2.2.5.</span> <span class="nav-text">如何构建一个文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本流程"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">基本流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构"><span class="nav-number">2.2.5.2.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#具体实现-2"><span class="nav-number">2.2.5.3.</span> <span class="nav-text">具体实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#功能函数"><span class="nav-number">2.2.5.3.1.</span> <span class="nav-text">功能函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实现流程"><span class="nav-number">2.2.5.3.2.</span> <span class="nav-text">实现流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结果"><span class="nav-number">2.2.5.4.</span> <span class="nav-text">结果</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#块缓存机制"><span class="nav-number">2.2.6.</span> <span class="nav-text">块缓存机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对文件系统的操作"><span class="nav-number">2.2.7.</span> <span class="nav-text">对文件系统的操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户接口"><span class="nav-number">2.3.</span> <span class="nav-text">用户接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件描述符"><span class="nav-number">2.3.1.</span> <span class="nav-text">文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPC机制的使用"><span class="nav-number">2.3.2.</span> <span class="nav-text">IPC机制的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#传递的指令形式"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">传递的指令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传递函数"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">传递函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件服务进程"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">文件服务进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用户态下调用传递函数"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">用户态下调用传递函数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一点想法"><span class="nav-number">3.</span> <span class="nav-text">一点想法</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fjh</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
