<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="OS,syscall,">










<meta name="description" content="lab4做了什么支持缺页中断处理完成基本的系统调用我认为系统调用的实质就是用户态的进程想使用一些内核态下的功能,比如分配内存空间,创建进程等等,但是由于操作系统要保障安全性,所以这些接口不能向用户程序开放,所以采用一个折中的方法,即系统调用,用户将一些必要的信息以参数的形式传递给内核,内核判断你的操作是否合法,合法则执行并将结果返回给用户,否则拒绝执行 实现forkfork就是以父进程为模板创建一">
<meta name="keywords" content="OS,syscall">
<meta property="og:type" content="article">
<meta property="og:title" content="OS-lab4">
<meta property="og:url" content="http://yoursite.com/2019/05/03/OS-lab4/index.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:description" content="lab4做了什么支持缺页中断处理完成基本的系统调用我认为系统调用的实质就是用户态的进程想使用一些内核态下的功能,比如分配内存空间,创建进程等等,但是由于操作系统要保障安全性,所以这些接口不能向用户程序开放,所以采用一个折中的方法,即系统调用,用户将一些必要的信息以参数的形式传递给内核,内核判断你的操作是否合法,合法则执行并将结果返回给用户,否则拒绝执行 实现forkfork就是以父进程为模板创建一">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/05/03/OS-lab4/Users/fjh/Desktop/work/OS-lab4/handle_kind.png">
<meta property="og:image" content="http://yoursite.com/2019/05/03/OS-lab4/Users/fjh/Desktop/work/OS-lab4/cause_register.png">
<meta property="og:image" content="http://yoursite.com/2019/05/03/OS-lab4/Users/fjh/Desktop/work/Os-lab4/epc.png">
<meta property="og:image" content="http://yoursite.com/2019/05/03/OS-lab4/Users/fjh/Desktop/work/OS-lab4/args.png">
<meta property="og:image" content="http://yoursite.com/2019/05/03/OS-lab4/Users/fjh/Desktop/work/OS-lab4/cow.png">
<meta property="og:image" content="http://yoursite.com/2019/05/03/OS-lab4/Users/fjh/Desktop/work/OS-lab4/fork.png">
<meta property="og:image" content="http://yoursite.com/2019/05/03/OS-lab4/ipc.png">
<meta property="og:updated_time" content="2019-05-03T11:43:42.960Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OS-lab4">
<meta name="twitter:description" content="lab4做了什么支持缺页中断处理完成基本的系统调用我认为系统调用的实质就是用户态的进程想使用一些内核态下的功能,比如分配内存空间,创建进程等等,但是由于操作系统要保障安全性,所以这些接口不能向用户程序开放,所以采用一个折中的方法,即系统调用,用户将一些必要的信息以参数的形式传递给内核,内核判断你的操作是否合法,合法则执行并将结果返回给用户,否则拒绝执行 实现forkfork就是以父进程为模板创建一">
<meta name="twitter:image" content="http://yoursite.com/2019/05/03/OS-lab4/Users/fjh/Desktop/work/OS-lab4/handle_kind.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/03/OS-lab4/">





  <title>OS-lab4 | Matrix</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Matrix</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">just do it !</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/03/OS-lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OS-lab4</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-03T19:40:14+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="lab4做了什么"><a href="#lab4做了什么" class="headerlink" title="lab4做了什么"></a>lab4做了什么</h1><h2 id="支持缺页中断处理"><a href="#支持缺页中断处理" class="headerlink" title="支持缺页中断处理"></a>支持缺页中断处理</h2><h2 id="完成基本的系统调用"><a href="#完成基本的系统调用" class="headerlink" title="完成基本的系统调用"></a>完成基本的系统调用</h2><p>我认为系统调用的实质就是用户态的进程想使用一些内核态下的功能,比如分配内存空间,创建进程等等,但是由于操作系统要保障<strong>安全性</strong>,所以这些接口不能向用户程序开放,所以采用一个折中的方法,即<strong>系统调用</strong>,用户将一些必要的信息以<strong>参数的形式</strong>传递给内核,内核判断你的操作是否<strong>合法</strong>,合法则执行并将结果返回给用户,否则拒绝执行</p>
<h2 id="实现fork"><a href="#实现fork" class="headerlink" title="实现fork"></a>实现fork</h2><p><code>fork</code>就是<strong>以父进程为模板</strong>创建一个与其<strong>高度相似</strong>的子进程,其关键的一点特性是<strong>父子进程中的<code>fork</code>返回值不同</strong>,这也是区分父子进程的方法</p>
<h2 id="实现进程间通信"><a href="#实现进程间通信" class="headerlink" title="实现进程间通信"></a>实现进程间通信</h2><p>通信本质上就是<strong>在进程间传递一个数值</strong>, 通过<strong>共享内存</strong>来实现, 共享的就是内核中的进程控制块</p>
<h1 id="提前准备的知识"><a href="#提前准备的知识" class="headerlink" title="提前准备的知识"></a>提前准备的知识</h1><h2 id="MIPS下C与汇编的参数传递"><a href="#MIPS下C与汇编的参数传递" class="headerlink" title="MIPS下C与汇编的参数传递"></a>MIPS下C与汇编的参数传递</h2><p>首先介绍两个关于MIPS汇编的宏定义 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/asm/asm.h</span></span><br><span class="line"><span class="comment">// 用来定义全局叶子汇编函数 : 即在函数内部不需要调用其他函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEAF(symbol)                                    \</span></span><br><span class="line">                .globl  symbol;                         \</span><br><span class="line">                .align  <span class="number">2</span>;                              \</span><br><span class="line">                .type   symbol,@function;               \</span><br><span class="line">                .ent    symbol,<span class="number">0</span>;                       \</span><br><span class="line">symbol:         .frame  sp,<span class="number">0</span>,ra</span><br><span class="line"><span class="comment">// 用来定义全局非叶子汇编函数 : 即在函数内部还调用其他函数 </span></span><br><span class="line"><span class="comment">// 所以在该宏定义结构中已经做了对栈指针的处理</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NESTED(symbol, framesize, rpc)                  \</span></span><br><span class="line">                .globl  symbol;                         \</span><br><span class="line">                .align  <span class="number">2</span>;                              \</span><br><span class="line">                .type   symbol,@function;               \</span><br><span class="line">                .ent    symbol,<span class="number">0</span>;                       \</span><br><span class="line">symbol:         .frame  sp, framesize, rpc</span><br><span class="line"><span class="comment">// 函数结尾</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> END(function)                                   \</span></span><br><span class="line">                .end    function;                       \</span><br><span class="line">                .size   function,.-function</span><br></pre></td></tr></table></figure>
<p><strong>注意我们一般而言只有在接近底层时才有使用到汇编来实现,所以大部分汇编功能都能通过叶子函数完成</strong></p>
<ol>
<li><p>C函数之间的调用 : </p>
<p>所有的参数传递以及返回值的维护由编译器隐式的实现,不需要考虑</p>
</li>
<li><p>MIPS汇编之间的调用</p>
<ul>
<li>调用者需要在代码中显式的在栈中保存受保护寄存器,返回值寄存器等,然后显式的向<code>$a0-$a3</code>中写入参数值,然后调用,返回时要恢复现场</li>
<li>被调用者需要显式的获取参数</li>
<li>参数较多时通过栈传递</li>
</ul>
<p>其实就是<strong>调用者与被调用者遵守并显式的实现统一的调用规则</strong></p>
</li>
<li><p><strong>C调用MIPS汇编函数</strong> : 最常见的一种情况(依据<code>o32ABI</code>的约定)</p>
<ul>
<li>调用者(即C函数) : <ol>
<li>在栈上创建一个容纳参数的空间,从<code>sp</code>指向的位置开始,第一个参数(即C源码中最左侧的参数)位于最低地址处,<strong>每个参数至少占据一个字的大小空间</strong></li>
<li><strong>为任何一个调用都至少分配16字节的栈参数空间,即使没有这么多参数</strong></li>
<li><strong>实际上优先通过的是寄存器传递参数,即参数结构的前16个字节(即4个字)保存在<code>$a0-$a3</code>的寄存器结构中,而栈中的前16个字节的内容未定义,但是其结构必须保存</strong></li>
</ol>
</li>
<li>被调用者(MIPS函数)<ol>
<li>可以选择盲目的将<code>$a0-$a3</code>的写入栈中,也可以不写(取决于该汇编函数的功能)</li>
<li><strong>前4个参数从寄存器获得,之后的参数从栈中获得</strong></li>
</ol>
</li>
</ul>
<p>// 他说此处应该有个图</p>
</li>
<li><p>MIPS汇编函数调用C函数 :</p>
<ul>
<li><p>调用者(即MIPS汇编代码) : 将参数按照C函数的定义从左向右的顺序存入<code>$a0-$a3</code>寄存器中,如果要求在调用结束后保存某些寄存器则要使用栈区保存(<strong>注意<code>ra</code>寄存器是一定要保存的,并在调用结束之后要恢复</strong>),然后直接跳转到C函数的入口地址处即可</p>
<p>注 : 具体实现方法为<strong>在.S文件中使用<code>extern</code>外联定义C函数<code>c_method()</code>,然后直接使用<code>jal c_method</code>即可</strong>(因为<code>jal</code>会写入返回地址到<code>$ra</code>中,而C函数在最后会自动调用<code>jr ra</code>)</p>
</li>
<li><p>被调用者(C函数) : 不用做任何特殊处理,正常编写即可</p>
</li>
</ul>
</li>
</ol>
<h2 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h2><p><strong>时钟中断,系统调用,以及在指令执行中出现的错误都作为一种异常处理</strong></p>
<h3 id="异常处理程序地址"><a href="#异常处理程序地址" class="headerlink" title="异常处理程序地址"></a>异常处理程序地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tools/sces0_3.lds</span></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  . = <span class="number">0x80000080</span>;</span><br><span class="line">  .except_vec3 : &#123;</span><br><span class="line">	*(.text.exc_vec3)</span><br><span class="line">  &#125;<span class="comment">// 可见我们将所有exc_vec3代码段加载到了0x80000080地址处,而这些代码就是最基本的异常处理程序(异常分发程序),实际上该处的代码并没有真正处理异常,只是根据异常类型将其分发给特定的异常处理程序</span></span><br><span class="line">  <span class="comment">// other code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地址<code>0x80000080</code>是当异常发生时<code>CPU</code>将<code>PC</code>跳转到的地址(由<code>MIPS R3000 CPU</code>的设计决定的)</p>
<p>即异常发生时 : <strong>首先是硬件发挥作用,即CPU进行以下行为</strong> : </p>
<ol>
<li>设置<code>EPC</code>为异常处理结束后重新开始的程序地址</li>
<li>设置<code>CP0</code>的<code>SR</code>寄存器中的<code>EXL</code>位使得<code>CPU</code>进入内核态<strong>禁止中断</strong></li>
<li>设置<code>CP0</code>的<code>CAUSE</code>寄存器编码为异常产生原因</li>
<li>设置<code>PC</code>值为异常处理程序的入口地址(在此处即<code>0x80000080</code>)</li>
</ol>
<h3 id="异常类型注册表"><a href="#异常类型注册表" class="headerlink" title="异常类型注册表"></a>异常类型注册表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/traps.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">handle_int</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">handle_reserved</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">handle_tlb</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">handle_sys</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">handle_mod</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 以上具体的实现在外部函数实现</span></span><br><span class="line"><span class="comment">/* 这个数组即是异常向量</span></span><br><span class="line"><span class="comment"> * 向量下标与CAUSE寄存器中的异常类型编号对用</span></span><br><span class="line"><span class="comment"> * 向量每一项为对应异常种类的处理程序的入口地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> exception_handlers[<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">	set_except_vector(i, handle_reserved);</span><br><span class="line">	set_except_vector(<span class="number">0</span>, handle_int);	<span class="comment">//时钟中断异常处理程序</span></span><br><span class="line">	set_except_vector(<span class="number">1</span>, handle_mod);	<span class="comment">//缺页异常处理程序</span></span><br><span class="line">	set_except_vector(<span class="number">2</span>, handle_tlb);	</span><br><span class="line">	set_except_vector(<span class="number">3</span>, handle_tlb);	<span class="comment">//tlb确实异常处理</span></span><br><span class="line">	set_except_vector(<span class="number">8</span>, handle_sys);	<span class="comment">//系统调用异常处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">set_except_vector</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">void</span> * addr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> handler=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> old_handler=exception_handlers[n];</span><br><span class="line">	exception_handlers[n]=handler;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)old_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注 : 异常类型在<code>CAUSE</code>寄存器中对应的编码值</p>
<p><img src="/2019/05/03/OS-lab4/Users/fjh/Desktop/work/OS-lab4/handle_kind.png" alt></p>
<h3 id="异常分发程序"><a href="#异常分发程序" class="headerlink" title="异常分发程序"></a>异常分发程序</h3><p>异常发生时<strong>直接跳转到</strong>的函数地址</p>
<ul>
<li><p>作用 : 根据<code>CAUSE</code>寄存器的值判断异常类型并跳转到对应的处理程序去</p>
</li>
<li><p>实现 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//boot/start.S</span></span><br><span class="line">.section .text.exc_vec3</span><br><span class="line">NESTED(except_vec3, <span class="number">0</span>, sp) <span class="comment">// 非叶子函数因为要跳转到</span></span><br><span class="line">	.<span class="built_in">set</span>	noat</span><br><span class="line">	.<span class="built_in">set</span>	noreorder</span><br><span class="line"><span class="number">1</span>:	<span class="comment">//j	1b</span></span><br><span class="line">	nop</span><br><span class="line">	mfc0	k1,CP0_CAUSE	    <span class="comment">//$k1中存储CAUSE寄存器中的值</span></span><br><span class="line">	andi	k1,<span class="number">0x7c</span>			   <span class="comment">//$k1中存储异常类型的编码值,具体见下文</span></span><br><span class="line">	la	k0,exception_handlers	<span class="comment">//$k0中存储异常向量的起始地址(即数组的基址)</span></span><br><span class="line">	addu	k0,k1			   <span class="comment">//$k0 + $k1 即基址+偏移获得存储(异常处理程序的入口地址)的地址放入$k0中</span></span><br><span class="line">	lw	k0,(k0)				   <span class="comment">//从该地址中取出异常处理程序的入口地址</span></span><br><span class="line">	NOP</span><br><span class="line">	jr	k0					  <span class="comment">//跳转到对应的异常处理程序</span></span><br><span class="line">	nop</span><br><span class="line">	END(except_vec3)</span><br></pre></td></tr></table></figure>
<p>注 : 对<code>andi k1,0x7c</code>的理解</p>
<ol>
<li><p><code>CAUSE</code>寄存器结构如下 :</p>
<p><img src="/2019/05/03/OS-lab4/Users/fjh/Desktop/work/OS-lab4/cause_register.png" alt></p>
</li>
<li><p><code>0x7c = 0x0111_1100</code>,与该数按位与就是获得<code>2-6</code>位的值,从上图可知就是<code>Exc Code</code>的值,所以该操作可以获得异常类型的编码值</p>
</li>
</ol>
</li>
<li><p>在异常分发完之后就是实际的处理程序的运行了</p>
<p>处理异常完成之后即可<strong>返回<code>EPC</code>保存的地址</strong></p>
</li>
</ul>
<h3 id="流程图示"><a href="#流程图示" class="headerlink" title="流程图示"></a>流程图示</h3><p><img src="/2019/05/03/OS-lab4/Users/fjh/Desktop/work/Os-lab4/epc.png" alt></p>
<h1 id="走进lab4"><a href="#走进lab4" class="headerlink" title="走进lab4"></a>走进lab4</h1><h2 id="基本系统调用"><a href="#基本系统调用" class="headerlink" title="基本系统调用"></a>基本系统调用</h2><h3 id="宏观上看一个系统调用的过程"><a href="#宏观上看一个系统调用的过程" class="headerlink" title="宏观上看一个系统调用的过程"></a>宏观上看一个系统调用的过程</h3><ol>
<li>调用一个封装好的用户空间的库函数</li>
<li>调用用户空间的<code>syscall_*</code> 函数</li>
<li>调用<code>msyscall</code>，用于陷入内核态</li>
<li>陷入内核，内核取得信息，执行对应的内核空间的系统调用函数（<code>sys_*</code>）</li>
<li>执行系统调用，并返回用户态，同时将返回值传递回用户态</li>
<li>从库函数返回，回到用户程序调用处</li>
</ol>
<h3 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h3><ol>
<li><p>用户态的行为 : </p>
<ol>
<li><p>调用<code>syscall_*</code>函数,等待返回值(如果有的话)</p>
<p><strong>用户空间不负责任何实质的处理,只是准备好参数之后陷入内核态即可</strong></p>
<p><strong>所有的系统调用都是通过<code>mysyscall</code>陷入内核,通过第一个参数作为系统调用号来区别不同的系统调用种类</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/syscall_lib.c</span></span><br><span class="line"><span class="comment">//所有函数的调用第一个参数是系统调用号(即系统调用类型)</span></span><br><span class="line"><span class="comment">//默认所有的调用都有6个参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_yield</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	msyscall(SYS_yield,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_env_destroy</span><span class="params">(u_int envid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	msyscall(SYS_env_destroy,envid,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall_set_pgfault_handler</span><span class="params">(u_int envid, u_int func, u_int xstacktop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_set_pgfault_handler,envid,func,xstacktop,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall_mem_alloc</span><span class="params">(u_int envid, u_int va, u_int perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_mem_alloc,envid,va,perm,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall_mem_map</span><span class="params">(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_mem_map,srcid,srcva,dstid,dstva,perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即用户准备好必要的信息,然后<strong>包装一层</strong>将第一个参数设置为<strong>系统调用号</strong>,然后内核根据系统调用号的值(<strong>偏移</strong>)决定<strong>真正执行功能的函数的入口地址</strong></p>
<p>这些系统调用号以一个注册表的形式定义在头文件中 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/unistd.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNISTD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNISTD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_BASE 9527</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_SYSCALLS 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_putchar 		((__SYSCALL_BASE ) + (0 ) ) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_getenvid 		((__SYSCALL_BASE ) + (1 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_yield			((__SYSCALL_BASE ) + (2 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_env_destroy		((__SYSCALL_BASE ) + (3 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_set_pgfault_handler	((__SYSCALL_BASE ) + (4 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_mem_alloc		((__SYSCALL_BASE ) + (5 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_mem_map			((__SYSCALL_BASE ) + (6 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_mem_unmap		((__SYSCALL_BASE ) + (7 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_env_alloc		((__SYSCALL_BASE ) + (8 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_set_env_status	((__SYSCALL_BASE ) + (9 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_set_trapframe		((__SYSCALL_BASE ) + (10 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_panic			((__SYSCALL_BASE ) + (11 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_ipc_can_send		((__SYSCALL_BASE ) + (12 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_ipc_recv		((__SYSCALL_BASE ) + (13 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_cgetc			((__SYSCALL_BASE ) + (14 ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用<code>msyscall</code>触发系统调用异常陷入内核态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/syscall_wrap.S</span></span><br><span class="line">LEAF(msyscall)	<span class="comment">//说明该函数是一个全局叶子函数,不需要调用其他函数</span></span><br><span class="line"><span class="comment">// sw	a0,0(sp)</span></span><br><span class="line"><span class="comment">// sw	a1,4(sp)</span></span><br><span class="line"><span class="comment">// sw	a2,8(sp)</span></span><br><span class="line"><span class="comment">// sw	a3,12(sp)</span></span><br><span class="line"><span class="comment">// move	v0, a0</span></span><br><span class="line"><span class="comment">// 将参数存入已经在C函数调用汇编函数时分配好的栈空间中</span></span><br><span class="line"><span class="comment">// 我认为目的就是稳一手,防止在异常分发程序中使用这些寄存器破坏数据(反正空间都已经在那了)</span></span><br><span class="line"><span class="comment">// 稳一手把自己稳炸了,不要写上面这些!!!!</span></span><br><span class="line">syscall	<span class="comment">//触发系统调用异常</span></span><br><span class="line">jr	ra</span><br><span class="line">END(msyscall)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p><strong>当调用<code>syscall</code>时发生了什么 : </strong></p>
<p>触发<strong>系统调用异常</strong>按照<strong>上面描述的异常处理流程</strong>将该异常分发到<strong>系统调用处理程序</strong></p>
</li>
<li><p>上述的保存寄存器代码段是依据于系统调用约定 :</p>
<ol>
<li><del>系统调用号放入<code>$v0</code></del>(课上测试不放我有什么办法)</li>
<li>参数的传递按照<code>o32ABI</code>的约定进行 :</li>
</ol>
<ul>
<li>在<code>syscall_lib.c</code>中C函数调用<code>msyscall(SYS_*, arg1,...arg5)</code>时<strong>依据约定栈区划定24字节空间,前4个参数通过<code>$a0-$a3</code>传递,后两个参数通过栈区传递</strong><ul>
<li><del>我为什么不能把所有的参数都放进栈中,为什么,艹</del></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>内核态的行为</p>
<ol>
<li><p>接下来运行<strong>系统调用异常处理程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/syscall.S</span></span><br><span class="line">NESTED(handle_sys,TF_SIZE, sp)</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有的异常处理的第一步都是保存现场(关于保存现场详情移步lab3)</span></span><br><span class="line">SAVE_ALL	<span class="comment">//保存运行现场,即将寄存器全部压栈</span></span><br><span class="line"><span class="comment">// 在上述保存过程中</span></span><br><span class="line">CLI		    <span class="comment">//关闭中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1: j 1b</span></span><br><span class="line">nop</span><br><span class="line">.<span class="built_in">set</span> at</span><br><span class="line"></span><br><span class="line">lw t1, TF_EPC(sp)</span><br><span class="line">addiu t1, <span class="number">4</span></span><br><span class="line">sw	t1, TF_EPC(sp)</span><br><span class="line"><span class="comment">//从保存的现场中取出EPC再+4之后存回,即为异常处理结束之后的重新开始运行的PC值</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//从保存的现场中取出$4即$a0的值存入a0当中去</span></span><br><span class="line">lw a0, TF_REG4(sp)	<span class="comment">//a0即保存的系统调用号</span></span><br><span class="line">addiu a0, a0, -SYSCALL_BASE	<span class="comment">//获得偏移,即获得了系统调用的具体种类</span></span><br><span class="line">sll	t0, a0,<span class="number">2</span></span><br><span class="line">la	t1, sys_call_table	<span class="comment">//t1为系统调用注册表(即下文的入口地址表)的起始地址</span></span><br><span class="line">addu	t1, t1, t0		<span class="comment">//根据偏移得到(具体系统调用函数的入口地址)的地址</span></span><br><span class="line">lw	t2, <span class="number">0</span>(t1)			<span class="comment">//取出入口地址放入$t2</span></span><br><span class="line">lw	t0,TF_REG29(sp)		<span class="comment">//取出保存现场保存的用户态下的栈指针放入$t0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意参数的不同分布</span></span><br><span class="line"><span class="comment">// 前4个参数由于是通过$ai来传递的,所以在保存现场时被存在TF区域,要从这里恢复</span></span><br><span class="line"><span class="comment">// 后两个参数本身就是通过栈来传递的,所以在用户的sp栈指针所指的栈中,而这个栈指针已经取到$t0中去了</span></span><br><span class="line">lw t3, <span class="number">16</span>($t0)</span><br><span class="line">lw t4, <span class="number">20</span>($t0)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//恢复$a0-$a3参数</span></span><br><span class="line">lw a0, TF_REG4(sp)</span><br><span class="line">lw a1, TF_REG5(sp)</span><br><span class="line">lw a2, TF_REG6(sp)</span><br><span class="line">lw a3, TF_REG7(sp)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//然后准备参数,调用对应的系统调用(调用C函数)</span></span><br><span class="line"><span class="comment">//参数 : 前4个通过寄存器传,后面两个通过sp栈区传</span></span><br><span class="line"><span class="comment">//但是在栈区还是要留前4个参数的空间,只不过什么都不存(我也不知道为什么,艹)</span></span><br><span class="line">addiu sp, sp, <span class="number">-24</span></span><br><span class="line">sw t3, <span class="number">16</span>(sp)</span><br><span class="line">sw t4, <span class="number">20</span>(sp)</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line">jalr t2</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复栈指针</span></span><br><span class="line">addiu sp, sp, <span class="number">24</span></span><br><span class="line">   </span><br><span class="line">sw	v0, TF_REG2(sp)</span><br><span class="line"></span><br><span class="line">j	ret_from_exception</span><br><span class="line">nop</span><br><span class="line">END(handle_sys)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 系统调用注册表    </span></span><br><span class="line">sys_call_table:</span><br><span class="line">.align <span class="number">2</span></span><br><span class="line">    .word sys_putchar	<span class="comment">//每一个word存储该系统调用函数的入口地址</span></span><br><span class="line">    .word sys_getenvid</span><br><span class="line">    .word sys_yield</span><br><span class="line">    .word sys_env_destroy</span><br><span class="line">    .word sys_set_pgfault_handler</span><br><span class="line">    .word sys_mem_alloc</span><br><span class="line">    .word sys_mem_map</span><br><span class="line">    .word sys_mem_unmap</span><br><span class="line">    .word sys_env_alloc</span><br><span class="line">    .word sys_set_env_status</span><br><span class="line">    .word sys_set_trapframe</span><br><span class="line">    .word sys_panic</span><br><span class="line">    .word sys_ipc_can_send</span><br><span class="line">    .word sys_ipc_recv</span><br><span class="line">    .word sys_cgetc</span><br></pre></td></tr></table></figure>
<p><strong>参数分布图示</strong></p>
<p><img src="/2019/05/03/OS-lab4/Users/fjh/Desktop/work/OS-lab4/args.png" alt></p>
<p>下面我就想不通了 : </p>
<ul>
<li>在异常分发阶段只是使用了<code>$k0,$k1</code>寄存器</li>
<li>在进入系统调用异常处理程序即<code>handle_sys</code>已经关闭了时钟中断</li>
<li>在<code>SAVA_ALL</code>和恢复参数之间并没有使用<code>$a0-$a3</code>寄存器</li>
</ul>
<p>所以这个保存现场+恢复在目前看来完全是无用操作,在最后设置参数时只需设置<code>args[4],args[5]</code>即可(实测可以跑)</p>
<p>我认为有以下考虑 :</p>
<ol>
<li>操作的统一性 : 处理异常第一件事就是保存现场</li>
<li>后续扩展功能可能破坏寄存器</li>
<li><del>课上测试换你文件</del></li>
</ol>
</li>
<li><p>接下来便是各种<del>神奇</del>的系统调用了</p>
</li>
</ol>
</li>
</ol>
<h4 id="各种系统调用"><a href="#各种系统调用" class="headerlink" title="各种系统调用"></a>各种系统调用</h4><ol>
<li><p><code>void sys_yield(void)</code> : </p>
<ul>
<li><p>函数作用 : 在用户态下做到进程切换</p>
</li>
<li><p>具体实现 : </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_yield</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先保存现场</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> * <span class="title">src</span> = (<span class="title">struct</span> <span class="title">Trapframe</span> *)(<span class="title">KERNEL_SP</span> - <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trapframe</span>));</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> * <span class="title">dst</span> = (<span class="title">struct</span> <span class="title">Trapframe</span> *)(<span class="title">TIMESTACK</span> - <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trapframe</span>));</span></span><br><span class="line">	bcopy((<span class="keyword">void</span> *)src,(<span class="keyword">void</span> *)dst,<span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">	sched_yield();<span class="comment">//执行时间片轮转调度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两个问题 : </p>
<ul>
<li><p><strong>为什么在此处我们保存现场时将<code>KERNEL_SP</code>栈中的数据保存到<code>TIMESTACK</code>栈中去,而在<code>lab3</code>中的进程切换的保存恢复现场都是在<code>TIMESTACK</code>中进行的 ? </strong></p>
<p><del>很不幸,这个问题沙雕的我不想思考</del></p>
<p>我认为<strong><code>kERNEL_SP</code>是系统调用异常时保存现场的区域,而<code>TIMESTACK</code>是时钟中断异常时保存现场的区域</strong></p>
<p><strong>其实这个关键在于<code>SAVE_ALL</code>中的<code>get_sp</code></strong> : </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/stackframe.h</span></span><br><span class="line">.macro SAVE_ALL    </span><br><span class="line">                                  </span><br><span class="line">		mfc0	k0,CP0_STATUS                   </span><br><span class="line">		sll		k0,<span class="number">3</span>   </span><br><span class="line">		bltz	k0,<span class="number">1f</span>                            </span><br><span class="line">		nop      		           </span><br><span class="line"><span class="number">1</span>:				</span><br><span class="line">		move	k0,sp </span><br><span class="line">		get_sp      <span class="comment">//获取要保存寄存器的栈的栈指针</span></span><br><span class="line">		move	k1,sp                     </span><br><span class="line">		subu	sp,k1,TF_SIZE  <span class="comment">// 栈指针下移获得空间                 </span></span><br><span class="line">		sw	k0,TF_REG29(sp)    <span class="comment">// 保存寄存器</span></span><br><span class="line">		........</span><br><span class="line">.macro get_sp</span><br><span class="line">	mfc0	k1, CP0_CAUSE</span><br><span class="line">	andi	k1, <span class="number">0x107C</span>	<span class="comment">//获取CAUSE寄存器中的ExcCode段</span></span><br><span class="line">	xori	k1, <span class="number">0x1000</span></span><br><span class="line">	bnez	k1, <span class="number">1f</span></span><br><span class="line">	nop</span><br><span class="line">	li	sp, <span class="number">0x82000000</span>	<span class="comment">//取TIMESTACK为保存的栈</span></span><br><span class="line">	j	<span class="number">2f</span></span><br><span class="line">	nop</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">	bltz	sp, <span class="number">2f</span></span><br><span class="line">	nop</span><br><span class="line">	lw	sp, KERNEL_SP  <span class="comment">//取KERNEL_SP为保存的栈</span></span><br><span class="line">	nop</span><br><span class="line"><span class="number">2</span>:	nop</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>
<p>即 : </p>
<ul>
<li><strong>在系统调用时异常处理程序第一步是将寄存器信息保存到<code>KERNEL_SP</code>栈区</strong></li>
<li><strong>在时钟中断时异常处理程序第一步是将寄存器信息保存到<code>TIMESTACK</code>栈区</strong></li>
</ul>
<p>所以该函数的实现如下 : </p>
<ol>
<li><p>进入该函数时寄存器信息已经保存到<code>KERNEL_SP</code>栈区了(<code>handle_sys</code>中进行)</p>
</li>
<li><p><strong>但是在<code>env_run</code>中我们默认是时钟中断导致的进程切换,没有考虑用户显式的命令进程切换,所以我们在切换之前保存当前进程信息都是从<code>TIMESTACK</code>中取数据,所以一定要将<code>KERNEL_SP</code>中的现场在<code>TIMESTACK</code>中备份一份以便进程切换</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/env.c/evn_run()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> *<span class="title">old</span> = (<span class="title">struct</span> <span class="title">Trapframe</span> *)(<span class="title">TIMESTACK</span>-<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trapframe</span>));</span></span><br><span class="line">	<span class="keyword">if</span>(curenv)&#123;</span><br><span class="line">		bcopy(old,&amp;(curenv-&gt;env_tf),<span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">		<span class="comment">//curenv-&gt;env_tf.pc += 4;//aim to mips 32</span></span><br><span class="line">		curenv-&gt;env_tf.pc = old-&gt;cp0_epc;</span><br><span class="line">		<span class="comment">//printf("cp0_epc:%x\n",curenv-&gt;env_tf.pc);</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><strong>调度函数的逻辑需要修改</strong></p>
<p>在<code>lab4</code>的进程切换函数中我们有了新的需求,我认为大概要求如下 : </p>
<ol>
<li>待调度链表中可以有状态为<code>ENV_NOTRUNNABLE</code>的进程控制块,要求其不能被调度</li>
<li><strong>用户态可以使用系统调用设置一个进程为<code>ENV_NOTRUNNABLE</code>状态,要求进入调度算法时当前进程若为<code>ENV_NOTRUNNABLE</code>,即使其时间片还未用完也调度走</strong></li>
</ol>
<p>在<code>lab3</code>的基础上增加几个判断即可,基本思想还是<strong>用两个链表模拟循环链表</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/sched.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_yield</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	counter++;</span><br><span class="line">	<span class="keyword">if</span> (curenv == <span class="literal">NULL</span> || counter &gt;= curenv-&gt;env_pri || curenv-&gt;env_status != ENV_RUNNABLE)	<span class="comment">//进程未NOTRUNNABLE立即调度</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (curenv != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LIST_INSERT_TAIL(&amp;env_sched_liat[t^<span class="number">1</span>], curenv, env_sched_link);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span>  <span class="title">Env</span> *<span class="title">e</span> = <span class="title">LIST_FIRST</span>(&amp;<span class="title">env_sched_list</span>[<span class="title">t</span>]);</span></span><br><span class="line">			<span class="keyword">if</span> (e == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				t = t ^ <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (e-&gt;env_status == ENV_RUNNABLE)</span><br><span class="line">			&#123;</span><br><span class="line">				LIST_REMOVE(e, env_sched_link);</span><br><span class="line">				counter = <span class="number">0</span>;</span><br><span class="line">				env_run(e);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;	<span class="comment">//NOT_RUNNABKLE的扔到另一个链表中</span></span><br><span class="line">				LIST_REMOVE(e, env_sched_link);</span><br><span class="line">				LIST_INSERT_TAIL(&amp;env_sched_list[t^<span class="number">1</span>], e, env_sched_link);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	env_run(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>int sys_mem_alloc(iint sysno, u_int envid, u_int va, u_int perm)</code> : </p>
<ul>
<li><p>函数作用 : 给指定进程<code>envid</code>的指定地址<code>va</code>分配一页地址</p>
</li>
<li><p>具体实现 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_mem_alloc</span><span class="params">(<span class="keyword">int</span> sysno, u_int envid, u_int va, u_int perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//检查虚拟地址va是否合法</span></span><br><span class="line">	<span class="keyword">if</span>(va&gt;=UTOP || va&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,use sys_mem_alloc must promise va &lt; UTOP(%x),but now va:%x\n"</span>,UTOP,va);</span><br><span class="line">		<span class="keyword">return</span> -E_UNSPECIFIED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//检查权限位</span></span><br><span class="line">	<span class="keyword">if</span>((perm &amp; PTE_COW) || !(perm &amp; PTE_V))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,use sys_mem_alloc must promise perm not contain PTE_COW.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">ppage</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(envid2env(envid,&amp;env,<span class="number">0</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,you can't get the env by the given env_id.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//新分配一个物理页</span></span><br><span class="line">	<span class="keyword">if</span>(page_alloc(&amp;ppage)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,use sys_mem_alloc can't get a free page memory.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">	ppage-&gt;pp_ref++;</span><br><span class="line">    <span class="comment">//在进程的页表中建立映射关系</span></span><br><span class="line">	<span class="keyword">if</span>(page_insert(env-&gt;env_pgdir,ppage,va,perm)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_mem_alloc we can't insert the alloced page to env_pgdir.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注 : 关于<code>envid2env中的checkperm参数</code> : </p>
<ol>
<li>当为0时不影响</li>
<li>当为1是要求查询的进程<strong>为当前进程或者当前进程的直接子进程</strong></li>
</ol>
</li>
</ul>
</li>
<li><p><code>int sys_mem_map(int sysno, u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</code> : </p>
<ul>
<li><p>函数作用 : 在目标进程<code>dstid</code>的页表结构中以<code>perm</code>的权限建设从虚拟页<code>dstva</code>到源进程<code>srcid</code>中<code>srcva</code>对应的物理页的页表映射结构</p>
</li>
<li><p>具体实现 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_mem_map</span><span class="params">(<span class="keyword">int</span> sysno, u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	u_int round_srcva, round_dstva;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srcenv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">dstenv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">ppage</span>;</span></span><br><span class="line">	Pte *ppte;</span><br><span class="line">	ppage = <span class="literal">NULL</span>;</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">	round_srcva = ROUNDDOWN(srcva, BY2PG);</span><br><span class="line">	round_dstva = ROUNDDOWN(dstva, BY2PG);</span><br><span class="line">    <span class="comment">//检查地址是否合法</span></span><br><span class="line">	<span class="keyword">if</span>(srcva&gt;=UTOP || dstva&gt;=UTOP || srcva&lt;<span class="number">0</span> || dstva&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,srcva:%x and dstva:%x must &lt;UTOP(%x).\n"</span>,srcva,dstva,UTOP);</span><br><span class="line">		<span class="keyword">return</span> -E_UNSPECIFIED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//检查权限位是否合法</span></span><br><span class="line">	<span class="keyword">if</span>(!(perm &amp; PTE_V))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_mem_map perm is illegal.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获得进程控制结构</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(srcid,&amp;srcenv,<span class="number">0</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,we can't get srcenv!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(envid2env(dstid,&amp;dstenv,<span class="number">0</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,we can't get dstenv!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//从srcenv中获取要映射的物理页</span></span><br><span class="line">	<span class="keyword">if</span>((ppage=page_lookup(srcenv-&gt;env_pgdir,round_srcva,&amp;ppte))==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,we found srcenv not exist page at %x.\n"</span>,round_srcva);</span><br><span class="line">		<span class="keyword">return</span> -E_UNSPECIFIED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在dstenv中建立页表映射关系</span></span><br><span class="line">	<span class="keyword">if</span>(page_insert(dstenv-&gt;env_pgdir,ppage,round_dstva,perm)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_mem_map can't insert src page to dst page.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>int sys_mem_unmap(int sysno, u_int envid, u_int va)</code> : </p>
<ul>
<li><p>函数作用 : 在进程<code>envid</code>的页表结构中去掉<code>va</code>虚拟页的映射结构</p>
</li>
<li><p>具体实现 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_mem_unmap</span><span class="params">(<span class="keyword">int</span> sysno, u_int envid, u_int va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(va&gt;=UTOP)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_mem_unmap va:%x &gt;=UTOP %x.\n"</span>,va,UTOP);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid,&amp;env,PTE_V)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_mem_unmap we can't get env.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	page_remove(env-&gt;env_pgdir,va);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>int sys_env_alloc(void)</code> : 这个函数与一般概念上的建立进程不同</p>
<ul>
<li><p>函数作用 : <strong>以当前进程作为父进程, 以父进程为模板创建一个高度相似的子进程</strong></p>
</li>
<li><p>具体实现 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_env_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="comment">//分配进程控制块</span></span><br><span class="line">	<span class="keyword">if</span>(env_alloc(&amp;e,curenv-&gt;env_id)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,because unable allocate a env,fork failed.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">	e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    e-&gt;env_pri = curenv-&gt;env_pri;</span><br><span class="line">    <span class="comment">//插入调度链表</span></span><br><span class="line">    LIST_INSERT(&amp;env_sched_list[<span class="number">0</span>], e, env_sched_link);</span><br><span class="line">    <span class="comment">//将父进程的环境拷贝一份给子进程</span></span><br><span class="line">	bcopy(KERNEL_SP-<span class="keyword">sizeof</span>(struct Trapframe),&amp;(e-&gt;env_tf),<span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">    <span class="comment">//之后这两条语句很重要,详见下文</span></span><br><span class="line">	e-&gt;env_tf.pc = e-&gt;env_tf.cp0_epc;</span><br><span class="line">	e-&gt;env_tf.regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">     </span><br><span class="line">**注 : 这个函数其实东西比较多 : **</span><br><span class="line">     </span><br><span class="line">* `e-&gt;env_tf.pc = e-&gt;env_tf.cp0_epc`</span><br><span class="line">     </span><br><span class="line">  **即子进程下一次被调度运行是从父进程创建子进程的系统调用后一条语句开始的**</span><br><span class="line">     </span><br><span class="line">       1. `e-&gt;env_tf.cp0_epc`是由**父进程拷贝过来**,所以该数据保存的是**父进程调用该系统调用创建子进程时的中断语句**</span><br><span class="line">  2. `e-&gt;env_tf.pc`是**子进程下一次开始运行的语句**</span><br><span class="line">     </span><br><span class="line">* **`e-&gt;env_tf.regs[2] = 0`** : **这句话很重要,它是`fork`机制父子进程返回值不同的基础**</span><br><span class="line">     </span><br><span class="line">       1. `e-&gt;env_tf.regs[2]`中保存的是**子进程保护现场中的返回值`v0`寄存器值,本来应该存储的是父进程的返回值(其实就是子进程的`env_id`)**</span><br><span class="line">       2. **将其值人为的赋值为0即可实现在调用子进程恢复现场时使得返回值为0,即实现`fork`函数子进程返回0,父进程返回子进程`id`**</span><br><span class="line"></span><br><span class="line">## 缺页中断处理</span><br><span class="line"></span><br><span class="line">### 一般缺页中断</span><br><span class="line"></span><br><span class="line">#### 处理流程</span><br><span class="line"></span><br><span class="line">1. **硬件工作** : `CPU`根据虚拟地址查`tlb`时`tlb`无效,触发异常,记录缺页异常类型,跳转到异常分发代码</span><br><span class="line">2. **软件工作** : </span><br><span class="line">   1. 异常分发代码判断为缺页异常跳转到`handle_tlb`异常处理代码</span><br><span class="line">   2. 该异常处理代码的作用仅是跳转到`do_refill`函数</span><br><span class="line">   3. 在该函数中具体判断是**`tlb`缺失但页表映射的物理页面存在还是物理页面都不存在**</span><br><span class="line">      * `tlb`缺失但是物理页面存在进行`tlb`重填,即`tlbwr`函数</span><br><span class="line">      * 物理页面不存在进行页表项填写,即`pageout`函数</span><br><span class="line">   4. 异常处理完之后返回,继续运行</span><br><span class="line"></span><br><span class="line">#### 代码细节</span><br><span class="line"></span><br><span class="line">1. `handle_tlb &amp; do_refill`</span><br><span class="line"></span><br><span class="line">​```c</span><br><span class="line">//该函数的作用是根据CP0状态跳转到TLB重填代码或者页表重填代码</span><br><span class="line">NESTED(do_refill,0 , sp)</span><br><span class="line">	.extern	mCONTEXT</span><br><span class="line">1:			</span><br><span class="line">	nop</span><br><span class="line">	lw		k1,mCONTEXT</span><br><span class="line">	and		k1,0xfffff000</span><br><span class="line">	mfc0	k0,CP0_BADVADDR	//CP0_BADVADDR中存储的是导致缺页中断的虚拟地址</span><br><span class="line">	srl		k0,20</span><br><span class="line">	and		k0,0xfffffffc</span><br><span class="line">	addu	k0,k1</span><br><span class="line">	lw		k1,0(k0)</span><br><span class="line">	nop</span><br><span class="line">	move	t0,k1</span><br><span class="line">	and		t0,0x0200</span><br><span class="line">	beqz	t0,NOPAGE</span><br><span class="line">	nop</span><br><span class="line">	and		k1,0xfffff000</span><br><span class="line">	mfc0	k0,CP0_BADVADDR</span><br><span class="line">	srl		k0,10</span><br><span class="line">	and		k0,0xfffffffc</span><br><span class="line">	and		k0,0x00000fff</span><br><span class="line">	addu	k0,k1</span><br><span class="line">	or		k0,0x80000000</span><br><span class="line">	lw		k1,0(k0)</span><br><span class="line">	nop</span><br><span class="line">	move	t0,k1</span><br><span class="line">	and		t0,0x0200</span><br><span class="line">	beqz	t0,NOPAGE</span><br><span class="line">	nop</span><br><span class="line">	move	k0,k1</span><br><span class="line">	and		k0,0x1</span><br><span class="line">	beqz	k0,NoCOW</span><br><span class="line">	nop</span><br><span class="line">	and		k1,0xfffffbff</span><br><span class="line">NoCOW:</span><br><span class="line">	mtc0	k1,CP0_ENTRYLO0</span><br><span class="line">	nop</span><br><span class="line">	tlbwr	//tlb重写填写</span><br><span class="line">	j		2f</span><br><span class="line">	nop</span><br><span class="line">NOPAGE:</span><br><span class="line">	nop</span><br><span class="line">	mfc0	a0,CP0_BADVADDR</span><br><span class="line">	lw		a1,mCONTEXT</span><br><span class="line">	nop</span><br><span class="line">	sw	 	ra,tlbra</span><br><span class="line">	jal		pageout	//缺页处理页表项重填</span><br><span class="line">	nop</span><br><span class="line">	nop</span><br><span class="line">	lw		ra,tlbra</span><br><span class="line">	nop</span><br><span class="line">	j	1b</span><br><span class="line">2:	nop</span><br><span class="line">	jr		ra</span><br><span class="line">	nop</span><br><span class="line">END(do_refill)</span><br><span class="line">    </span><br><span class="line">BUILD_HANDLER tlb	do_refill	cli	   //宏定义定义全局函数handle_tlb,作用仅为跳转到do_refill</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>pageout</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mm/pmap.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pageout</span><span class="params">(<span class="keyword">int</span> va, <span class="keyword">int</span> context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_long r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (context &lt; <span class="number">0x80000000</span>) &#123;</span><br><span class="line">        panic(<span class="string">"tlb refill and alloc error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((va &gt; <span class="number">0x7f400000</span>) &amp;&amp; (va &lt; <span class="number">0x7f800000</span>)) &#123;</span><br><span class="line">        panic(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;it's env's zone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (va &lt; <span class="number">0x10000</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"current env id is:%d,va:%x,context:%x\n"</span>,curenv-&gt;env_id,va,context);</span><br><span class="line">        panic(<span class="string">"^^^^^^TOO LOW^^^^^^^^^"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = page_alloc(&amp;p)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic (<span class="string">"page alloc error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;pp_ref++;</span><br><span class="line">    page_insert((Pde *)context, p, VA2PFN(va), PTE_R);	<span class="comment">//页表项填写</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pageout:\t@@@___0x%x___@@@  ins a page \n"</span>, va);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写时复制导致的缺页中断"><a href="#写时复制导致的缺页中断" class="headerlink" title="写时复制导致的缺页中断"></a>写时复制导致的缺页中断</h3><h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><p>父子进程共享物理内存是有前提条件的 : <strong>共享的物理内存不会被任一进程修改</strong>,当父子进程中有修改共享内存内存（一般是数据段,<strong>标志是用<code>COW</code>保护</strong>）的行为发生时,就会触发一个缺页异常,内核捕获这种缺页中断后,再为发生内存修改的进程相应的地址分配物理页面.</p>
<h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><ol>
<li><strong>硬件工作</strong> : <code>CPU</code>根据虚拟地址查页表时发现物理地址被<code>COW</code>位保护,触发异常,记录缺页异常类型,跳转到异常分发代码</li>
<li><strong>软件工作</strong> : <ol>
<li>异常分发代码判断为缺页异常,跳转到写时复制缺页异常处理代码</li>
<li><strong>在微内核的设计当中内核不做具体的处理,具体的缺页重填代码在用户态实现</strong></li>
<li>用户态分配物理页,建立映射机制</li>
<li>异常中断返回,重新访问该地址,程序继续运行</li>
</ol>
</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="缺页异常处理-内核中"><a href="#缺页异常处理-内核中" class="headerlink" title="缺页异常处理(内核中)"></a>缺页异常处理(内核中)</h5><ol>
<li><p><strong>缺页异常的处理被分发到<code>handle_mod</code>函数处理</strong>(具体的跳转流程详见异常类型注册表与异常分发程序)</p>
<p>这个<code>handle_mod</code>函数藏得很深,使用汇编宏定义来定义</p>
<p>在这个函数中实际上<strong>保存现场关闭中断</strong>之后跳转到实际处理函数<code>page_fault_handler</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/genex.S</span></span><br><span class="line"><span class="comment">//定义全局的异常处理程序的宏定义</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * exception为异常的类型(tlb/mod),函数名为handle_\exception(对应异常类型注册表中的handle_tlb,handle_mod)</span></span><br><span class="line"><span class="comment"> * handler为实际处理该异常的函数,即在该程序内部要跳转到的程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">.macro	BUILD_HANDLER exception handler clear</span><br><span class="line">	.align	<span class="number">5</span></span><br><span class="line">	NESTED(handle_\exception, TF_SIZE, sp)  </span><br><span class="line">	nop</span><br><span class="line">	SAVE_ALL				</span><br><span class="line">	__build_clear_\clear</span><br><span class="line">	.<span class="built_in">set</span>	at</span><br><span class="line">	move	a0, sp</span><br><span class="line">	jal	\handler</span><br><span class="line">	nop</span><br><span class="line">	j	ret_from_exception</span><br><span class="line">	nop</span><br><span class="line">	END(handle_\exception)</span><br><span class="line">.endm</span><br><span class="line">BUILD_HANDLER reserved do_reserved cli	<span class="comment">//定义全局函数handle_resereverd</span></span><br><span class="line">BUILD_HANDLER mod	page_fault_handler cli	<span class="comment">//定义全局函数hanle_mod,在函数中跳转到page_fault_handler中去</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>page_fault_handler</code>函数 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/trap.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">page_fault_handler</span><span class="params">(struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"><span class="comment">//tf参数时在调用放在$a0中,即当前的栈指针,当中保存着运行现场,为一个struct Trapframe结构体大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_int va;</span><br><span class="line">    u_int *tos, d;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">PgTrapFrame</span>;</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">curenv</span>;</span></span><br><span class="line">	bcopy(tf, &amp;PgTrapFrame,<span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">    <span class="comment">//之后这个判断语句主要是为了支持异常处理的重入</span></span><br><span class="line">	<span class="keyword">if</span>(tf-&gt;regs[<span class="number">29</span>] &gt;= (curenv-&gt;env_xstacktop - BY2PG) &amp;&amp; tf-&gt;regs[<span class="number">29</span>] &lt;= (curenv-&gt;env_xstacktop - <span class="number">1</span>))</span><br><span class="line">	&#123;	<span class="comment">//在处理缺页异常时又出现异常</span></span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] = tf-&gt;regs[<span class="number">29</span>] - <span class="keyword">sizeof</span>(struct  Trapframe);</span><br><span class="line">		bcopy(&amp;PgTrapFrame, tf-&gt;regs[<span class="number">29</span>], <span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	<span class="comment">//正常运行中第一次触发缺页异常</span></span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] = curenv-&gt;env_xstacktop - <span class="keyword">sizeof</span>(struct  Trapframe);</span><br><span class="line">		bcopy(&amp;PgTrapFrame, curenv-&gt;env_xstacktop - <span class="keyword">sizeof</span>(struct  Trapframe), <span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//设置重新开始运行的代码为处理缺页异常的</span></span><br><span class="line">	tf-&gt;cp0_epc = curenv-&gt;env_pgfault_handler;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>有关缺页异常处理的重入机制</strong></p>
<p>主要表现在<strong>栈顶指针的设置</strong>上</p>
<ol>
<li><p>正常的程序运行中出现缺页异常对应程序中<code>else</code>情况</p>
<p>此时<strong><code>tf</code>中保存的栈顶指针(即<code>tf-&gt;regs[29]</code>)应该是在<code>USTACKTOP</code>之下,即<code>normal user stack</code>区域</strong></p>
<p>在该情况下要进入缺页异常处理应该<strong>设置栈顶指针为异常处理栈指针</strong>,即<code>tf-&gt;regs[29] = curenv-&gt;env_xstacktop - sizeof(struct  Trapframe)</code></p>
</li>
<li><p>在缺页异常处过程中触发缺页异常对应程序中<code>if</code>情况</p>
<p>此时<strong><code>tf</code>中保存的栈顶指针(即<code>tf-&gt;regs[29]</code>)应该是在<code>UXSTACKTOP</code>之下,即<code>user exception stack</code>区域</strong></p>
<p>在该情况下要进入缺页异常处理应该<strong>将异常处理栈的栈指针下移即可</strong>,即<code>tf-&gt;regs[29] = tf-&gt;regs[29] - sizeof(struct  Trapframe)</code></p>
</li>
</ol>
</li>
<li><p><strong>很奇怪的一点就是这个异常处理函数处理分配异常处理栈区保存现场之外什么也没有做,真正的缺重填在哪?安装微内核设计的原则应该在用户态,但是又是怎么跳转到那里的呢?</strong></p>
<p>关键就在于<strong><code>tf-&gt;cp0_epc = curenv-&gt;env_pgfault_handler</code>, 每个进程控制块中有一项<code>env_pgfault_handler</code>该项中保存的就是请求异常处理程序的入口,通过将其设置为<code>epc</code>实现在异常处理完成恢复现场时设置重新开始运行的地方就是处理缺页异常的代码</strong></p>
</li>
</ul>
</li>
</ol>
<h5 id="缺页异常处理程序注册-用户中"><a href="#缺页异常处理程序注册-用户中" class="headerlink" title="缺页异常处理程序注册(用户中)"></a>缺页异常处理程序注册(用户中)</h5><p>由上文知我们需要 :</p>
<ul>
<li><strong>一段所有进程公用的缺页异常处理代码</strong></li>
<li>在进程建立时<strong>进行缺页异常处理程序入口的注册,即将函数入口地址赋值给<code>env-&gt;env_pgfault_handler</code></strong></li>
</ul>
<p><strong>所以<code>env_pgfault_handler</code>才是真正的处理函数</strong></p>
<p>具体流程如下 :</p>
<ol>
<li><p>在<code>fork</code>中创建子进程时调用<code>set_pgfault_handler(pgfault)</code>注册异常处理程序</p>
</li>
<li><p><code>set_pgfault_handler()</code> :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/pgfault.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_pgfault_handler</span><span class="params">(<span class="keyword">void</span> (*fn)(u_int va, u_int err))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;	</span><br><span class="line">	<span class="keyword">if</span> (__pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_alloc(<span class="number">0</span>, UXSTACKTOP - BY2PG, PTE_V|PTE_R)&lt;<span class="number">0</span> || syscall_set_pgfault_handler(<span class="number">0</span>, __asm_pgfault_handler, UXSTACKTOP)&lt;<span class="number">0</span>)</span><br><span class="line"> <span class="comment">//为异常处理分配所需的栈并且完成异常处理注册</span></span><br><span class="line">		&#123;</span><br><span class="line">			writef(<span class="string">"cannot set pgfault handler\n"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	__pgfault_handler = fn;	<span class="comment">//fn即传入的函数指针指向pgfault()函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述函数将<code>__pgfault_handler</code>的值设为<code>pafault()</code>(<strong>真正深藏不露的缺页异常处理函数</strong>)的入口地址 :</p>
<p><strong>该函数将<code>COW</code>保护的物理页复制一份并在当前进程建立映射,这要父子进程的修改就互不相干了</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/fork.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pgfault</span><span class="params">(u_int va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int temp = <span class="number">0x50000000</span>;	<span class="comment">//临时使用的一个虚拟地址</span></span><br><span class="line">	va = ROUNDDOWN(va,BY2PG);	<span class="comment">//要复制的目标对应的虚拟地址</span></span><br><span class="line">	u_int perm = (*vpt)[VPN(va)]&amp; <span class="number">0xfff</span>;</span><br><span class="line">	<span class="keyword">if</span>(perm &amp; PTE_COW)&#123;</span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_alloc(<span class="number">0</span>,temp,perm &amp;(~PTE_COW))&lt;<span class="number">0</span>)&#123; <span class="comment">//为临时虚拟地址temp分配一个物理页</span></span><br><span class="line">			user_panic(<span class="string">"syscall_mem_alloc error.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		user_bcopy((<span class="keyword">void</span> *)va,(<span class="keyword">void</span> *)temp,BY2PG);<span class="comment">//将va对应物理页中数据复制到temp对应的物理页中</span></span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_map(<span class="number">0</span>,temp,<span class="number">0</span>,va,perm &amp;(~PTE_COW))&lt;<span class="number">0</span>)&#123;<span class="comment">//修改va映射的物理页为temp映射的物理页</span></span><br><span class="line">			user_panic(<span class="string">"syscall_mem_map error.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_unmap(<span class="number">0</span>,temp)&lt;<span class="number">0</span>)&#123;<span class="comment">//解除临时虚拟地址temp的映射关系</span></span><br><span class="line">			user_panic(<span class="string">"syscall_mem_unmap error.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		user_panic(<span class="string">"va page is not PTE_COW.\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述函数调用了<code>syscall_set_pgfault_handler</code>,这是一个系统调用,其对应的内核中的功能代码如下 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/syscall_all.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_set_pgfault_handler</span><span class="params">(<span class="keyword">int</span> sysno, u_int envid, u_int func, u_int xstacktop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid,&amp;env,PTE_V)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_set_pgfault_handler we can't get env by envid.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	env-&gt;env_pgfault_handler = func;	<span class="comment">//设置真正的处理缺页异常的代码</span></span><br><span class="line">	env-&gt;env_xstacktop = xstacktop;		<span class="comment">//设置异常处理栈</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由上述代码我们知道真正的异常处理函数(即<code>env_pgfault_handler</code>)应该是<strong><code>__asm_pgfault_handler</code></strong> (其实里面还是通过调用<code>pgfault</code>实现 ) :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/entry.S</span></span><br><span class="line">__asm_pgfault_handler:</span><br><span class="line">nop</span><br><span class="line">	lw	a0, TF_BADVADDR(sp)</span><br><span class="line">	lw	t1, __pgfault_handler	<span class="comment">//这个函数就是pgfault()</span></span><br><span class="line">	jalr	t1</span><br><span class="line"></span><br><span class="line">nop</span><br><span class="line"><span class="comment">//异常处理结束,恢复现场</span></span><br><span class="line">	lw	v1,TF_LO(sp)                                       </span><br><span class="line">		mtlo	v1                               </span><br><span class="line">		lw	v0,TF_HI(sp)                                         </span><br><span class="line">		lw	v1,TF_EPC(sp)                    </span><br><span class="line">		mthi	v0                               </span><br><span class="line">		mtc0	v1,CP0_EPC                                             </span><br><span class="line">		lw	$<span class="number">31</span>,TF_REG31(sp)                 </span><br><span class="line">		........</span><br><span class="line">		lw	$<span class="number">1</span>,TF_REG1(sp) </span><br><span class="line">		lw	k0,TF_EPC(sp) 	</span><br><span class="line">		jr	k0			</span><br><span class="line">		lw	sp,TF_REG29(sp)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="流程图示-1"><a href="#流程图示-1" class="headerlink" title="流程图示"></a>流程图示</h4><p><img src="/2019/05/03/OS-lab4/Users/fjh/Desktop/work/OS-lab4/cow.png" alt></p>
<h2 id="fork实现"><a href="#fork实现" class="headerlink" title="fork实现"></a>fork实现</h2><h3 id="fork的功能"><a href="#fork的功能" class="headerlink" title="fork的功能"></a>fork的功能</h3><ol>
<li>以父进程为模板创建一个高度相似的子进程</li>
<li>要求父子进程中<code>fork</code>函数的返回值不同<ul>
<li>在父进程中返回子进程的<code>envid</code></li>
<li>在子进程中返回0</li>
</ul>
</li>
</ol>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/entry.S</span></span><br><span class="line">vpt:</span><br><span class="line">	.word UVPT</span><br><span class="line">vpd:</span><br><span class="line">	.word (UVPT+(UVPT&gt;&gt;<span class="number">12</span>)*<span class="number">4</span>)</span><br><span class="line"><span class="comment">//user/fork.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int newenvid;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">envs</span>;</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span><span class="comment">//将其指向当前的进程，如果子进程无法创建，则指向父进程</span></span><br><span class="line">	u_int i;</span><br><span class="line">	<span class="comment">//设置缺页中断处理</span></span><br><span class="line">	set_pgfault_handler(pgfault);	</span><br><span class="line">	<span class="keyword">if</span>((newenvid = syscall_env_alloc())==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//在syscall中直接设置子进程保存现场中的返回值为0,所以实现返回值不同</span></span><br><span class="line">        <span class="comment">//即当前是子进程运行的话直接进入该分支返回</span></span><br><span class="line">		env = &amp;envs[ENVX(syscall_getenvid())];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	我们只需要将父进程中相关的用户空间的页复制到子进程用户空间即可</span></span><br><span class="line"><span class="comment">	所谓的复制实际上只是建立映射到同一物理地址的映射而已,物理数据只有一份</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	注意创建一个进程的时候会调用env_vm_init函数，这个函数中以内核页表为模板建立UTOP以上的映射</span></span><br><span class="line"><span class="comment">	所以我们创建子进程，复制父进程的地址空间只需要复制UTOP以下的页即可，因为所有进程UTOP以上的页都是利用</span></span><br><span class="line"><span class="comment">	boot_pgdir作为模板复制的，不需要再次复制拷贝</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;UTOP-BY2PG;i+=BY2PG)&#123;</span><br><span class="line">		<span class="keyword">if</span>(((*vpd)[VPN(i)/<span class="number">1024</span>])!=<span class="number">0</span> &amp;&amp; ((*vpt)[VPN(i)])!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里的(*vpd/t)[]的用法就相当于数组下标的用法</span></span><br><span class="line"><span class="comment">    (*vpd)[i]为第i个页目录项</span></span><br><span class="line"><span class="comment">    (*vpt)[i]为第i个页表项</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">			duppage(newenvid,VPN(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//搭建异常处理栈，分配一个页，让别的进程不抢占此页</span></span><br><span class="line">	<span class="keyword">if</span>(syscall_mem_alloc(newenvid,UXSTACKTOP-BY2PG,PTE_V|PTE_R)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		user_panic(<span class="string">"failed alloc UXSTACK.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//帮助子进程注册错误处理函数</span></span><br><span class="line">	<span class="keyword">if</span>(syscall_set_pgfault_handler(newenvid,__asm_pgfault_handler,UXSTACKTOP)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		user_panic(<span class="string">"page fault handler setup failed.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//至此子进程可以进行调度运行了</span></span><br><span class="line">	syscall_set_env_status(newenvid,ENV_RUNNABLE);</span><br><span class="line">	writef(<span class="string">"OK! newenvid is:%d\n"</span>,newenvid);</span><br><span class="line">	<span class="keyword">return</span> newenvid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>duppage</code>函数 :</p>
<p>该函数作用 : </p>
<ul>
<li>建立子进程中到共享物理页的映射</li>
<li>将可写入的共享区域的页用<code>COW</code>的权限位保护起来</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/fork.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">duppage</span><span class="params">(u_int envid, u_int pn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u_int perm;</span><br><span class="line">	perm = (*vpt)[pn] &amp; <span class="number">0xfff</span>; <span class="comment">//取出标记位</span></span><br><span class="line">	<span class="keyword">if</span>((((perm &amp; PTE_R) !=<span class="number">0</span>) || ((perm &amp; PTE_COW)!=<span class="number">0</span>)) &amp;&amp; (perm &amp; PTE_V))&#123;</span><br><span class="line">		<span class="keyword">if</span>(perm &amp; PTE_LIBRARY)&#123;</span><br><span class="line">			perm = PTE_V | PTE_R | PTE_LIBRARY;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			perm = PTE_V | PTE_R | PTE_COW;</span><br><span class="line">		&#125;</span><br><span class="line">       	<span class="comment">//以保护权限建立子进程到共享物理页的映射</span></span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_map(<span class="number">0</span>,pn*BY2PG,envid,pn*BY2PG,perm)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			user_panic(<span class="string">"syscall_mem_map for son failed.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//在父进程中对共享物理页做权限保护</span></span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_map(<span class="number">0</span>,pn*BY2PG,<span class="number">0</span>,pn*BY2PG,perm)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			user_panic(<span class="string">"syscall_mem_map for father failed.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(syscall_mem_map(<span class="number">0</span>,pn*BY2PG,envid,pn*BY2PG,perm)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			user_panic(<span class="string">"syscall_mem_map for son failed.1\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fork图示"><a href="#fork图示" class="headerlink" title="fork图示"></a>fork图示</h3><p><img src="/2019/05/03/OS-lab4/Users/fjh/Desktop/work/OS-lab4/fork.png" alt></p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过所有进程共享的内核空间中的进程控制块结构<code>envs[]</code>来实现不同进程之间的传递数据(即通信)</p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><ol>
<li><p><code>env</code>控制块中的对应该功能的数据域</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/env.h</span></span><br><span class="line">    u_int env_ipc_value;            <span class="comment">// 进程间要传递的数据</span></span><br><span class="line">	u_int env_ipc_from;             <span class="comment">// 发送信息到该进程的源进程</span></span><br><span class="line">	u_int env_ipc_recving;          <span class="comment">// 为1表示该进程在等待接受信息状态</span></span><br><span class="line">	u_int env_ipc_dstva;		   <span class="comment">// 该进程进程间的共享物理页面映射到的虚拟地址</span></span><br><span class="line">	u_int env_ipc_perm;			   <span class="comment">// 建立映射的权限位</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接受信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/syscall_all.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_ipc_recv</span><span class="params">(<span class="keyword">int</span> sysno, u_int dstva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//检查地址有效性</span></span><br><span class="line">	<span class="keyword">if</span>(dstva&gt;=UTOP)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_ipc_recv the dstva %x need &lt; UTOP %x\n"</span>,dstva,UTOP);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	curenv-&gt;env_ipc_recving = <span class="number">1</span>;	<span class="comment">//设置该进程未等待接受信息状态</span></span><br><span class="line">	curenv-&gt;env_ipc_dstva = dstva;	<span class="comment">//设置将共享共享物理页映射到的虚拟地址</span></span><br><span class="line">	curenv-&gt;env_status = ENV_NOT_RUNNABLE;	<span class="comment">//阻塞该进程,等待接受信息之后才能继续运行</span></span><br><span class="line">	sys_yield();	<span class="comment">//调度其他进程给该进程发送信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib/syscall_all.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_ipc_can_send</span><span class="params">(<span class="keyword">int</span> sysno, u_int envid, u_int value, u_int srcva, u_int perm)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 参数含义 :</span></span></span><br><span class="line"><span class="function"><span class="comment">   1. envid为要发送信息的目标进程的进程号</span></span></span><br><span class="line"><span class="function"><span class="comment">   2. value为要传递的数据信息</span></span></span><br><span class="line"><span class="function"><span class="comment">   3. srcva为要共享的物理页在该进程(发送进程)中映射到的虚拟地址</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">	Pte *ppte;</span><br><span class="line">	<span class="keyword">if</span>(srcva&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"in sys_ipc_can_send found va is 0\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(srcva&gt;=UTOP)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_ipc_can_send srcva %x need &lt;UTOP %x.\n"</span>,srcva,UTOP);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid,&amp;e,<span class="number">0</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_ipc_can_send the envid can't found the env.envid is:%d\n"</span>,envid);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(e-&gt;env_ipc_recving==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,in sys_ipc_can_send we found env_ipc_recving is 0.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((p=page_lookup(curenv-&gt;env_pgdir,srcva,<span class="number">0</span>))&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"send srcva is not exist.srcva is:%x\n"</span>,srcva);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(page_insert(e-&gt;env_pgdir,p,e-&gt;env_ipc_dstva,perm)&lt;<span class="number">0</span>)&#123; <span class="comment">//建立目标进程中共享物理页面的映射</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"dst pot failed.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	e-&gt;env_ipc_perm = perm|PTE_V|PTE_R;</span><br><span class="line">	e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">	e-&gt;env_status = ENV_RUNNABLE;	<span class="comment">//目标进程接受到信息,可以继续运行</span></span><br><span class="line">	e-&gt;env_ipc_value = value;		<span class="comment">//写入要传递的数据</span></span><br><span class="line">	e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="通信图示"><a href="#通信图示" class="headerlink" title="通信图示"></a>通信图示</h3><p><img src="/2019/05/03/OS-lab4/ipc.png" alt></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/OS/" rel="tag"># OS</a>
          
            <a href="/tags/syscall/" rel="tag"># syscall</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/13/OS-lab3/" rel="next" title="OS-lab3">
                <i class="fa fa-chevron-left"></i> OS-lab3
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">fjh</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#lab4做了什么"><span class="nav-number">1.</span> <span class="nav-text">lab4做了什么</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#支持缺页中断处理"><span class="nav-number">1.1.</span> <span class="nav-text">支持缺页中断处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完成基本的系统调用"><span class="nav-number">1.2.</span> <span class="nav-text">完成基本的系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现fork"><span class="nav-number">1.3.</span> <span class="nav-text">实现fork</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现进程间通信"><span class="nav-number">1.4.</span> <span class="nav-text">实现进程间通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#提前准备的知识"><span class="nav-number">2.</span> <span class="nav-text">提前准备的知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MIPS下C与汇编的参数传递"><span class="nav-number">2.1.</span> <span class="nav-text">MIPS下C与汇编的参数传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常处理流程"><span class="nav-number">2.2.</span> <span class="nav-text">异常处理流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#异常处理程序地址"><span class="nav-number">2.2.1.</span> <span class="nav-text">异常处理程序地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常类型注册表"><span class="nav-number">2.2.2.</span> <span class="nav-text">异常类型注册表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常分发程序"><span class="nav-number">2.2.3.</span> <span class="nav-text">异常分发程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流程图示"><span class="nav-number">2.2.4.</span> <span class="nav-text">流程图示</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#走进lab4"><span class="nav-number">3.</span> <span class="nav-text">走进lab4</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本系统调用"><span class="nav-number">3.1.</span> <span class="nav-text">基本系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#宏观上看一个系统调用的过程"><span class="nav-number">3.1.1.</span> <span class="nav-text">宏观上看一个系统调用的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码细节"><span class="nav-number">3.1.2.</span> <span class="nav-text">代码细节</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#各种系统调用"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">各种系统调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写时复制导致的缺页中断"><span class="nav-number">3.1.3.</span> <span class="nav-text">写时复制导致的缺页中断</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#写时复制"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">写时复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理流程"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">处理流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码实现"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#缺页异常处理-内核中"><span class="nav-number">3.1.3.3.1.</span> <span class="nav-text">缺页异常处理(内核中)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缺页异常处理程序注册-用户中"><span class="nav-number">3.1.3.3.2.</span> <span class="nav-text">缺页异常处理程序注册(用户中)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流程图示-1"><span class="nav-number">3.1.3.4.</span> <span class="nav-text">流程图示</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fork实现"><span class="nav-number">3.2.</span> <span class="nav-text">fork实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fork的功能"><span class="nav-number">3.2.1.</span> <span class="nav-text">fork的功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#具体实现"><span class="nav-number">3.2.2.</span> <span class="nav-text">具体实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fork图示"><span class="nav-number">3.2.3.</span> <span class="nav-text">fork图示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间通信"><span class="nav-number">3.3.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">3.3.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现细节"><span class="nav-number">3.3.2.</span> <span class="nav-text">实现细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通信图示"><span class="nav-number">3.3.3.</span> <span class="nav-text">通信图示</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fjh</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
