<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="OS,env,">










<meta name="description" content="env进程结构管理先给大家安利一个神器：Understand，有了它，妈妈再也不担心我源码看吐了 首先神图镇楼  一点与lab3无关的在刚开始时，我个人一直疑惑的一个问题便是什么是OS的工作，而什么是硬件支持的工作，这个问题其实我现在还不是很清楚，下面写一点我的拙见：  关于地址：  页表项的填写是要操作系统来负责的，即在代码中显式填写 在代码中给一个虚拟地址来访问数据是由硬件支持的，并且他可以判">
<meta name="keywords" content="OS,env">
<meta property="og:type" content="article">
<meta property="og:title" content="OS-lab3">
<meta property="og:url" content="http://yoursite.com/2019/04/13/OS-lab3/index.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:description" content="env进程结构管理先给大家安利一个神器：Understand，有了它，妈妈再也不担心我源码看吐了 首先神图镇楼  一点与lab3无关的在刚开始时，我个人一直疑惑的一个问题便是什么是OS的工作，而什么是硬件支持的工作，这个问题其实我现在还不是很清楚，下面写一点我的拙见：  关于地址：  页表项的填写是要操作系统来负责的，即在代码中显式填写 在代码中给一个虚拟地址来访问数据是由硬件支持的，并且他可以判">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/04/13/OS-lab3/mm.png">
<meta property="og:image" content="http://yoursite.com/2019/04/13/OS-lab3/env_status.png">
<meta property="og:image" content="http://yoursite.com/2019/04/13/OS-lab3/envs.png">
<meta property="og:image" content="http://yoursite.com/2019/04/13/OS-lab3/create_call.png">
<meta property="og:image" content="http://yoursite.com/2019/04/13/OS-lab3/ELF.png">
<meta property="og:image" content="http://yoursite.com/2019/04/13/OS-lab3/segment1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/13/OS-lab3/segment2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/13/OS-lab3/segment3.png">
<meta property="og:image" content="http://yoursite.com/2019/04/13/OS-lab3/SR.png">
<meta property="og:image" content="http://yoursite.com/2019/04/13/OS-lab3/E.png">
<meta property="og:image" content="http://yoursite.com/2019/04/13/OS-lab3/save.png">
<meta property="og:image" content="http://yoursite.com/2019/04/13/OS-lab3/write.png">
<meta property="og:image" content="http://yoursite.com/2019/04/13/OS-lab3/1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/13/OS-lab3/2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/13/OS-lab3/3.png">
<meta property="og:image" content="http://yoursite.com/2019/04/13/OS-lab3/4.png">
<meta property="og:image" content="http://yoursite.com/2019/04/13/OS-lab3/5.png">
<meta property="og:updated_time" content="2019-05-03T12:10:56.232Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OS-lab3">
<meta name="twitter:description" content="env进程结构管理先给大家安利一个神器：Understand，有了它，妈妈再也不担心我源码看吐了 首先神图镇楼  一点与lab3无关的在刚开始时，我个人一直疑惑的一个问题便是什么是OS的工作，而什么是硬件支持的工作，这个问题其实我现在还不是很清楚，下面写一点我的拙见：  关于地址：  页表项的填写是要操作系统来负责的，即在代码中显式填写 在代码中给一个虚拟地址来访问数据是由硬件支持的，并且他可以判">
<meta name="twitter:image" content="http://yoursite.com/2019/04/13/OS-lab3/mm.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/13/OS-lab3/">





  <title>OS-lab3 | Matrix</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Matrix</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">just do it !</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/13/OS-lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fjh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OS-lab3</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-13T08:02:53+08:00">
                2019-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="env进程结构管理"><a href="#env进程结构管理" class="headerlink" title="env进程结构管理"></a>env进程结构管理</h1><p>先给大家安利一个神器：<code>Understand</code>，有了它，妈妈再也不担心我源码看吐了</p>
<p>首先神图镇楼</p>
<p><img src="/2019/04/13/OS-lab3/mm.png" alt></p>
<h2 id="一点与lab3无关的"><a href="#一点与lab3无关的" class="headerlink" title="一点与lab3无关的"></a>一点与lab3无关的</h2><p><strong>在刚开始时，我个人一直疑惑的一个问题便是什么是OS的工作，而什么是硬件支持的工作，这个问题其实我现在还不是很清楚，下面写一点我的拙见：</strong></p>
<ol>
<li><p>关于地址：</p>
<ul>
<li>页表项的填写是要操作系统来负责的，即在代码中显式填写</li>
<li>在代码中给一个虚拟地址来访问数据是由硬件支持的，并且他可以判断在<code>ULIM</code>上硬件就直接最高位置0然后访问，如果在下面就通过页表查找访问</li>
</ul>
<p><strong>这就解释了我们许多地方的地址变化看似功能上不是内核中的事，但是我们的虚拟地址都是用内核中才满足的转换函数，其实我个人认为就是由于我们页表结构还没填好所以暂时建立一个映射而已，其作用只是一个访问的作用而已，等利用他把页表建立好它也就没用了</strong></p>
</li>
<li><p>关于中断：</p>
<ul>
<li>在时间片用完之后硬件产生时间中断，跳转PC值</li>
<li>操作系统要负责记录当前进程的上下文，并且构建将要调度执行的进程的上下文（其实还要设置一大堆CPU的状态寄存器）</li>
</ul>
</li>
<li><p>……..</p>
</li>
</ol>
<h2 id="基本常数定义"><a href="#基本常数定义" class="headerlink" title="基本常数定义"></a>基本常数定义</h2><h3 id="最大进程数目"><a href="#最大进程数目" class="headerlink" title="最大进程数目"></a>最大进程数目</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG2NENV	10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NENV		(1&lt;&lt;LOG2NENV)</span></span><br></pre></td></tr></table></figure>
<p>即最多有2^10即1024个进程</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENV_FREE	0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENV_RUNNABLE		1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENV_NOT_RUNNABLE	2</span></span><br></pre></td></tr></table></figure>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><h3 id="env进程管理块"><a href="#env进程管理块" class="headerlink" title="env进程管理块"></a>env进程管理块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span> 	   <span class="comment">// 保存进程切换前后的寄存器值（即所谓的保存上下文）</span></span><br><span class="line">	LIST_ENTRY(Env) env_link;	   <span class="comment">// 在空闲进程队列env_free_list中链接下一项的指针</span></span><br><span class="line">	u_int env_id;                  <span class="comment">// 进程id号（每个进程的唯一标识）</span></span><br><span class="line">	u_int env_parent_id;           <span class="comment">// 父进程的id号 </span></span><br><span class="line">	u_int env_status;              <span class="comment">// 进程的状态</span></span><br><span class="line">	Pde  *env_pgdir;               <span class="comment">// 进程的页目录的内核中的起始虚拟地址 </span></span><br><span class="line">	u_int env_cr3;				  <span class="comment">// 进程的页目录的起始物理地址（即cr3寄存器中存储的值）</span></span><br><span class="line">	LIST_ENTRY(Env) env_sched_link;<span class="comment">// 在调度队列env_sched_list中链接下一项的指针</span></span><br><span class="line">	u_int env_pri;				  <span class="comment">// 进程的优先级，定义为进程可用的时间片个数</span></span><br><span class="line">    <span class="comment">// 之后的lab4再补充以下结构</span></span><br><span class="line">	u_int env_ipc_value;           </span><br><span class="line">	u_int env_ipc_from;           </span><br><span class="line">	u_int env_ipc_recving;        </span><br><span class="line">	u_int env_ipc_dstva;		</span><br><span class="line">	u_int env_ipc_perm;		</span><br><span class="line">	u_int env_pgfault_handler;    </span><br><span class="line">	u_int env_xstacktop;          </span><br><span class="line">	u_int env_runs;		</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">// 数据结构展开</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span> </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> regs[<span class="number">32</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cp0_status;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> hi;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> lo;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cp0_badvaddr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cp0_cause;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cp0_epc;	<span class="comment">//中断异常时执行的指令地址</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pc;		<span class="comment">//在进程切换回来时应该开始执行的地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LIST_ENTRY(type)						\</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>								\</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">le_next</span>;</span>	<span class="comment">/* next element */</span>			\</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">type</span> **<span class="title">le_prev</span>;</span>	<span class="comment">/* address of previous next element */</span>	\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="env-free-list"><a href="#env-free-list" class="headerlink" title="env_free_list"></a>env_free_list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env_list</span> <span class="title">env_free_list</span>;</span></span><br></pre></td></tr></table></figure>
<p>该结构的作用将<strong>待分配</strong>的空闲<code>env</code>控制块串成链表形式，该链表中的<code>env</code>控制块都是<strong><code>ENV_FREE</code>状态</strong></p>
<h3 id="env-sched-list"><a href="#env-sched-list" class="headerlink" title="env_sched_list"></a>env_sched_list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env_list</span> <span class="title">env_sched_list</span>[2];</span></span><br></pre></td></tr></table></figure>
<p>该结构的作用是将已经处于<strong>可运行状态</strong>的<code>env</code>控制块串成链表形式以便调度程序来调度运行（<strong>本质上就是分配给时间片</strong>），该链表中的<code>env</code>控制块都是<strong><code>ENV_RUNNABLE</code>状态</strong></p>
<p>具体使用详见进程调度算法</p>
<h3 id="进程的状态转移"><a href="#进程的状态转移" class="headerlink" title="进程的状态转移"></a>进程的状态转移</h3><p><img src="/2019/04/13/OS-lab3/env_status.png" alt></p>
<p>注 ： <strong>对用户而言只能调用<code>create</code>,不能使用<code>alloc</code>所以在其看来进程一旦创建便处于可执行状态了</strong></p>
<p>？？或者在<code>env_alloc</code>中设置为<code>ENV_NOT_RUNNABLE</code>,把设置<code>status = ENV_RUNNABLE</code>放在<code>create</code>层次其实更好？？</p>
<p><strong>此处有个坑(测试杀我) ： 评测函数env_check()中会调用env_alloc()，所以会创建一堆只建立了页表但是没有加载可执行文件的残疾进程，所以如果你在调度时只是简单的判断是否是<code>RUNNABLE</code>状态，则会让这些进程运行，然后就会报<code>TOO LOW</code>的错误</strong></p>
<h2 id="对进程的操作"><a href="#对进程的操作" class="headerlink" title="对进程的操作"></a>对进程的操作</h2><h3 id="初始化控制结构"><a href="#初始化控制结构" class="headerlink" title="初始化控制结构"></a>初始化控制结构</h3><h4 id="构建控制块数组"><a href="#构建控制块数组" class="headerlink" title="构建控制块数组"></a>构建控制块数组</h4><ol>
<li><p>函数实现</p>
<p><strong>该函数的流程与物理内存控制块<code>pages</code>的构建流程基本一样</strong></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pmap.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mips_vm_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// code</span></span><br><span class="line">	envs = (struct Env *)alloc(NENV * <span class="keyword">sizeof</span>(struct Env), BY2PG, <span class="number">1</span>);</span><br><span class="line">    n = ROUND(NENV * <span class="keyword">sizeof</span>(struct Env), BY2PG);</span><br><span class="line">    boot_map_segment(pgdir, UENVS, n, PADDR(envs), PTE_R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>图示分析</p>
<p><img src="/2019/04/13/OS-lab3/envs.png" alt></p>
</li>
</ol>
<h4 id="初始化控制结构-1"><a href="#初始化控制结构-1" class="headerlink" title="初始化控制结构"></a>初始化控制结构</h4><ol>
<li>函数实现</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 初始化空闲进程块链表</span></span><br><span class="line">	LIST_INIT(&amp;env_free_list);</span><br><span class="line">    <span class="comment">// 初始化待调度进程控制块链表</span></span><br><span class="line">	LIST_INIT(&amp;env_sched_list[<span class="number">0</span>]);</span><br><span class="line">	LIST_INIT(&amp;env_sched_list[<span class="number">1</span>]);</span><br><span class="line">	<span class="comment">// 初始时所有的进程控制块都是空闲的</span></span><br><span class="line">	<span class="keyword">for</span>(i=NENV<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		envs[i].env_status = ENV_FREE;</span><br><span class="line">		LIST_INSERT_HEAD(&amp;env_free_list,&amp;envs[i],env_link);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建一个进程"><a href="#创建一个进程" class="headerlink" title="创建一个进程"></a>创建一个进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_create_priority</span><span class="params">(u_char *binary, <span class="keyword">int</span> size, <span class="keyword">int</span> priority)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="comment">//分配进程控制块</span></span><br><span class="line">	<span class="keyword">if</span>(env_alloc(&amp;e,<span class="number">0</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,env can't create because alloc env failed!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//设计进程优先级，在我们的系统中即是一次可以使用的时间片个数</span></span><br><span class="line">	e-&gt;env_pri = priority；</span><br><span class="line">    <span class="comment">//加载二进制镜像</span></span><br><span class="line">	load_icode(e,binary,size);</span><br><span class="line">    <span class="comment">//将加载完之后的进程加入等待被调度的链表中</span></span><br><span class="line">	LIST_INSERT_HEAD(&amp;env_sched_link[<span class="number">0</span>], &amp;e, env_sched_link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数调用分析"><a href="#函数调用分析" class="headerlink" title="函数调用分析"></a>函数调用分析</h4><p><img src="/2019/04/13/OS-lab3/create_call.png" alt></p>
<h4 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h4><h5 id="分配进程所需资源"><a href="#分配进程所需资源" class="headerlink" title="分配进程所需资源"></a>分配进程所需资源</h5><p>即函数<code>env_alloc()</code>的作用，分配进程运行的必需资源，详细分析如下：</p>
<ol>
<li><p>函数流程 ：</p>
<ol>
<li>从进程控制块空闲链表中取出一个</li>
<li><strong>使用<code>snv_setup_vm</code>分配空间资源</strong></li>
<li>填写控制块中的各项数值</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">env_alloc</span><span class="params">(struct Env **<span class="keyword">new</span>, u_int parent_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="comment">// 从空闲进程块中分配一个控制块</span></span><br><span class="line">	<span class="keyword">if</span>((e=LIST_FIRST(&amp;env_free_list))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,alloc env failed!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 为进程分配运行必需的空间资源</span></span><br><span class="line">	env_setup_vm(e);</span><br><span class="line">    <span class="comment">// 填写控制块的项</span></span><br><span class="line">	e-&gt;env_parent_id = parent_id;</span><br><span class="line">	e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	e-&gt;env_runs = <span class="number">0</span>;</span><br><span class="line">	e-&gt;env_id = mkenvid(e);			    <span class="comment">//生成唯一的进程标识符</span></span><br><span class="line">    e-&gt;env_tf.cp0_status = <span class="number">0x10001004</span>;</span><br><span class="line">	e-&gt;env_tf.regs[<span class="number">29</span>] = USTACKTOP;		<span class="comment">//填写栈寄存器</span></span><br><span class="line">	<span class="comment">// 将使用过的控制块从空闲链表中移除</span></span><br><span class="line">	*<span class="keyword">new</span> = e;</span><br><span class="line">	LIST_REMOVE(e,env_link);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重点说明 ：</p>
<ol>
<li><p><code>env_setup_vm()</code>函数 ：</p>
<p>该函数作用是建立进程的页目录结构</p>
<p>注意点 ：</p>
<ul>
<li>对进程页目录的初始化（一部分来自拷贝了内核页目录）</li>
<li><strong>自映射机制的构建</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">env_setup_vm</span><span class="params">(struct Env *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	Pde *pgdir;</span><br><span class="line">    <span class="comment">// 给进程的页目录分配一个物理页</span></span><br><span class="line">	<span class="keyword">if</span> ((r = page_alloc(&amp;p)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		panic(<span class="string">"env_setup_vm - page_alloc error\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;pp_ref++;</span><br><span class="line">	pgdir = (Pde *)page2kva(p);<span class="comment">//将分配的物理页映射到kseg0中的一个虚拟地址方便之后填写</span></span><br><span class="line">  	<span class="comment">/* 之后的工作是对这个进程的页表中的项进行填写</span></span><br><span class="line"><span class="comment">  	 * 注意填写要区分</span></span><br><span class="line"><span class="comment">  	 * 1.没有在内核页表中完成映射的虚拟空间（UTOP向下：用户堆栈区) : 清空初始化</span></span><br><span class="line"><span class="comment">  	 * 2.已经在内核页表中映射好的虚拟空间（UTOP向上：ENVS,PAGES,USER VPT, kseg） ： 拷贝内核中对应页表项</span></span><br><span class="line"><span class="comment">  	 * 注：ENV,PAGES的映射是在mips_vm_init中通过boot_map_segment实现的</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PDX(UTOP); i++) &#123;</span><br><span class="line">		pgdir[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (i = PDX(UTOP); i &lt;= PDX(~<span class="number">0</span>); i++) &#123;</span><br><span class="line">		pgdir[i] = boot_pgdir[i];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 填写控制块信息</span></span><br><span class="line">	e-&gt;env_pgdir = pgdir;	<span class="comment">//进程页目录的起始虚拟内核地址</span></span><br><span class="line">	e-&gt;env_cr3   = PADDR(pgdir); <span class="comment">//进程页目录的起始物理地址</span></span><br><span class="line">	<span class="comment">// 之后的两条语句完成自映射机制</span></span><br><span class="line">    e-&gt;env_pgdir[PDX(VPT)]   = e-&gt;env_cr3 | PTE_V;<span class="comment">//将（进程页目录的起始物理地址）以（只读的权限）写入页目录中（内核空间的页目录起始虚拟地址VPT）对应的项</span></span><br><span class="line">    e-&gt;env_pgdir[PDX(UVPT)]  = e-&gt;env_cr3 | PTE_V | PTE_R;<span class="comment">//将（进程页目录的起始物理地址）以（读写的权限）写入页目录中（用户空间的页目录起始虚拟地址UVPT）对应的项</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>mkenvid()</code>函数</p>
<p>该函数的作用是生成唯一的进程标识符</p>
<ul>
<li><p>生成标识符 ：标识符分为两段</p>
<ul>
<li><p>使用<code>next_env_id</code>静态递增变量来<strong>保证不同进程的进程号一定不同</strong></p>
<p>占据高位段</p>
</li>
<li><p>使用<code>idx</code>即该进程控制块在<code>envs[]</code>的数组下标段来<strong>保证可以从进程号获得<code>env</code>控制块</strong></p>
<p>占据低11位段（因为只有1024项）</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function">u_int <span class="title">mkenvid</span><span class="params">(struct Env *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> u_long next_env_id = <span class="number">0</span>;</span><br><span class="line">	u_int idx = e - envs;</span><br><span class="line">    <span class="comment">//拼接两部分</span></span><br><span class="line">	<span class="keyword">return</span> (++next_env_id &lt;&lt; (<span class="number">1</span> + LOG2NENV)) | idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">envid2env</span><span class="params">(u_int envid, struct Env **penv, <span class="keyword">int</span> checkperm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="comment">//当前第一个进程还未创建其他进程</span></span><br><span class="line">	<span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">		*penv = curenv;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//依据低11位来取出index获得env结构体</span></span><br><span class="line">	e = &amp;envs[ENVX(envid)];</span><br><span class="line">    <span class="comment">//该进程未使用，</span></span><br><span class="line">    <span class="comment">//或者唯一进程标识符不同，</span></span><br><span class="line">    <span class="comment">//则取进程失败</span></span><br><span class="line">	<span class="keyword">if</span> (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid) &#123;</span><br><span class="line">		*penv = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//取出进程不是由当前进程创建的，即父子关系不对，则取出失败</span></span><br><span class="line">    <span class="keyword">if</span> (checkperm &amp;&amp; e != curenv &amp;&amp; e-&gt;env_parent_id != curenv-&gt;env_id)&#123;</span><br><span class="line">        *penv = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">	*penv = e;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>e-&gt;env_tf.cp0_status = 0x10001004;</code>语句：</p>
<p>待施工….。</p>
</li>
</ol>
</li>
</ol>
<h5 id="加载二进制映像"><a href="#加载二进制映像" class="headerlink" title="加载二进制映像"></a>加载二进制映像</h5><p>即函数<code>load_icode(struct Env *e, u_char *binary, u_int size)</code>的作用 ：</p>
<ol>
<li><p>函数流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_icode</span><span class="params">(struct Env *e, u_char *binary, u_int size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	u_long entry_point;</span><br><span class="line">	u_long r;</span><br><span class="line">    u_long perm;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span>(page_alloc(&amp;p)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry,alloc page failed!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//为用户栈空间分配一页物理内存并完成从[USTACKTOP-BY2PG, USTACKTOP]到分配物理空间的二级页结构映射</span></span><br><span class="line">    <span class="comment">//即构建进程的运行栈空间</span></span><br><span class="line">	perm = PTE_V|PTE_R;</span><br><span class="line">	page_insert(e-&gt;env_pgdir,p,USTACKTOP-BY2PG,perm);</span><br><span class="line">    <span class="comment">//加载二进文件</span></span><br><span class="line">    r = load_elf(binary,size,&amp;entry_point,e,load_icode_mapper);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Sorry.load entire image failed!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	e-&gt;env_tf.pc = entry_point;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>重点说明</p>
<ol>
<li><p><code>load_elf()</code>函数 ：</p>
<ul>
<li><p>参数含义 ：</p>
<ul>
<li><code>binary</code> ：待加载的二级制<code>ELF</code>文件的起始虚拟地址</li>
<li><code>size</code> ： <code>ELF</code>文件的字节数目</li>
<li><code>entry_point</code> ：程序的入口地址</li>
<li><code>*map</code>：函数指针，在此处即是调用<code>load_icode_mapper()</code></li>
</ul>
</li>
<li><p>函数作用 ：</p>
<p><strong>解析<code>ELF</code>文件头信息</strong>并把它加载到指定的虚拟内存区域，并建立对物理空间的二级页表映射</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel_elfloader.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">load_elf</span><span class="params">(u_char *binary, <span class="keyword">int</span> size, u_long *entry_point, <span class="keyword">void</span> *user_data,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">int</span> (*<span class="built_in">map</span>)(u_long va, <span class="keyword">u_int32_t</span> sgsize,</span></span></span><br><span class="line"><span class="function"><span class="params">						u_char *bin, <span class="keyword">u_int32_t</span> bin_size, <span class="keyword">void</span> *user_data))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//解析ELF文件头的信息（具体结构在下文）</span></span><br><span class="line">	Elf32_Ehdr *ehdr = (Elf32_Ehdr *)binary;</span><br><span class="line">	Elf32_Phdr *phdr = <span class="literal">NULL</span>;</span><br><span class="line">	u_char *ptr_ph_table = <span class="literal">NULL</span>;</span><br><span class="line">	Elf32_Half ph_entry_count;</span><br><span class="line">	Elf32_Half ph_entry_size;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="comment">//判断ELF文件是否合法</span></span><br><span class="line">	<span class="keyword">if</span> (size &lt; <span class="number">4</span> || !is_elf_format(binary)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获得segment结构头的起始地址指针</span></span><br><span class="line">	ptr_ph_table = binary + ehdr-&gt;e_phoff;</span><br><span class="line">    <span class="comment">//获得segment段的数目</span></span><br><span class="line">	ph_entry_count = ehdr-&gt;e_phnum;</span><br><span class="line">    <span class="comment">//获得一个segment结构头的大小</span></span><br><span class="line">	ph_entry_size = ehdr-&gt;e_phentsize;</span><br><span class="line">	<span class="comment">//遍历所有segment结构头</span></span><br><span class="line">	<span class="keyword">while</span> (ph_entry_count--) &#123;</span><br><span class="line">		phdr = (Elf32_Phdr *)ptr_ph_table;</span><br><span class="line">        <span class="comment">//如果该segment的类型是加载类型</span></span><br><span class="line">		<span class="keyword">if</span> (phdr-&gt;p_type == PT_LOAD) &#123;</span><br><span class="line">            <span class="comment">//将该segment段加载到其头结构指出的虚拟地址空间并建立二级页表映射</span></span><br><span class="line">			r = <span class="built_in">map</span>(phdr-&gt;p_vaddr, phdr-&gt;p_memsz,</span><br><span class="line">					binary + phdr-&gt;p_offset, phdr-&gt;p_filesz, user_data);</span><br><span class="line">			<span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> r;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//指下一个segment结构头</span></span><br><span class="line">		ptr_ph_table += ph_entry_size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 程序入口地址</span></span><br><span class="line">	*entry_point = ehdr-&gt;e_entry;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>load_icode_mapper()</code>函数 ：</p>
<ul>
<li><p>参数含义 ：</p>
<ul>
<li><code>va</code> : 该段要加载到的虚拟地址</li>
<li><code>sgsize</code> : 该段在内存中的大小</li>
<li><code>bin</code> : 该段在<code>ELF</code>文件中的内容的起始地址</li>
<li><code>bin_size</code> : 该段在文件中的大小</li>
</ul>
</li>
<li><p>函数作用 ：</p>
<p><strong>将<code>ELF</code>文件中的一个<code>segment</code>加载到指定的虚拟地址处并建立好对应的二级页表映射（主要通过<code>page_inset</code>建立），若内存中大小比在文件中大，则多余的位用0补</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_icode_mapper</span><span class="params">(u_long va, <span class="keyword">u_int32_t</span> sgsize,</span></span></span><br><span class="line"><span class="function"><span class="params">							 u_char *bin, <span class="keyword">u_int32_t</span> bin_size, <span class="keyword">void</span> *user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span> = (<span class="title">struct</span> <span class="title">Env</span> *)<span class="title">user_data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	u_long i;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">    <span class="comment">//获得va在其所在页中的偏移offset</span></span><br><span class="line">	u_long offset = va - ROUNDDOWN(va, BY2PG);</span><br><span class="line">	<span class="comment">//为二进制文件分配存储的物理页</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; bin_size; i += BY2PG) &#123;</span><br><span class="line">		<span class="keyword">if</span>(page_alloc(&amp;p)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Sorry,alloc page failed!\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;pp_ref++;</span><br><span class="line">        <span class="comment">//void bcopy(const void *src, void *dst, size_t len)</span></span><br><span class="line">        <span class="comment">//从src（虚拟源地址）复制len个字节到dst(虚拟目标地址)</span></span><br><span class="line">        <span class="comment">//下面的两个copy不好理解，具体看下图</span></span><br><span class="line">        <span class="comment">//总的来说，就是比较剩下待拷贝的数据大小与页的大小来决定拷贝的数据量，然后逐页拷贝</span></span><br><span class="line">        <span class="comment">//对第一个分配的页，可能页不从首地址开始，所以要特殊考虑</span></span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">			bcopy(bin,(<span class="keyword">char</span> *)page2kva(p)+offset,((BY2PG-offset)&lt;bin_size-i)?(BY2PG-offset):(bin_size - i));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			bcopy(bin+i-offset,(<span class="keyword">char</span> *)page2kva(p),(BY2PG&lt;bin_size-i+offset)?BY2PG:(bin_size-i+offset));</span><br><span class="line">        <span class="comment">//拷贝完之后p对应物理页中存储二进制数据</span></span><br><span class="line">        <span class="comment">//然后以读写的权限通过该进程的页表将va+i（即当前一页二进制数据应该加载到虚拟地址）映射到p对应的物理页上</span></span><br><span class="line">		r = page_insert(env-&gt;env_pgdir,p,va+i,PTE_V|PTE_R);</span><br><span class="line">		<span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Sorry,insert a page is failed!\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//当该segment在内存中的大小大于在文件中时</span></span><br><span class="line">    <span class="comment">//给多余的地址空间赋值为0（在page_alloc()中就已经清0） </span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; sgsize) &#123;</span><br><span class="line">		<span class="keyword">if</span>(page_alloc(&amp;p)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Sorry,alloc page failed!\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;pp_ref++;</span><br><span class="line">		r = page_insert(env-&gt;env_pgdir,p,va+i,PTE_V|PTE_R);</span><br><span class="line">		<span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Sorry,alloc page failed!\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">		&#125;</span><br><span class="line">		i+=BY2PG;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>图示</strong></p>
<ul>
<li><p><code>ELF</code>文件结构示意图</p>
<p><img src="/2019/04/13/OS-lab3/ELF.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ELF文件头结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	e_ident[EI_NIDENT];	<span class="comment">/* Magic number and other info */</span></span><br><span class="line">	Elf32_Half	e_type;			<span class="comment">/* Object file type */</span></span><br><span class="line">	Elf32_Half	e_machine;		<span class="comment">/* Architecture */</span></span><br><span class="line">	Elf32_Word	e_version;		<span class="comment">/* Object file version */</span></span><br><span class="line">	Elf32_Addr	e_entry;		<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">	Elf32_Off	e_phoff;		<span class="comment">/* Program header table file offset */</span></span><br><span class="line">	Elf32_Off	e_shoff;		<span class="comment">/* Section header table file offset */</span></span><br><span class="line">	Elf32_Word	e_flags;		<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">	Elf32_Half	e_ehsize;		<span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">	Elf32_Half	e_phentsize;	<span class="comment">/* Program header table entry size */</span></span><br><span class="line">	Elf32_Half	e_phnum;		<span class="comment">/* Program header table entry count */</span></span><br><span class="line">	Elf32_Half	e_shentsize;	<span class="comment">/* Section header table entry size */</span></span><br><span class="line">	Elf32_Half	e_shnum;		<span class="comment">/* Section header table entry count */</span></span><br><span class="line">	Elf32_Half	e_shstrndx;		<span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个segment结构头的结构，其管理一份segment段</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Elf32_Word	p_type;			<span class="comment">/* Segment type */</span></span><br><span class="line">	Elf32_Off	p_offset;		<span class="comment">/* Segment file offset */</span></span><br><span class="line">	Elf32_Addr	p_vaddr;		<span class="comment">/* Segment virtual address */</span></span><br><span class="line">	Elf32_Addr	p_paddr;		<span class="comment">/* Segment physical address */</span></span><br><span class="line">	Elf32_Word	p_filesz;		<span class="comment">/* Segment size in file */</span></span><br><span class="line">	Elf32_Word	p_memsz;		<span class="comment">/* Segment size in memory */</span></span><br><span class="line">	Elf32_Word	p_flags;		<span class="comment">/* Segment flags */</span></span><br><span class="line">	Elf32_Word	p_align;		<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载一个<code>segment</code>的示意图</p>
<p><img src="/2019/04/13/OS-lab3/segment1.png" alt></p>
<p><img src="/2019/04/13/OS-lab3/segment2.png" alt></p>
<p><img src="/2019/04/13/OS-lab3/segment3.png" alt></p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h3><p>主要使用<code>env_run(e)</code>方法运行线程e ：</p>
<ul>
<li>函数流程 ：<ol>
<li>从内存中取出当前线程（<code>curenv</code>）保存上下文的地方</li>
<li>将上下文信息存入当前线程（<code>curenv</code>）的控制块的<code>env_tf</code>结构中以便他切走</li>
<li>设置<code>e</code>为当前进程，并加载<code>e</code>进程的上下文信息</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMESTACK 0x82000000</span></span><br><span class="line"><span class="comment">//由当前进程切换到e进程执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_run</span><span class="params">(struct Env *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//old即为当前进程进程的上下文存储的地方</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> *<span class="title">old</span> = (<span class="title">struct</span> <span class="title">Trapframe</span> *)(<span class="title">TIMESTACK</span>-<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trapframe</span>));</span></span><br><span class="line">	<span class="keyword">if</span>(curenv)&#123;</span><br><span class="line">        <span class="comment">//将当前进程的上下文保存其进程控制块的的env_tf结构体变量中</span></span><br><span class="line">		bcopy(old,&amp;(curenv-&gt;env_tf),<span class="keyword">sizeof</span>(struct Trapframe));</span><br><span class="line">        <span class="comment">/* 填写存储进程再次切换回来时应该开始执行的指令地址</span></span><br><span class="line"><span class="comment">         * 我们的进程切换时由于分配时间片使用完之后导致的时钟中断</span></span><br><span class="line"><span class="comment">         * cp0_epc存储的是产生中断时的执行指令地址</span></span><br><span class="line"><span class="comment">         * 所以它就是我们进程再次切回时应该执行的指令，将其保存在env_tf。pc中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		curenv-&gt;env_tf.pc = old-&gt;cp0_epc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将当前进程切换到e</span></span><br><span class="line">	curenv = e;</span><br><span class="line">	curenv-&gt;env_runs ++;</span><br><span class="line">	<span class="comment">//（即切换页目录）加载要运行进程的页目录（env_cr3中保存了页目录的起始物理地址)</span></span><br><span class="line">	lcontext(KADDR(curenv-&gt;env_cr3));	</span><br><span class="line">    <span class="comment">//加载当前要运行的进程的上下文</span></span><br><span class="line">	env_pop_tf(&amp;(curenv-&gt;env_tf),GET_ENV_ASID(curenv-&gt;env_id));	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>分析<code>lcontext(KADDR(curenv-&gt;env_cr3))</code></p>
<p><strong>该函数的所用其实是加载要运行的进程的页目录虚拟地址到<code>mCONTEXT</code>这个全局变量中，其实也是构造进程运行环境的一部分</strong></p>
<p>让我们先追踪溯源 ：</p>
<ol>
<li><p><code>lcontext</code>的函数定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env_asm.S</span></span><br><span class="line">LEAF(lcontext)</span><br><span class="line">		.<span class="keyword">extern</span>	mCONTEXT</span><br><span class="line">		<span class="comment">//该操作即是将该进程的页目录的内核虚拟地址存入mCONTEXT中</span></span><br><span class="line">		sw		a0,mCONTEXT<span class="comment">//a0代表第一个参数，即为KADDR(curenv-&gt;cr3)</span></span><br><span class="line">		jr	ra</span><br><span class="line">		nop</span><br><span class="line">END(lcontext)</span><br></pre></td></tr></table></figure>
</li>
<li><p>出现了变量<code>mCONTEXT</code>我们继续来追踪溯源 ：</p>
<ul>
<li><p>定义处 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//start.S第45行</span></span><br><span class="line">			.globl mCONTEXT</span><br><span class="line">mCONTEXT:</span><br><span class="line">   			.word <span class="number">0</span><span class="comment">//即初值为0的一个字大小的全局变量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用处 ：我们目前只关注在这之前改变他值的操作，暂时不关心使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pmap.c第160行</span></span><br><span class="line">pgdir = alloc(BY2PG, BY2PG, <span class="number">1</span>);</span><br><span class="line">mCONTEXT = (<span class="keyword">int</span>)pgdir;<span class="comment">//mCONTEXT中保存的是内核中的页目录的起始内核虚拟地址</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><p>分析<code>env_pop_tf(&amp;(curenv-&gt;env_tf),GET_ENV_ASID(curenv-&gt;env_id));</code></p>
<p><strong>该函数的作用是构造要运行的进程的上下文环境，即从它的<code>env_tf</code>中取出上一次执行到结束时的环境，然后赋值给当前的运行环境，保证和上一次运行衔接</strong></p>
<ul>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//env_asm.S第15行</span></span><br><span class="line">LEAF(env_pop_tf)</span><br><span class="line"><span class="comment">/*传入参数</span></span><br><span class="line"><span class="comment"> *$a0 : 当前进程的env-&gt;env_tf起始地址，即上下文信息</span></span><br><span class="line"><span class="comment"> *$a1 : 当前进程的唯一标识（经过一定处理）//我也不知道他为什么要处理。。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.<span class="built_in">set</span>	mips1          </span><br><span class="line">		<span class="comment">//1:	j	1b</span></span><br><span class="line">	nop    </span><br><span class="line">		move	k0,a0 </span><br><span class="line">		mtc0	a1,CP0_ENTRYHI</span><br><span class="line">		<span class="comment">//是设置中断位，从禁止中断（即之前在时钟中断进入的核心态）到允许中断即将EXL：IE从10--&gt;00（详见下图）(?????)</span></span><br><span class="line">		mfc0	t0,CP0_STATUS                    </span><br><span class="line">		ori		t0,<span class="number">0x3</span>                          </span><br><span class="line">		xori	t0,<span class="number">0x3</span>                          </span><br><span class="line">		mtc0	t0,CP0_STATUS                    </span><br><span class="line">		<span class="comment">//加载进程控制块的储存上下文信息的tf中的值到对应的寄存器中去	</span></span><br><span class="line">		lw	v1,TF_LO(k0)                                       </span><br><span class="line">		mtlo	v1                               </span><br><span class="line">		lw	v0,TF_HI(k0)                     </span><br><span class="line">		lw	v1,TF_EPC(k0)                    </span><br><span class="line">		mthi	v0                               </span><br><span class="line">		mtc0	v1,CP0_EPC  </span><br><span class="line">		lw	$<span class="number">31</span>,TF_REG31(k0)                 </span><br><span class="line">		...........                </span><br><span class="line">		lw	$<span class="number">1</span>,TF_REG1(k0)</span><br><span class="line">		lw	k1,TF_PC(k0)</span><br><span class="line">		lw	k0,TF_STATUS(k0)                 </span><br><span class="line">		nop</span><br><span class="line">        <span class="comment">//跟新CP0协处理器的状态</span></span><br><span class="line">		mtc0	k0,CP0_STATUS</span><br><span class="line">		j	k1</span><br><span class="line">		rfe</span><br><span class="line">		nop</span><br><span class="line">END(env_pop_tf)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/OS-lab3/SR.png" alt></p>
<p><img src="/2019/04/13/OS-lab3/E.png" alt></p>
</li>
<li><p>图解进程切换</p>
<p><img src="/2019/04/13/OS-lab3/save.png" alt></p>
<p><img src="/2019/04/13/OS-lab3/write.png" alt></p>
</li>
</ul>
</li>
</ul>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>我的傻瓜调度 ：</p>
<p>进程调度主要依赖于函数<code>sched_yield()</code>以及数据结构<code>env_sched_list[2]</code>（这两个链表构造出一种类似于循环链表的形式） :</p>
<ul>
<li><p>调度原理</p>
<ol>
<li><p>初始经过<code>env_create_priority()</code>创建的进程（已经加载过二进制文件随时可以调度执行）加入到<code>env_sched_list[0]</code>中去</p>
</li>
<li><p>每次符合调度条件时，将当前要调度走的进程插入另一个调度队列，然后试图从当前调度队列中拿出一项可调度的，<strong>如果没有则换另一个链表寻找</strong></p>
</li>
<li>拿到要切换到的进程后，<strong>将时间片计数值清0</strong>，然后调用<code>env_run()</code>进行切换</li>
</ol>
<p>注：在调度第一个进程时行为有所不同</p>
</li>
<li><p>调度算法实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sched.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_yield</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录当前进程已经使用的时间片数目</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//t = 0/1表示从哪个待调度队列中取进程</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	counter++;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 切换进程的条件</span></span><br><span class="line"><span class="comment">     * 1. 当前进程时NULL，这种情况只发生在运行第一个进程的时候</span></span><br><span class="line"><span class="comment">     * 2. 当前进程的时间片已经用完了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">if</span> (curenv == <span class="literal">NULL</span> || counter &gt;= curenv-&gt;env_pri)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 如果不是第一次运行进程，则要将当前进程添加到另一个待调度队列中以便下一次调度</span></span><br><span class="line">		<span class="keyword">if</span> (curenv != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LIST_INSERT_TAIL(&amp;env_sched_link[t^<span class="number">1</span>], curenv, env_sched_link);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//在当前调度队列中寻找下一个可调度来运行的进程</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span>  <span class="title">Env</span> *<span class="title">e</span> = <span class="title">LIST_FIRST</span>(&amp;<span class="title">env_sched_link</span>[<span class="title">t</span>]);</span></span><br><span class="line">            <span class="comment">//如果没找到，则换一个调度队列继续找</span></span><br><span class="line">			<span class="keyword">if</span> (e == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				t = t ^ <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//找到一个可执行的</span></span><br><span class="line">			<span class="keyword">if</span> (e-&gt;env_status == ENV_RUNNABLE)</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">//从待调度队列中移除</span></span><br><span class="line">				LIST_REMOVE(e, env_sched_link);</span><br><span class="line">                <span class="comment">//初始化已使用时间片个数</span></span><br><span class="line">				counter = <span class="number">0</span>;</span><br><span class="line">				env_run(e);<span class="comment">//在env_run()方法中会将curenv设置为e</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果不需要调度则当前进程继续执行</span></span><br><span class="line">	env_run(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图示</p>
<p>以我们指导书的两个线程为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENV_CREATE_PRIORITY(user_A, <span class="number">2</span>);</span><br><span class="line">ENV_CREATE_PRIORITY(user_B, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//调度顺序应该为BABABA</span></span><br><span class="line"><span class="comment">//其中一次B占1个时间片，一个A占2个时间片</span></span><br></pre></td></tr></table></figure>
<ol>
<li>初始进程建立好之后</li>
</ol>
<p><img src="/2019/04/13/OS-lab3/1.png" alt></p>
<ol start="2">
<li>第一次调度执行B</li>
</ol>
<p><img src="/2019/04/13/OS-lab3/2.png" alt></p>
<ol start="3">
<li>第二次调度执行A</li>
</ol>
<p><img src="/2019/04/13/OS-lab3/3.png" alt></p>
<ol start="3">
<li>第三次调度又执行B</li>
</ol>
<p><img src="/2019/04/13/OS-lab3/4.png" alt></p>
<p><img src="/2019/04/13/OS-lab3/5.png" alt></p>
</li>
</ul>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>在<code>lab3</code>中所有的进程切换都是时钟中断导致的</p>
<p>流程如下 : (异常处理详见<code>lab4</code>)</p>
<ol>
<li>硬件完成 : 产生时间中断,CPU保存信息(异常原因,<code>EPC</code>等),跳转到异常分发代码</li>
<li>软件完成 : <ol>
<li>根据<code>CAUSE</code>寄存器中的<code>ExcCode</code>判断为时钟中断,跳转到对于的处理函数<code>hand_int</code></li>
<li>处理函数进行异常的处理</li>
<li>处理完之后返回,恢复运行</li>
</ol>
</li>
</ol>
<p>异常处理函数如下 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NESTED(handle_int, TF_SIZE, sp)</span><br><span class="line">nop</span><br><span class="line">SAVE_ALL	<span class="comment">//保存现场,将寄存器的值压栈(TIMESTACK栈)</span></span><br><span class="line">CLI			<span class="comment">//异常处理中关闭时钟中断</span></span><br><span class="line">.<span class="built_in">set</span>	at</span><br><span class="line">mfc0	t0, CP0_CAUSE</span><br><span class="line">mfc0	t2, CP0_STATUS</span><br><span class="line"><span class="keyword">and</span>	t0, t2</span><br><span class="line">andi	t1, t0, STATUSF_IP4</span><br><span class="line">bnez	t1, timer_irq	<span class="comment">//timer_irq为真正的处理函数</span></span><br><span class="line">nop</span><br><span class="line">END(handle_int)</span><br><span class="line"></span><br><span class="line">timer_irq:</span><br><span class="line"><span class="number">1</span>:	j	sched_yield	<span class="comment">//异常处理即为切换进程</span></span><br><span class="line">	nop</span><br><span class="line">	j	ret_from_exception	<span class="comment">//恢复现场(其实不会恢复,因为j跳转不会记录返回地址)</span></span><br><span class="line">	<span class="comment">//真正的恢复寄存器的值应该是新调度运行的进程的,而不是老进程的,即由env_pop_tf函数完成</span></span><br><span class="line">	nop</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/OS/" rel="tag"># OS</a>
          
            <a href="/tags/env/" rel="tag"># env</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/12/Write-Read/" rel="next" title="Write-Read">
                <i class="fa fa-chevron-left"></i> Write-Read
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/03/OS-lab4/" rel="prev" title="OS-lab4">
                OS-lab4 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">fjh</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#env进程结构管理"><span class="nav-number">1.</span> <span class="nav-text">env进程结构管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一点与lab3无关的"><span class="nav-number">1.1.</span> <span class="nav-text">一点与lab3无关的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本常数定义"><span class="nav-number">1.2.</span> <span class="nav-text">基本常数定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最大进程数目"><span class="nav-number">1.2.1.</span> <span class="nav-text">最大进程数目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程状态"><span class="nav-number">1.2.2.</span> <span class="nav-text">进程状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本数据结构"><span class="nav-number">1.3.</span> <span class="nav-text">基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#env进程管理块"><span class="nav-number">1.3.1.</span> <span class="nav-text">env进程管理块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#env-free-list"><span class="nav-number">1.3.2.</span> <span class="nav-text">env_free_list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#env-sched-list"><span class="nav-number">1.3.3.</span> <span class="nav-text">env_sched_list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的状态转移"><span class="nav-number">1.3.4.</span> <span class="nav-text">进程的状态转移</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对进程的操作"><span class="nav-number">1.4.</span> <span class="nav-text">对进程的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化控制结构"><span class="nav-number">1.4.1.</span> <span class="nav-text">初始化控制结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构建控制块数组"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">构建控制块数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化控制结构-1"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">初始化控制结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建一个进程"><span class="nav-number">1.4.2.</span> <span class="nav-text">创建一个进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数调用分析"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">函数调用分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流程分析"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">流程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分配进程所需资源"><span class="nav-number">1.4.2.2.1.</span> <span class="nav-text">分配进程所需资源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#加载二进制映像"><span class="nav-number">1.4.2.2.2.</span> <span class="nav-text">加载二进制映像</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程运行"><span class="nav-number">1.4.3.</span> <span class="nav-text">进程运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程调度"><span class="nav-number">1.4.4.</span> <span class="nav-text">进程调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程切换"><span class="nav-number">1.4.5.</span> <span class="nav-text">进程切换</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fjh</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
